Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 1
DarkX.ASM



      1					 .386p
      2					 NOWARN	PRO
      3					 JUMPS
      4
      5					 ; stack sizes in DWORDs
      6		  =1000			 PM_STACKSIZE	 EQU 1000h	 ; 4Kb
      7		  =1000			 RM_STACKSIZE	 EQU 1000h	 ; 4Kb
      8
      9					 ; TASM	3.1 no ensambla	bien los PUSH's	de offsets de 32 bits
     10					 pushd MACRO address_32
     11						 db 68h
     12						 dw offset address_32,0
     13					 ENDM
     14
     15					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     16					 ; SEGMENTO DE DATOS DE	PROGRAMA
     17					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     18
     19	    0000			 TXDATA	 SEGMENT USE16 'DATA'
     20
     21	    0000  44 61	72 6B 58 20 2D+		 copyright_msg		 db "DarkX - the DarkRising DOS	Extender [ v0.98.1 ] (c)    +
     22		  20 74	68 65 20 44 61+	 1998",13,10
     23		  72 6B	52 69 73 69 6E+
     24		  67 20	44 4F 53 20 45+
     25		  78 74	65 6E 64 65 72+
     26		  20 5B	20 76 30 2E 39+
     27		  38 2E	31 20 5D 20 28+
     28		  63 29	20 31 39 39 38+
     29		  0D 0A
     30	    003A  45 78	74 65 6E 64 65+					 db "Extender by B52 , Memory Manager and LE loader by	    +
     31		  72 20	62 79 20 42 35+	 Teknik",13,10
     32		  32 20	2C 20 4D 65 6D+
     33		  6F 72	79 20 4D 61 6E+
     34		  61 67	65 72 20 61 6E+
     35		  64 20	4C 45 20 6C 6F+
     36		  61 64	65 72 20 62 79+
     37		  20 54	65 6B 6E 69 6B+
     38		  0D 0A
     39	    0074  3C 20	68 74 74 70 3A+					 db "< http://thedarkrising.home.ml.org	>",13,10,"$"
     40		  2F 2F	74 68 65 64 61+
     41		  72 6B	72 69 73 69 6E+
     42		  67 2E	68 6F 6D 65 2E+
     43		  6D 6C	2E 6F 72 67 20+
     44		  3E 0D	0A 24
     45
     46	    009B  20 FE	20 43 50 55 20+		 cpu_type_msg		 db " þ	CPU Family:  $"
     47		  46 61	6D 69 6C 79 3A+
     48		  20 20	24
     49	    00AC  00B2r	00B6r 00BAr		 cpu_strings		 dw offset cpu386,offset cpu486,offset pentium_cpu
     50	    00B2  33 38	36 24			 cpu386			 db "386$"
     51	    00B6  34 38	36 24			 cpu486			 db "486$"
     52	    00BA  50 65	6E 74 69 75 6D+		 pentium_cpu		 db "Pentium+$"
     53		  2B 24
     54	    00C3  00CDr	0000 00D5r    +		 fpu_strings		 dw offset nofpu,0,offset fpu287,offset	fpu387,offset fpu487
     55		  00DBr	00E1r
     56	    00CD  20 6E	6F 20 46 50 55+		 nofpu			 db " no FPU$"
     57		  24
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 2
DarkX.ASM



     58	    00D5  20 2B	32 38 37 24		 fpu287			 db " +287$"
     59	    00DB  20 2B	33 38 37 24		 fpu387			 db " +387$"
     60	    00E1  20 2B	34 38 37 24		 fpu487			 db " +487$"
     61	    00E7  0D 0A	20 FE 20 53 79+		 sys_type_msg		 db 13,10," þ System Type: $"
     62		  73 74	65 6D 20 54 79+
     63		  70 65	3A 20 24
     64	    00FA  0102r	0106r 010Br   +		 sys_types		 dw offset raw_msg,offset vcpi_msg,offset dpmi_msg,offset   +
     65		  0110r			 xms_msg
     66	    0102  52 41	57 24			 raw_msg		 db "RAW$"
     67	    0106  56 43	50 49 24		 vcpi_msg		 db "VCPI$"
     68	    010B  44 50	4D 49 24		 dpmi_msg		 db "DPMI$"
     69	    0110  58 4D	53 24			 xms_msg		 db "XMS$"
     70	    0114  0D 0A	20 FE 20 44 4F+		 dos_mem_msg		 db 13,10," þ DOS memory:  $"
     71		  53 20	6D 65 6D 6F 72+
     72		  79 3A	20 20 24
     73	    0127  20 4B	62 0D 0A 20 FE+		 extended_mem_msg	 db " Kb",13,10," þ DPMI memory: $"
     74		  20 44	50 4D 49 20 6D+
     75		  65 6D	6F 72 79 3A 20+
     76		  24
     77	    013D  20 4B	62 0D 0A 0A 24		 kb_msg			 db " Kb",13,10,10,"$"
     78
     79	    0144  45 72	72 6F 72 3A 20+		 dos_version_error_msg	 db "Error: DOS	v3.0 or	better needed$"
     80		  44 4F	53 20 76 33 2E+
     81		  30 20	6F 72 20 62 65+
     82		  74 74	65 72 20 6E 65+
     83		  65 64	65 64 24
     84	    0165  45 72	72 6F 72 3A 20+		 A20_error_msg		 db "Error: Could not enable A20 line$"
     85		  43 6F	75 6C 64 20 6E+
     86		  6F 74	20 65 6E 61 62+
     87		  6C 65	20 41 32 30 20+
     88		  6C 69	6E 65 24
     89	    0186  45 72	72 6F 72 3A 20+		 v86_error_msg		 db "Error: System is in V86 mode and no VCPI/DPMI manager  +
     90		  53 79	73 74 65 6D 20+	 found$"
     91		  69 73	20 69 6E 20 56+
     92		  38 36	20 6D 6F 64 65+
     93		  20 61	6E 64 20 6E 6F+
     94		  20 56	43 50 49 2F 44+
     95		  50 4D	49 20 6D 61 6E+
     96		  61 67	65 72 20 66 6F+
     97		  75 6E	64 24
     98	    01C2  45 72	72 6F 72 3A 20+		 no386_error_msg	 db "Error: No 386 or better processor found$"
     99		  4E 6F	20 33 38 36 20+
    100		  6F 72	20 62 65 74 74+
    101		  65 72	20 70 72 6F 63+
    102		  65 73	73 6F 72 20 66+
    103		  6F 75	6E 64 24
    104
    105						 ; loader error	messages
    106	    01EA  45 72	72 6F 72 3A 20+		 exe_size_error_msg	 db "Error: Not	enough memory to load program$"
    107		  4E 6F	74 20 65 6E 6F+
    108		  75 67	68 20 6D 65 6D+
    109		  6F 72	79 20 74 6F 20+
    110		  6C 6F	61 64 20 70 72+
    111		  6F 67	72 61 6D 24
    112	    0213  45 72	72 6F 72 3A 20+		 load_error_msg		 db "Error: Unable to load EXE file from disk (error in	disk+
    113		  55 6E	61 62 6C 65 20+	 operations)$"
    114		  74 6F	20 6C 6F 61 64+
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 3
DarkX.ASM



    115		  20 45	58 45 20 66 69+
    116		  6C 65	20 66 72 6F 6D+
    117		  20 64	69 73 6B 20 28+
    118		  65 72	72 6F 72 20 69+
    119		  6E 20	64 69 73 6B 20+
    120		  6F 70	65 72 61 74 69+
    121		  6F 6E	73 29 24
    122	    0257  45 72	72 6F 72 3A 20+		 unsuported_feature_msg	 db "Error: Linear executable contains a feature not	    +
    123		  4C 69	6E 65 61 72 20+	 suported by the loader$"
    124		  65 78	65 63 75 74 61+
    125		  62 6C	65 20 63 6F 6E+
    126		  74 61	69 6E 73 20 61+
    127		  20 66	65 61 74 75 72+
    128		  65 20	6E 6F 74 20 73+
    129		  75 70	6F 72 74 65 64+
    130		  20 62	79 20 74 68 65+
    131		  20 6C	6F 61 64 65 72+
    132		  24
    133	    029E  45 72	72 6F 72 3A 20+		 desc_alloc_error_msg	 db "Error: Could not allocate descriptors$"
    134		  43 6F	75 6C 64 20 6E+
    135		  6F 74	20 61 6C 6C 6F+
    136		  63 61	74 65 20 64 65+
    137		  73 63	72 69 70 74 6F+
    138		  72 73	24
    139	    02C4  45 72	72 6F 72 3A 20+		 bad_exec_error_msg	 db "Error: Program is NOT a Linear or DOS32 Executable$"
    140		  50 72	6F 67 72 61 6D+
    141		  20 69	73 20 4E 4F 54+
    142		  20 61	20 4C 69 6E 65+
    143		  61 72	20 6F 72 20 44+
    144		  4F 53	33 32 20 45 78+
    145		  65 63	75 74 61 62 6C+
    146		  65 24
    147	    02F7  45 72	72 6F 72 3A 20+		 comp_exe_error_msg	 db "Error: DLINK executable is	compressed$"
    148		  44 4C	49 4E 4B 20 65+
    149		  78 65	63 75 74 61 62+
    150		  6C 65	20 69 73 20 63+
    151		  6F 6D	70 72 65 73 73+
    152		  65 64	24
    153
    154	    031D  ????????			 dos_mem_size		 dd ?
    155
    156						 ; EXE info (OEM function 3201h)
    157	    0321				 exe_info_struc		 LABEL
    158						 ;**********************************
    159	    0321  00000000			 program_offset		 dd 0	 ; 0 if	Linear Executable
    160	    0325  ????????			 psp_offset		 dd ?
    161	    0329  ????????			 env_offset		 dd ?
    162	    032D  ????????			 program_name_ptr	 dd ?
    163	    0331  0010				 zero_sel		 dw 2 SHL 3	 ; =D32_SEL without DPMI
    164	    0333  0030				 prog_sel		 dw 6 SHL 3	 ; =DATA_SEL without DPMI
    165	    0335  0040				 psp_selector		 dw PSP_SEL	 ; sin DPMI ser  ‚ste
    166	    0337  0038				 env_selector		 dw ENV_SEL	 ; para	vars. de entorno
    167	    0339  ????				 disk_seg		 dw ?
    168						 ;**********************************
    169	    033B  00000000			 exe_size		 dd 0	 ; 0 with LE's (not implemented)
    170
    171						 ; system info
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 4
DarkX.ASM



    172	    033F  ????				 cpu_info		 dw ?
    173	    0341  00				 system_type		 db 0	 ; 0=RAW
    174	    0342  04				 fpu_info		 db 4	 ; 487 if fpuid	is not executed	(Pentium)
    175
    176	    0343  ????????			 extended_heap_size	 dd ?
    177
    178	    0347  00000000			 xms_entry_point	 dd 0	 ; si es 0, es que no hay XMS
    179
    180	    034B  ????????			 vcpi_entry_point	 dd ?
    181	    034F  0050							 dw VCPI_CODE_SEL
    182
    183	    0351  00000000			 dir_base		 dd 0
    184	    0355  00000000			 page_dir_base		 dd 0
    185	    0359  00000000			 page_dir_entries	 dd 0
    186
    187	    035D  45 72	72 6F 72 20 69+		 vcpi_init_err_msg	 db "Error initializing	VCPI!$"
    188		  6E 69	74 69 61 6C 69+
    189		  7A 69	6E 67 20 56 43+
    190		  50 49	21 24
    191
    192	    0376  ????				 pm_ds			 dw ?
    193	    0378  ????				 pm_es			 dw ?
    194	    037A  ????				 pm_fs			 dw ?
    195	    037C  ????				 pm_gs			 dw ?
    196	    037E  ????				 pm_ss			 dw ?
    197
    198	    0380  44 50	4D 49 20 64 6F+		 dpmi_32b_error		 db "DPMI does not support 32bit programs!$"
    199		  65 73	20 6E 6F 74 20+
    200		  73 75	70 70 6F 72 74+
    201		  20 33	32 62 69 74 20+
    202		  70 72	6F 67 72 61 6D+
    203		  73 21	24
    204	    03A6  45 72	72 6F 72 20 69+		 dpmi_init_error	 db "Error initializing	DPMI!$"
    205		  6E 69	74 69 61 6C 69+
    206		  7A 69	6E 67 20 44 50+
    207		  4D 49	21 24
    208
    209	    03BF				 dpmi_rm_call_struc	 LABEL
    210	    03BF  08*(????????)						 dd 8 dup(?)
    211	    03DF  09*(????)						 dw 9 dup(?)
    212
    213	    03F1  ????				 dpmi_private_buffer	 dw ?
    214
    215	    03F3  ????????			 dpmi_save_restore_real	 dd ?
    216	    03F7  ???? ???? ????		 dpmi_save_restore_pm	 dw ?,?,?
    217
    218	    03FD  ????????			 dpmi_real_to_pm	 dd ?
    219	    0401  ???? ???? ????		 dpmi_pm_to_real	 dw ?,?,?
    220
    221	    0407  20*(00)			 dpmi_rm_call		 db 32 dup(0)
    222
    223	    0427  07*(00000000)			 dpmi_sels		 dd SELECTORS dup(0)
    224
    225	    0443  5A*(00)			 dpmi_exc_handlers	 db 6*15 dup(0)
    226	    049D  0000 0000 0000		 dpmi_old_int21h	 dw 0,0,0
    227	    04A3  0000 0000 0000		 dpmi_old_int31h	 dw 0,0,0
    228
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 5
DarkX.ASM



    229	    04A9  00				 dpmi_exception_flag	 db 0
    230
    231	    04AA  45 72	72 6F 72 3A 20+		 not_enough_mem		 db "Error: Not	enough conventional memory$"
    232		  4E 6F	74 20 65 6E 6F+
    233		  75 67	68 20 63 6F 6E+
    234		  76 65	6E 74 69 6F 6E+
    235		  61 6C	20 6D 65 6D 6F+
    236		  72 79	24
    237
    238	    04D0  ????				 psp_seg		 dw ?
    239
    240						 ; registros en	modo real antes	del salto a protegido
    241	    04D2				 rm_regs_struc		 LABEL
    242	    04D2  00000000			 real_edi		 dd 0
    243	    04D6  00000000			 real_esi		 dd 0
    244	    04DA  00000000			 real_ebp		 dd 0
    245	    04DE  00000000						 dd 0	 ; reserverd
    246	    04E2  00000000			 real_ebx		 dd 0
    247	    04E6  00000000			 real_edx		 dd 0
    248	    04EA  00000000			 real_ecx		 dd 0
    249	    04EE  00000000			 real_eax		 dd 0
    250	    04F2  0000				 real_flags		 dw 0
    251	    04F4  0000				 real_es		 dw 0
    252	    04F6  0000				 real_ds		 dw 0
    253	    04F8  0000				 real_fs		 dw 0
    254	    04FA  0000				 real_gs		 dw 0
    255	    04FC  0000 0000						 dw 0,0	 ; CS:IP
    256	    0500  0000 0000						 dw 0,0	 ; SS:SP
    257
    258						 ; registros en	modo protegido antes del salto a real
    259	    0504  00000000			 pm_eax			 dd 0
    260	    0508  00000000			 pm_ebx			 dd 0
    261	    050C  00000000			 pm_ecx			 dd 0
    262	    0510  00000000			 pm_edx			 dd 0
    263	    0514  00000000			 pm_esi			 dd 0
    264	    0518  00000000			 pm_edi			 dd 0
    265	    051C  00000000			 pm_ebp			 dd 0
    266	    0520  00000000			 pm_esp			 dd 0
    267	    0524  00000000			 pm_eflags		 dd 0
    268
    269	    0528  ???????? ????????		 ret_info		 dd ?,?		 ; EIP,CS
    270
    271	    0530  001Dr				 set_pm_address		 dw offset set_pm_raw
    272
    273	    0532  ????????			 prot_code_address	 dd ?
    274	    0536  ????							 dw ?		 ; selector de c¢digo de 32 bits
    275
    276	    0538  0000r	0000			 ret_real_address	 dw offset ret_real_raw,0
    277
    278	    053C				 gdt_reg		 label fword
    279	    053C  00AF				 gdt_limit		 dw (NUM_DESCS + FREE_DESCS) * 8 - 1
    280	    053E  ????????			 gdt_base		 dd ?
    281
    282	    0542				 idt_reg		 label fword
    283	    0542  07FF				 idt_limit		 dw 256	* 8 -1	 ; 256 descriptores (1 por gate)
    284	    0544  ????????			 idt_base		 dd ?
    285
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 6
DarkX.ASM



    286	    0548				 idt_real		 label fword
    287	    0548  FFFF							 dw 0FFFFh
    288	    054A  00000000						 dd 0
    289
    290						 ; "system registers" para pasarle al VCPI
    291	    054E				 vcpi_sys_regs		 LABEL
    292	    054E  00000000			 vcpi_cr3		 dd 0			 ; valor del cr3
    293	    0552  0000053Cr			 vcpi_gdtr		 dd offset gdt_reg	 ; linear address de la	GDT (1er Mb)
    294	    0556  00000542r			 vcpi_idtr		 dd offset idt_reg	 ;   "	     "	  de la	IDT (1er Mb)
    295	    055A  0000				 vcpi_ldtr		 dw 0			 ; valor del LDTR
    296	    055C  0048				 vcpi_tr		 dw TSS_SEL		 ;   "	  "  TR
    297	    055E  00000000			 vcpi_cs_eip		 dd 0			 ; entry point (CS:EIP)	para el
    298	    0562  ????							 dw ?			 ; modo	protegido
    299
    300						 INCLUDE gdt.inc
1   301		  =000C			 NUM_DESCS	 EQU 12		 ; 12 descriptores de DarkX (3 de VCPI)
1   302		  =000A			 FREE_DESCS	 EQU 10		 ; allocatable descriptors for application
1   303
1   304		  =0040			 PSP_SEL	 EQU 8 SHL 3
1   305		  =0038			 ENV_SEL	 EQU 7 SHL 3
1   306		  =0048			 TSS_SEL	 EQU 9 SHL 3
1   307		  =0050			 VCPI_CODE_SEL	 EQU 10	SHL 3
1   308
1   309					 ; NOTA	: ponemos los bits de acceso a 1 para que el procesador	no tenga que
1   310					 ;	  ponerlos a 1 cuando se accedan y tener c¢digo	m s efectivo
1   311					 ;	  ( v lido para	486 y Pentium )
1   312
1   313	    0564			 gdt		 label
1   314
1   315	    0564  08*(00)		 zero_descriptor	 db	 8 dup(0)
1   316
1   317	    056C  FFFF			 code_descriptor	 dw	 0FFFFh		 ; 4 Gb
1   318	    056E  ????						 dw	 ?		 ; b15-0 de base de segmento
1   319	    0570  ??						 db	 ?		 ; b23-16 de base de segmento
1   320	    0571  9B						 db	 10011011b	 ; b7 present bit = 1
1   321											 ; b6-5	priv. level = 0
1   322											 ; b4 sistema =	1 (code/data)
1   323											 ; b3 ejecutable = 1 (s¡)
1   324											 ; b2 conforming (???) = 0
1   325											 ; b1 bit de lectura = 1 (s¡)
1   326											 ; b0 bit de acceso = 1
1   327	    0572  CF						 db	 11001111b	 ; b7 granularidad = 1 (p gs.)
1   328											 ; b6 op. size = 1 (32 bits)
1   329											 ; b5 ???
1   330											 ; b4 not used
1   331											 ; b3-0	= b19-16 de l¡mite
1   332	    0573  00						 db	 0		 ; b31-24 de la	base
1   333
1   334	    0574  FFFF			 data_descriptor	 dw 0FFFFh		 ; 4 Gb
1   335	    0576  0000						 dw	 0		 ; b15-0 de base de segmento
1   336	    0578  00						 db	 0		 ; b23-16 de base de segmento
1   337	    0579  93						 db	 10010011b	 ; b7 present bit = 1
1   338											 ; b6-5	priv. level = 0
1   339											 ; b4 sistema =	1 (code/data)
1   340											 ; b3 ejecutable = 0 (no)
1   341											 ; b2 expandible hacia arriba
1   342											 ; b1 W	= 1 (read/write)
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 7
DarkX.ASM



1   343											 ; b0 bit de acceso = 1
1   344	    057A  CF						 db	 11001111b	 ; b7 granularidad = 1 (p gs.)
1   345											 ; b6 op. size = 1 (32 bits)
1   346											 ; b5 ???
1   347											 ; b4 not used
1   348											 ; b3-0	= b19-16 de l¡mite
1   349	    057B  00						 db	 0		 ; b31-24 de la	base
1   350
1   351	    057C  FFFF			 c16_desc		 dw	 0FFFFh
1   352	    057E  ????						 dw	 ?
1   353	    0580  ??						 db	 ?
1   354	    0581  9B						 db	 9Ah OR	1
1   355	    0582  00						 db	 0	 ; segmento de 16 bits de 64Kb
1   356	    0583  00						 db	 0
1   357
1   358	    0584  FFFF			 d16_desc		 dw	 0FFFFh
1   359	    0586  ????						 dw	 ?
1   360	    0588  ??						 db	 ?
1   361	    0589  93						 db	 92h OR	1
1   362	    058A  00 00						 db	 0,0
1   363
1   364					 ; descriptores	para el	c¢digo y los datos del programa
1   365	    058C  FFFF			 code_desc		 dw	 0FFFFh
1   366	    058E  0000						 dw	 0
1   367	    0590  00						 db	 0
1   368	    0591  9B CF						 db	 9Bh,0CFh
1   369	    0593  00						 db	 0
1   370
1   371	    0594  FFFF			 data_desc		 dw	 0FFFFh
1   372	    0596  0000						 dw	 0
1   373	    0598  00						 db	 0
1   374	    0599  93 CF						 db	 93h,0CFh
1   375	    059B  00						 db	 0
1   376
1   377					 ; descriptor para el segmento de variables de entorno
1   378	    059C  FFFF			 env_desc		 dw	 0FFFFh	 ; l¡mite 64Kb
1   379	    059E  0000						 dw	 0
1   380	    05A0  00						 db	 0
1   381	    05A1  93						 db	 92h OR	1
1   382	    05A2  00 00						 db	 0,0
1   383
1   384					 ; a partir de aqu¡ no se pueden mover de sitio	los descriptores
1   385
1   386					 ; descriptor para el segmento del PSP
1   387	    05A4  00FF			 psp_desc		 dw	 0FFh	 ; l¡mite 100h bytes
1   388	    05A6  0000						 dw	 0
1   389	    05A8  00						 db	 0
1   390	    05A9  93						 db	 93h
1   391	    05AA  40 00						 db	 40h,0
1   392
1   393					 ; descriptor del Task State Segment (TSS)
1   394	    05AC  FFFF			 tss_desc		 dw	 0FFFFh
1   395	    05AE  0000						 dw	 0
1   396	    05B0  00						 db	 0
1   397	    05B1  89						 db	 89h	 ; Present, not	Busy
1   398	    05B2  00						 db	 0
1   399	    05B3  00						 db	 0
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 8
DarkX.ASM



1   400
1   401					 ; reservamos 3	descriptores para el VCPI, en caso de que lo haya
1   402	    05B4  18*(00)		 vcpi_descs		 db	 3*8 dup(0)
1   403
1   404					 ; espacio para	descriptores libres
1   405	    05CC  50*(00)		 free_descs_start	 db	 FREE_DESCS*8 dup(0)
1   406
    407	    061C  0A*(00)			 free_descs_handles	 db FREE_DESCS dup(0)
    408
    409	    0626  0646r				 error_string_table	 dw exc_0
    410	    0628  0656r							 dw exc_1
    411									 REPT	 4
    412									 dw exc_default
    413									 ENDM
1   414	    062A  06ADr							 dw exc_default
1   415	    062C  06ADr							 dw exc_default
1   416	    062E  06ADr							 dw exc_default
1   417	    0630  06ADr							 dw exc_default
    418	    0632  0666r							 dw exc_6
    419	    0634  0675r							 dw exc_7
    420									 REPT	 5
    421									 dw exc_default
    422									 ENDM
1   423	    0636  06ADr							 dw exc_default
1   424	    0638  06ADr							 dw exc_default
1   425	    063A  06ADr							 dw exc_default
1   426	    063C  06ADr							 dw exc_default
1   427	    063E  06ADr							 dw exc_default
    428	    0640  0687r							 dw exc_13
    429	    0642  06A2r							 dw exc_14
    430	    0644  06ADr							 dw exc_default
    431
    432	    0646  44 49	56 49 44 45 20+		 exc_0			 db "DIVIDE OVERFLOW",0
    433		  4F 56	45 52 46 4C 4F+
    434		  57 00
    435	    0656  44 45	42 55 47 20 45+		 exc_1			 db "DEBUG EXCEPTION",0
    436		  58 43	45 50 54 49 4F+
    437		  4E 00
    438	    0666  49 4E	56 41 4C 49 44+		 exc_6			 db "INVALID OPCODE",0
    439		  20 4F	50 43 4F 44 45+
    440		  00
    441	    0675  46 50	55 20 4E 4F 54+		 exc_7			 db "FPU NOT AVAILABLE",0
    442		  20 41	56 41 49 4C 41+
    443		  42 4C	45 00
    444	    0687  47 45	4E 45 52 41 4C+		 exc_13			 db "GENERAL PROTECTION	FAILURE",0
    445		  20 50	52 4F 54 45 43+
    446		  54 49	4F 4E 20 46 41+
    447		  49 4C	55 52 45 00
    448	    06A2  50 41	47 45 20 46 41+		 exc_14			 db "PAGE FAULT",0
    449		  55 4C	54 00
    450	    06AD  45 58	43 45 50 54 49+		 exc_default		 db "EXCEPTION",0
    451		  4F 4E	00
    452
    453	    06B7  49 4E	56 41 4C 49 44+		 invalid_sel_msg	 db "INVALID SELECTOR VALUE "
    454		  20 53	45 4C 45 43 54+
    455		  4F 52	20 56 41 4C 55+
    456		  45 20
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 9
DarkX.ASM



    457
    458	    06CE  45 52	52 4F 52 3A 20		 debug_info_msg		 db "ERROR: "
    459	    06D5  20 20	20 20 20 20 20+		 error_string		 db "			       ",13,10
    460		  20 20	20 20 20 20 20+
    461		  20 20	20 20 20 20 20+
    462		  20 20	20 20 20 0D 0A
    463	    06F1  33 32	2D 62 69 74 20+					 db "32-bit protected mode exception number: "
    464		  70 72	6F 74 65 63 74+
    465		  65 64	20 6D 6F 64 65+
    466		  20 65	78 63 65 70 74+
    467		  69 6F	6E 20 6E 75 6D+
    468		  62 65	72 3A 20
    469	    0719  30 30	68 0D 0A		 exception_number	 db "00h",13,10
    470	    071E  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    471		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    472		  C4 C4	C4 C4 C4 C4 C4+
    473		  C4 C4	C4 C4 C4 C4 C4+
    474		  C4 C4	C4 C4 C4 C4 C4+
    475		  C4 C4	C4 C4 C4 C4 C4+
    476		  C4 C4	C4 C4 C4 C4 C4+
    477		  C4 C4	C4 C4 C4 C4 C4+
    478		  C4 C4	C4 C4 C4 C4 C4+
    479		  C4 C4	C4 C4 C4 C4 C4+
    480		  C4 C4	C4 C4 C4 C4 C4+
    481		  C4 C4	C4
    482	    076E  43 72	61 73 68 20 61+					 db "Crash address  CS:EIP = "
    483		  64 64	72 65 73 73 20+
    484		  20 43	53 3A 45 49 50+
    485		  20 3D	20
    486	    0786  30 30	30 30 3A		 debug_cs		 db "0000:"
    487	    078B  30 30	30 30 30 30 30+		 debug_eip		 db "00000000h	->  "
    488		  30 68	20 20 2D 3E 20+
    489		  20
    490	    079A  30 30	20 30 30 20 30+		 crash_code		 db "00	00 00 00 00 00 00 00",13,10,10
    491		  30 20	30 30 20 30 30+
    492		  20 30	30 20 30 30 20+
    493		  30 30	0D 0A 0A
    494	    07B4  53 74	61 63 6B 20 63+					 db "Stack contents SS:ESP = "
    495		  6F 6E	74 65 6E 74 73+
    496		  20 53	53 3A 45 53 50+
    497		  20 3D	20
    498	    07CC  30 30	30 30 3A		 debug_ss0		 db "0000:"
    499	    07D1  30 30	30 30 30 30 30+		 debug_esp0		 db "00000000h	->  "
    500		  30 68	20 20 2D 3E 20+
    501		  20
    502	    07E0  30 30	30 30 30 30 30+		 stack_cont1		 db "00000000 "
    503		  30 20
    504	    07E9  30 30	30 30 30 30 30+		 stack_cont2		 db "00000000 "
    505		  30 20
    506	    07F2  30 30	30 30 30 30 30+		 stack_cont3		 db "00000000",13,10
    507		  30 0D	0A
    508	    07FC  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    509		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    510		  C4 C4	C4 C4 C4 C4 C4+
    511		  C4 C4	C4 C4 C4 C4 C4+
    512		  C4 C4	C4 C4 C4 C4 C4+
    513		  C4 C4	C4 C4 C4 C4 C4+
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 10
DarkX.ASM



    514		  C4 C4	C4 C4 C4 C4 C4+
    515		  C4 C4	C4 C4 C4 C4 C4+
    516		  C4 C4	C4 C4 C4 C4 C4+
    517		  C4 C4	C4 C4 C4 C4 C4+
    518		  C4 C4	C4 C4 C4 C4 C4+
    519		  C4 C4	C4
    520	    084C  45 41	58 20 3D 20					 db "EAX = "
    521	    0852  30 30	30 30 30 30 30+		 debug_eax		 db "00000000h ; "
    522		  30 68	20 3B 20
    523	    085E  45 42	58 20 3D 20					 db "EBX = "
    524	    0864  30 30	30 30 30 30 30+		 debug_ebx		 db "00000000h ; "
    525		  30 68	20 3B 20
    526	    0870  45 43	58 20 3D 20					 db "ECX = "
    527	    0876  30 30	30 30 30 30 30+		 debug_ecx		 db "00000000h ; "
    528		  30 68	20 3B 20
    529	    0882  45 44	58 20 3D 20					 db "EDX = "
    530	    0888  30 30	30 30 30 30 30+		 debug_edx		 db "00000000h",13,10
    531		  30 68	0D 0A
    532	    0893  45 53	49 20 3D 20					 db "ESI = "
    533	    0899  30 30	30 30 30 30 30+		 debug_esi		 db "00000000h ; "
    534		  30 68	20 3B 20
    535	    08A5  45 44	49 20 3D 20					 db "EDI = "
    536	    08AB  30 30	30 30 30 30 30+		 debug_edi		 db "00000000h ; "
    537		  30 68	20 3B 20
    538	    08B7  45 42	50 20 3D 20					 db "EBP = "
    539	    08BD  30 30	30 30 30 30 30+		 debug_ebp		 db "00000000h ; "
    540		  30 68	20 3B 20
    541	    08C9  45 53	50 20 3D 20					 db "ESP = "
    542	    08CF  30 30	30 30 30 30 30+		 debug_esp		 db "00000000h",13,10
    543		  30 68	0D 0A
    544	    08DA  45 46	4C 41 47 53 20+					 db "EFLAGS = "
    545		  3D 20
    546	    08E3  30 30	30 30 30 30 30+		 debug_flags		 db "00000000h",13,10
    547		  30 68	0D 0A
    548	    08EE  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    549		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    550		  C4 C4	C4 C4 C4 C4 C4+
    551		  C4 C4	C4 C4 C4 C4 C4+
    552		  C4 C4	C4 C4 C4 C4 C4+
    553		  C4 C4	C4 C4 C4 C4 C4+
    554		  C4 C4	C4 C4 C4 C4 C4+
    555		  C4 C4	C4 C4 C4 C4 C4+
    556		  C4 C4	C4 C4 C4 C4 C4+
    557		  C4 C4	C4 C4 C4 C4 C4+
    558		  C4 C4	C4 C4 C4 C4 C4+
    559		  C4 C4	C4
    560	    093E  53 65	6C 65 63 74 6F+					 db "Selectors:		 Descriptors:",13,10
    561		  72 73	3A 20 20 20 20+
    562		  20 20	20 20 20 20 44+
    563		  65 73	63 72 69 70 74+
    564		  6F 72	73 3A 0D 0A
    565	    0960  43 53	20 3D 20					 db "CS	= "
    566	    0965  30 30	30 30 68 20 20+		 debug_cs1		 db "0000h    ->    "
    567		  20 20	2D 3E 20 20 20+
    568		  20
    569	    0974  30 30	20 30 30 20 30+		 desc_cs		 db "00	00 00 00 00 00 00 00",13,10
    570		  30 20	30 30 20 30 30+
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 11
DarkX.ASM



    571		  20 30	30 20 30 30 20+
    572		  30 30	0D 0A
    573	    098D  44 53	20 3D 20					 db "DS	= "
    574	    0992  30 30	30 30 68 20 20+		 debug_ds		 db "0000h    ->    "
    575		  20 20	2D 3E 20 20 20+
    576		  20
    577	    09A1  30 30	20 30 30 20 30+		 desc_ds		 db "00	00 00 00 00 00 00 00",13,10
    578		  30 20	30 30 20 30 30+
    579		  20 30	30 20 30 30 20+
    580		  30 30	0D 0A
    581	    09BA  45 53	20 3D 20					 db "ES	= "
    582	    09BF  30 30	30 30 68 20 20+		 debug_es		 db "0000h    ->    "
    583		  20 20	2D 3E 20 20 20+
    584		  20
    585	    09CE  30 30	20 30 30 20 30+		 desc_es		 db "00	00 00 00 00 00 00 00",13,10
    586		  30 20	30 30 20 30 30+
    587		  20 30	30 20 30 30 20+
    588		  30 30	0D 0A
    589	    09E7  46 53	20 3D 20					 db "FS	= "
    590	    09EC  30 30	30 30 68 20 20+		 debug_fs		 db "0000h    ->    "
    591		  20 20	2D 3E 20 20 20+
    592		  20
    593	    09FB  30 30	20 30 30 20 30+		 desc_fs		 db "00	00 00 00 00 00 00 00",13,10
    594		  30 20	30 30 20 30 30+
    595		  20 30	30 20 30 30 20+
    596		  30 30	0D 0A
    597	    0A14  47 53	20 3D 20					 db "GS	= "
    598	    0A19  30 30	30 30 68 20 20+		 debug_gs		 db "0000h    ->    "
    599		  20 20	2D 3E 20 20 20+
    600		  20
    601	    0A28  30 30	20 30 30 20 30+		 desc_gs		 db "00	00 00 00 00 00 00 00",13,10
    602		  30 20	30 30 20 30 30+
    603		  20 30	30 20 30 30 20+
    604		  30 30	0D 0A
    605	    0A41  53 53	20 3D 20					 db "SS	= "
    606	    0A46  30 30	30 30 68 20 20+		 debug_ss		 db "0000h    ->    "
    607		  20 20	2D 3E 20 20 20+
    608		  20
    609	    0A55  30 30	20 30 30 20 30+		 desc_ss		 db "00	00 00 00 00 00 00 00",13,10
    610		  30 20	30 30 20 30 30+
    611		  20 30	30 20 30 30 20+
    612		  30 30	0D 0A
    613	    0A6E  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    614		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    615		  C4 C4	C4 C4 C4 C4 C4+
    616		  C4 C4	C4 C4 C4 C4 C4+
    617		  C4 C4	C4 C4 C4 C4 C4+
    618		  C4 C4	C4 C4 C4 C4 C4+
    619		  C4 C4	C4 C4 C4 C4 C4+
    620		  C4 C4	C4 C4 C4 C4 C4+
    621		  C4 C4	C4 C4 C4 C4 C4+
    622		  C4 C4	C4 C4 C4 C4 C4+
    623		  C4 C4	C4 C4 C4 C4 C4+
    624		  C4 C4	C4
    625	    0ABE  24							 db "$"
    626
    627					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 12
DarkX.ASM



    628					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
    629					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    630
    631					 ;	  include nicedbg.inc		  ; DEBUGGING macros
    632
    633						 include letypes.inc
1   634					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   635					 ; file: letypes.inc
1   636					 ;
1   637					 ;  Data types for LE loader. Used by TX32 extender.
1   638					 ;
1   639					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1   640					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   641
1   642	00000ABF			 LEHEADER	 struc
1   643
1   644	00000000  01*(????)		 signature	 dw	 ?	 ; LE indicates	Linear Executable
1   645	00000002  01*(??)		 byte_order	 db	 ?	 ; Byte	order
1   646	00000003  01*(??)		 word_order	 db	 ?	 ; Word	order
1   647	00000004  01*(????????)		 exe_level	 dd	 ?	 ; Executable format level
1   648	00000008  01*(????)		 cpu_type	 dw	 ?	 ; CPU type (2 - Intel 386, 3 ...)
1   649	0000000A  01*(????)		 target_os	 dw	 ?	 ; Target OS (1	- OS/2)
1   650	0000000C  01*(????????)		 module_version	 dd	 ?	 ; Module version
1   651	00000010  01*(????????)		 module_type	 dd	 ?	 ; Module type
1   652	00000014  01*(????????)		 memory_pages	 dd	 ?	 ; Number of memory pages
1   653	00000018  01*(????????)		 object_cs	 dd	 ?	 ; CS (object number)
1   654	0000001C  01*(????????)		 offset_eip	 dd	 ?	 ; EIP (offset)
1   655	00000020  01*(????????)		 object_ss	 dd	 ?	 ; SS (object number)
1   656	00000024  01*(????????)		 offset_esp	 dd	 ?	 ; ESP (offset)
1   657	00000028  01*(????????)		 page_size	 dd	 ?	 ; Memory page size (4 kb)
1   658	0000002C  01*(????????)		 bytes_last_page dd	 ?	 ; Bytes on last page
1   659	00000030  01*(????????)		 fixup_sect_size dd	 ?	 ; Fixup section size
1   660	00000034  01*(????????)		 fixup_checksum	 dd	 ?	 ; Fixup section checksum
1   661	00000038  01*(????????)		 load_sect_size	 dd	 ?	 ; Loader section size
1   662	0000003C  01*(????????)		 load_checksum	 dd	 ?	 ; Loader section checksum
1   663	00000040  01*(????????)		 off_object_tbl	 dd	 ?	 ; Offset of object table
1   664	00000044  01*(????????)		 obj_tbl_entries dd	 ?	 ; Object table	entries
1   665	00000048  01*(????????)		 off_page_map	 dd	 ?	 ; Object page map table offset
1   666	0000004C  01*(????????)		 off_obj_it_data dd	 ?	 ; Object iterate data map offset
1   667	00000050  01*(????????)		 off_res_table	 dd	 ?	 ; Resource table offset
1   668	00000054  01*(????????)		 res_tbl_entries dd	 ?	 ; Resource table entries
1   669	00000058  01*(????????)		 off_res_names	 dd	 ?	 ; Resident names table	offset
1   670	0000005C  01*(????????)		 off_entry_table dd	 ?	 ; Entry table offset
1   671	00000060  01*(????????)		 off_mod_dirs	 dd	 ?	 ; Module directives table offset
1   672	00000064  01*(????????)		 num_mod_dirs	 dd	 ?	 ; Module directives entries
1   673	00000068  01*(????????)		 off_fixup_pag	 dd	 ?	 ; Fixup page table offset
1   674	0000006C  01*(????????)		 off_fixup_rec	 dd	 ?	 ; Fixup record	table offset
1   675	00000070  01*(????????)		 off_import_mods dd	 ?	 ; Imported modules name table offset
1   676	00000074  01*(????????)		 num_import_mods dd	 ?	 ; Imported modules count
1   677	00000078  01*(????????)		 off_import_proc dd	 ?	 ; Imported procedures name table offset
1   678	0000007C  01*(????????)		 off_pages_chksm dd	 ?	 ; Per-page checksum table offset
1   679	00000080  01*(????????)		 off_data_pages	 dd	 ?	 ; Data	pages offset
1   680	00000084  01*(????????)		 num_preload	 dd	 ?	 ; Preload page	count
1   681	00000088  01*(????????)		 off_nres_names	 dd	 ?	 ; Non-resident	names table offset
1   682	0000008C  01*(????????)		 len_nres_names	 dd	 ?	 ; Non-resident	names table length
1   683	00000090  01*(????????)		 nres_names_chk	 dd	 ?	 ; Non-resident	names checksum
1   684	00000094  01*(????????)		 auto_data_obj	 dd	 ?	 ; Automatic data object
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 13
DarkX.ASM



1   685	00000098  01*(????????)		 off_dbg_nfo	 dd	 ?	 ; Debug information offset
1   686	0000009C  01*(????????)		 len_dbg_nfo	 dd	 ?	 ; Debug information length
1   687	000000A0  01*(????????)		 preload_inst_pg dd	 ?	 ; Preload instance pages number
1   688	000000A4  01*(????????)		 demand_inst_pg	 dd	 ?	 ; Demand instance pages number
1   689	000000A8  01*(????????)		 extra_heap	 dd	 ?	 ; Extra heap allocation
1   690	000000AC  01*(06*(????????))	 leh_reserved	 dd	 6 dup (?)
1   691
1   692	000000C4					 ends
1   693
1   694	00000ABF			 OBJECT		 struc
1   695
1   696	00000000  01*(????????)		 virtual_size	 dd	 ?	 ; Virtual size	in bytes
1   697	00000004  01*(????????)		 relocation_base dd	 ?	 ; Relocation base address
1   698	00000008  01*(????????)		 object_flags	 dd	 ?	 ; Object flags
1   699	0000000C  01*(????????)		 page_map_index	 dd	 ?	 ; Page	map index
1   700	00000010  01*(????????)		 num_pages	 dd	 ?	 ; Number of page map entries
1   701	00000014  01*(????????)		 ot_reserved	 dd	 ?	 ; Reserved
1   702
1   703	00000018					 ends
1   704
1   705	00000ABF			 OBJNFO		 struc
1   706
1   707	00000000  01*(????????)		 obj_handles	 dd	 ?	 ; Object handle to free memory
1   708	00000004  01*(??)		 mem_type	 db	 ?	 ; Handle's memory type
1   709	00000005  01*(????????)		 obj_offset	 dd	 ?	 ; Object's base address
1   710
1   711	00000009					 ends
1   712
1   713
    714
    715					 ; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    716					 ; loadle "data	segment"
    717					 ; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    718
    719	    0ABF  ????????		 handle		     dd	     ?		 ; File	handle
    720	    0AC3  ????????		 le_offset	     dd	     ?		 ; Offset to LE	header from the	start
    721										 ;  of the file
    722	    0AC7  C4*(??)		 le_hdr		     LEHEADER <>	 ; LE header
    723	    0B8B  0A*(18*(??))		 object_tbl	     OBJECT 10 dup (?)	 ; Object table
    724	    0C7B  0A*(09*(??))		 object_nfo	     OBJNFO 10 dup (?)	 ; Objects info
    725	    0CD5  ????????		 obj_handles_ptr     dd	     ?		 ; Ptr to current object handle
    726	    0CD9  ????????		 num_obj_handles     dd	     ?		 ; Number of memory blocks allocated
    727
    728	    0CDD  ????????		 obj_count	     dd	     ?		 ; Object counter
    729
    730	    0CE1  ????????		 curr_page	     dd	     ?		 ; Now loading this page
    731	    0CE5  ????????		 curr_fixup_pag	     dd	     ?		 ; File	ptr to current fixup page table
    732										 ;  entry
    733	    0CE9  ????????		 off_1st_fixup_rec   dd	     ?		 ; Offset from fixup record table of
    734										 ;  1st	entry for this page
    735	    0CED  ????????		 off_1st_fixup_rec_next_page dd	 ?	 ; Idem	for next page
    736	    0CF1  ????????		 curr_page_off	     dd	     ?		 ; Offset of currently fixed up	page
    737
    738	    0CF5  ??			 source_type	     db	     ?		 ; Fixup's source type
    739	    0CF6  ??			 target_flags	     db	     ?		 ; Fixup's target flags
    740	    0CF7  ????			 source_off	     dw	     ?		 ; Fixup's source offset
    741	    0CF9  ????			 object_num	     dw	     ?		 ; Fixup's object number
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 14
DarkX.ASM



    742	    0CFB  ????????		 target_off	     dd	     ?		 ; Fixup's target offset
    743
    744					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    745					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
    746					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    747
    748	00000CFF			 TFword	 STRUC
    749	00000000  01*(????????)			 loffset	 dd ?
    750	00000004  01*(????)			 selector	 dw ?
    751	00000006			 ENDS
    752
    753		  =0000			 FREE_CB	 EQU 0
    754		  =0001			 ALLOCATED_CB	 EQU 1
    755					 ; call-back data table
    756	00000CFF			 TCallback	 STRUC
    757	00000000  01*(??)			 callback_state	 db ?
    758	00000001  01*(????)			 rm_entry_point	 dw ?
    759	00000003  01*(06*(??))			 pm_proc_to_call TFword	?
    760	00000009  01*(06*(??))			 rm_call_struc	 TFword	?
    761	0000000F			 ENDS
    762
    763					 ;RM_ENTRY=offset callback_address_table
    764	    0CFF			 LABEL	 callback_data
    765					 REPT	 CALLBACKS
    766						 TCallback <FREE_CB,RM_ENTRY,?,?>
    767					 RM_ENTRY=(offset end_of_cb_address-offset callback_address_table)
    768					 ENDM
1   769	    0CFF  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   770	    0D0E  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   771	    0D1D  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   772	    0D2C  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   773	    0D3B  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   774	    0D4A  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   775	    0D59  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   776	    0D68  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   777	    0D77  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   778	    0D86  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   779	    0D95  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   780	    0DA4  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   781	    0DB3  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   782	    0DC2  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   783	    0DD1  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   784	    0DE0  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   785	    0DEF  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   786	    0DFE  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   787	    0E0D  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   788	    0E1C  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   789	    0E2B  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   790	    0E3A  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   791	    0E49  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   792	    0E58  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   793	    0E67  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   794	    0E76  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   795	    0E85  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   796	    0E94  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   797	    0EA3  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   798	    0EB2  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 15
DarkX.ASM



1   799	    0EC1  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   800	    0ED0  00 0007 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
    801
    802	    0EDF			 TXDATA	 ENDS
    803
    804					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    805					 ; SEGMENTO DE CODIGO PARA RUTINAS DE 16 BITS (	ENTRADA	EN PM, SALIDA, ... )
    806					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    807
    808	    0000			 TXCODE	 SEGMENT PARA USE16 'CODE'
    809					 ASSUME	 CS:TXCODE,DS:txdata,SS:txpila
    810
    811					 INCLUDE	 raw_xms.inc
1   812					 ASSUME	 DS:txdata
1   813					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   814	    0000			 ret_real_raw:
1   815					 ; INPUT -> DS = D16_SEL
1   816	    0000  FA				 cli
1   817
1   818	    0001  8C D8				 mov	 ax,ds
1   819	    0003  8E C0				 mov	 es,ax
1   820	    0005  8E E0				 mov	 fs,ax
1   821	    0007  8E E8				 mov	 gs,ax
1   822	    0009  8E D0				 mov	 ss,ax
1   823
1   824	    000B  0F 01	1E 0548r		 lidt	 fword ptr idt_real
1   825
1   826	    0010  0F 20	C0			 mov	 eax,cr0
1   827	    0013  24 FE				 and	 al,0FEh
1   828	    0015  0F 22	C0			 mov	 cr0,eax
1   829
1   830	    0018  EA			 saltito db 0eah
1   831	    0019  ????				 dw ?
1   832	    001B  ????				 dw ?
1   833
1   834					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   835
1   836	    001D			 set_pm_raw:
1   837					 ; INPUT -> DS = D16_SEL
1   838						 ; ponemos la GDT y la IDT
1   839	    001D  66				 db	 66h
1   840	    001E  0F 01	16 053Cr		 lgdt	 fword ptr gdt_reg
1   841	    0023  0F 01	1E 0542r		 lidt	 fword ptr idt_reg
1   842						 ; vamos a P.MODE
1   843	    0028  0F 01	E0			 smsw	 ax
1   844	    002B  0D 0001			 or	 ax,1
1   845	    002E  0F 01	F0			 lmsw	 ax
1   846	    0031  EB 00				 jmp	 next_label	 ; carga la prefetch queue
1   847	    0033				 next_label:
1   848	    0033  66| FF 2E 0532r		 jmp	 fword ptr prot_code_address
1   849					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   850					 alloc_xms_mem MACRO
1   851						 mov	 ax,txcode32
1   852						 mov	 es,ax
1   853						 ASSUME	 ES:txcode32
1   854						 mov	 byte ptr es:extended_pointers,0
1   855						 xor	 di,di
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 16
DarkX.ASM



1   856						 cont_adding_xms:
1   857						 mov	 ah,8
1   858						 xor	 bl,bl
1   859						 call	 dword ptr xms_entry_point
1   860						 or	 bl,bl
1   861						 jnz	 xms_alloc_done
1   862						 push	 ax
1   863						 mov	 dx,ax
1   864						 mov	 ah,9
1   865						 call	 dword ptr xms_entry_point
1   866						 pop	 cx
1   867						 or	 ax,ax
1   868						 jz	 xms_alloc_done
1   869						 mov	 word ptr es:[di+xms_handles],dx
1   870						 inc	 byte ptr es:extended_pointers
1   871						 mov	 ah,0Ch
1   872						 call	 dword ptr xms_entry_point
1   873						 or	 ax, ax
1   874						 jnz	 page_is_locked	 ; si no la bloquea, no	la a¤adimos a la heap
1   875							 dec	 byte ptr es:extended_pointers
1   876							 jmp	 cont_adding
1   877						 page_is_locked:
1   878						 shl	 edx,16
1   879						 mov	 dx,bx
1   880						 movzx	 ecx,cx
1   881						 shl	 ecx,10
1   882						 mov	 dword ptr es:[di+extended_pointers+1],edx
1   883						 mov	 dword ptr es:[di+extended_pointers+1+4],ecx
1   884						 add	 di,8
1   885						 cmp	 di,8*100
1   886						 je	 xms_alloc_done
1   887						 jmp	 cont_adding_xms
1   888						 xms_alloc_done:
1   889					 ENDM
1   890					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   891					 free_xms_mem	 MACRO
1   892						 ASSUME	 DS:txcode32,ES:txdata
1   893						 mov	 ax,txcode32
1   894						 mov	 ds,ax
1   895						 mov	 ax,txdata
1   896						 mov	 es,ax
1   897						 mov	 si,offset xms_handles
1   898						 movzx	 cx,byte ptr extended_pointers
1   899						 or	 cx,cx
1   900						 jz	 xms_mem_freed
1   901						 free_xms_blocks:
1   902							 mov	 dx,[si]
1   903							 mov	 ah,0Dh		 ; UNLOCK block
1   904							 call	 dword ptr es:xms_entry_point
1   905							 mov	 ah,0Ah		 ; FREE	block
1   906							 call	 dword ptr es:xms_entry_point
1   907							 add	 si,8
1   908						 loop	 free_xms_blocks
1   909						 xms_mem_freed:
1   910						 ASSUME	 DS:txdata
1   911					 ENDM
1   912					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 17
DarkX.ASM



1   913					 look_for_extended_beginning	 MACRO
1   914					 ; buscamos el principio de la extendida libre con el m‚todo VDISK
1   915					 ; OUTPUT -> EAX = extended memory beginning
1   916						 xor	 ax,ax
1   917						 mov	 fs,ax
1   918						 dec	 ax
1   919						 mov	 gs,ax
1   920						 mov	 fs,fs:[19h*4+2]
1   921						 mov	 eax,100000h
1   922						 cmp	 dword ptr fs:[12h],'SIDV'
1   923						 jnz	 method_2
1   924						 mov	 edx,fs:[12h+4]
1   925						 shl	 edx,8
1   926						 shr	 edx,8
1   927						 cmp	 edx,'V	K'
1   928						 jnz	 method_2
1   929						 mov	 eax,fs:[2Ch]
1   930						 shl	 eax,8
1   931						 shr	 eax,8
1   932						 method_2:
1   933						 cmp	 dword ptr gs:[16+3],'SIDV'
1   934						 jnz	 extended_init_found
1   935						 cmp	 byte ptr gs:[16+3+4],'K'
1   936						 jnz	 extended_init_found
1   937						 movzx	 edx,word ptr gs:[16+1Eh]     ;	+16 para el siguiente segmento
1   938						 shl	 edx,10
1   939						 add	 edx,100000h
1   940						 cmp	 edx,eax
1   941						 jbe	 extended_init_found
1   942						 xchg	 edx,eax
1   943						 extended_init_found:
1   944
1   945					 ENDM
1   946					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   947
    948					 INCLUDE	 vcpi.inc
1   949					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   950	    0038			 ret_real_vcpi:
1   951					 ; INPUT -> DS = D16_SEL ; ES =	D32_SEL
1   952	    0038  FA				 cli
1   953
1   954	    0039  06				 push	 es
1   955	    003A  17				 pop	 ss
1   956	    003B  66| BC 00000000s		 mov	 esp,txpila_real
1   957	    0041  66| C1 E4 04			 shl	 esp,4
1   958	    0045  66| 81 C4 00003FF0		 add	 esp,size txpr-4*4 ; simulamos 'push' de los selectores
1   959	    004C  66| 33 C0			 xor	 eax,eax
1   960	    004F  2E: A1 04B6r			 mov	 ax,cs:stack_frame+2
1   961	    0053  66| 50			 push	 eax		 ; ESP
1   962	    0055  2E: A1 04B4r			 mov	 ax,cs:stack_frame
1   963	    0059  66| 50			 push	 eax
1   964	    005B  66| 9C			 pushfd
1   965						 ASSUME	 ES:TXCODE
1   966	    005D  66| BB 00000000s		 mov	 ebx,txcode
1   967	    0063  66| C1 E3 04			 shl	 ebx,4
1   968	    0067  66| 26: 67| 0F B7 83+		 movzx	 eax,word ptr es:[ebx+saltito+3]
    969		  0000001Br
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 18
DarkX.ASM



1   970	    0071  66| 50			 push	 eax		 ; CS
1   971	    0073  66| 26: 67| 0F B7 83+		 movzx	 eax,word ptr es:[ebx+saltito+1]
    972		  00000019r
1   973	    007D  66| 50			 push	 eax		 ; EIP
1   974						 ASSUME	 ES:TXDATA,DS:txdata
1   975	    007F  8C D8				 mov	 ax,ds
1   976	    0081  8C C3				 mov	 bx,es
1   977	    0083  8E C0				 mov	 es,ax
1   978	    0085  8E DB				 mov	 ds,bx
1   979	    0087  B8 DE0C			 mov	 ax,0DE0Ch
1   980	    008A  66| 26: FF 1E	034Br		 call	 fword ptr es:vcpi_entry_point
1   981
1   982					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   983
1   984	    0090			 set_pm_vcpi:
1   985					 ; DS =	TXDATA
1   986	    0090  66| A1 0532r			 mov	 eax,prot_code_address
1   987	    0094  66| A3 055Er			 mov	 vcpi_cs_eip,eax
1   988	    0098  B8 DE0C			 mov	 ax,0DE0Ch
1   989	    009B  66| BE 00000000s		 mov	 esi,txdata
1   990	    00A1  66| C1 E6 04			 shl	 esi,4
1   991	    00A5  66| 81 C6 0000054Er		 add	 esi,offset vcpi_sys_regs
1   992	    00AC  CD 67				 int	 67h
1   993
1   994					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   995
1   996					 save_vcpi_data	 MACRO
1   997						 mov	 ax,txdata
1   998						 mov	 ds,ax
1   999						 mov	 set_pm_address,offset set_pm_vcpi
1  1000						 mov	 ret_real_address,offset ret_real_vcpi
1  1001					 ENDM
1  1002
1  1003					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1004
1  1005	    00AE			 vcpi_init	 proc
1  1006						 ; le decimos que redireccionamos las irq's
1  1007	    00AE  B8 DE0A			 mov	 ax,0DE0Ah
1  1008	    00B1  CD 67				 int	 67h	 ; averiguamos la base de las irq's 8-15
1  1009	    00B3  0A E4				 or	 ah,ah
1  1010	    00B5  0F 85	011D			 jnz	 vcpi_init_error
1  1011	    00B9  2E: 88 1E 0A68r		 mov	 cs:irq_base,bl
1  1012	    00BE  B8 DE0B			 mov	 ax,0DE0Bh
1  1013	    00C1  BB 0050			 mov	 bx,50h	 ; base	de las irq's bajas
1  1014	    00C4  FA				 cli
1  1015	    00C5  CD 67				 int	 67h
1  1016	    00C7  0A E4				 or	 ah,ah
1  1017	    00C9  0F 85	0109			 jnz	 vcpi_init_error
1  1018
1  1019						 ; le pedimos un interface al gestor
1  1020						 ; necesitamos un buffer de 4Kb	por cada 4Mb que haya en el sistema
1  1021	    00CD  B8 DE02			 mov	 ax,0DE02h
1  1022	    00D0  CD 67				 int	 67h	 ; this	function never fails (EDX=physical address of highest 4Kb   +
   1023					 page)
1  1024	    00D2  66| 81 C2 00400FFF		 add	 edx,4096+3FFFFFh  ; (tama¤o = direcci¢n £ltima	p gina + 4096)+3fffffh para +
   1025					 alinear a 4Mb
1  1026	    00D9  66| 81 E2 FFC00000		 and	 edx,NOT 3FFFFFh
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 19
DarkX.ASM



1  1027	    00E0  66| 52			 push	 edx
1  1028
1  1029	    00E2  66| C1 EA 0E			 shr	 edx,14	 ; phys.address*4Kb/4Mb/16   (p rrafos necesarios)
1  1030	    00E6  8B DA				 mov	 bx,dx
1  1031						 ; queremos adem s 4Kb para el directorio de p ginas
1  1032						 ; + 4K	por si est  desalineado
1  1033						 ; + 256 bytes para el TSS (104	m¡nimo)
1  1034	    00E8  81 C3	0210			 add	 bx,(4096+4096+256)/16
1  1035	    00EC  E8 0CE3			 call	 get_dos_mem
1  1036	    00EF  05 00FF			 add	 ax,0FFh	 ; lo alineamos	a 4Kb
1  1037	    00F2  25 FF00			 and	 ax,0FF00h	 ; a la	siguiente p gina
1  1038	    00F5  8E C0				 mov	 es,ax
1  1039
1  1040						 ; inicializamos el directorio de p ginas a 0
1  1041	    00F7  33 FF				 xor	 di,di
1  1042	    00F9  66| 33 C0			 xor	 eax,eax
1  1043	    00FC  B9 0400			 mov	 cx,1000h/4
1  1044	    00FF  FC				 cld
1  1045	    0100  F3> 66| AB			 rep	 stosd
1  1046						 ; mapeamos toda la memoria existente a	s¡ misma
1  1047	    0103  66| 59			 pop	 ecx
1  1048	    0105  66| C1 E9 16			 shr	 ecx,22		 ; ECX = N£mero	de tablas de p ginas necesarias
1  1049	    0109  66| B8 00000067		 mov	 eax,67h	 ; first page dirty,accessed,user,writeable,present
1  1050	    010F  06 1E				 push	 es ds
1  1051	    0111  06				 push	 es
1  1052	    0112  1F				 pop	 ds
1  1053	    0113  33 F6				 xor	 si,si
1  1054	    0115				 set_page_dir_entries:
1  1055	    0115  51					 push	 cx
1  1056	    0116  BF 1000				 mov	 di,1000h
1  1057	    0119  B9 0400				 mov	 cx,1024 ; pages in a page table
1  1058	    011C					 set_page_table_entries:
1  1059	    011C  66| AB					 stosd
1  1060	    011E  66| 05 00001000				 add	 eax,1000h
1  1061	    0124  E2 F6					 loop	 set_page_table_entries
1  1062	    0126  8C C1					 mov	 cx,es
1  1063	    0128  51					 push	 cx
1  1064	    0129  81 C1	0100				 add	 cx,4096/16	 ; ES:1000h -> siguiente tabla
1  1065	    012D  8E C1					 mov	 es,cx
1  1066	    012F  66| 33 C9				 xor	 ecx,ecx
1  1067	    0132  59					 pop	 cx
1  1068							 ; llenamos la entrada del directorio de p ginas
1  1069	    0133  66| C1 E1 04				 shl	 ecx,4
1  1070	    0137  66| 81 C1 00001007			 add	 ecx,1007h	 ; siguiente tabla (USER,WRITEABLE,PRESENT)
1  1071	    013E  66| 89 0C				 mov	 [si],ecx
1  1072	    0141  83 C6	04				 add	 si,4
1  1073	    0144  59					 pop	 cx
1  1074	    0145  E2 CE				 loop	 set_page_dir_entries
1  1075
1  1076						 ; guardamos la	primera	entrada	libre en el directorio de p ginas
1  1077	    0147  66| 33 DB			 xor	 ebx,ebx
1  1078	    014A  8C DB				 mov	 bx,ds
1  1079	    014C  1F				 pop	 ds
1  1080	    014D  66| C1 E3 04			 shl	 ebx,4
1  1081	    0151  66| 89 1E 0351r		 mov	 dir_base,ebx
1  1082	    0156  66| 0F B7 F6			 movzx	 esi,si
1  1083	    015A  66| 03 DE			 add	 ebx,esi
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 20
DarkX.ASM



1  1084	    015D  66| 89 1E 0355r		 mov	 page_dir_base,ebx	 ; linear address of first free	page dir. entry
1  1085	    0162  66| BB 00000400		 mov	 ebx,4096/4		 ; total number	of entries in directory
1  1086	    0168  66| C1 EE 02			 shr	 esi,2
1  1087	    016C  66| 2B DE			 sub	 ebx,esi
1  1088	    016F  66| 89 1E 0359r		 mov	 page_dir_entries,ebx	 ; number of available entries
1  1089
1  1090						 ; el espacio para el TSS est  despu‚s de la £ltima tabla de p ginas
1  1091	    0174  8C C0				 mov	 ax,es
1  1092	    0176  07				 pop	 es
1  1093	    0177  66| 0F B7 C0			 movzx	 eax,ax
1  1094	    017B  66| C1 E0 04			 shl	 eax,4
1  1095	    017F  66| 05 00001000		 add	 eax,1000h	 ;1000h-7
1  1096	    0185  A3 05AEr			 mov	 word ptr tss_desc+2,ax
1  1097	    0188  66| C1 E8 10			 shr	 eax,16
1  1098	    018C  A2 05B0r			 mov	 byte ptr tss_desc+4,al
1  1099						 ; pedimos el interface
1  1100	    018F  BF 1000			 mov	 di,1000h
1  1101	    0192  B8 DE01			 mov	 ax,0DE01h
1  1102	    0195  BE 05B4r			 mov	 si,offset vcpi_descs	 ; DS:SI -> buffer 3 desc.'s
1  1103	    0198  CD 67				 int	 67h
1  1104	    019A  0A E4				 or	 ah,ah
1  1105	    019C  75 38				 jnz	 vcpi_init_error
1  1106	    019E  66| 89 1E 034Br		 mov	 vcpi_entry_point,ebx
1  1107					 ;	  xor	  ebx,ebx
1  1108					 ;	  mov	  bx,es
1  1109					 ;	  shl	  ebx,4
1  1110					 ;	  mov	  page_base,ebx
1  1111					 ;	  add	  page_base,1000h	  ; page table base
1  1112					 ;	  movzx	  edi,di
1  1113					 ;	  mov	  last_free_page,ebx
1  1114					 ;	  add	  last_free_page,2000h	  ; + 4Kb (page	dir.) +	4Kb (page table)
1  1115					 ;	  add	  ebx,edi
1  1116					 ;	  mov	  first_free_page,ebx
1  1117						 ; miramos si el directorio de p ginas est  paginado a alg£n sitio
1  1118	    01A3  8C C3				 mov	 bx,es
1  1119	    01A5  C1 EB	02			 shr	 bx,2
1  1120	    01A8  66| 26: 8B 87	1000		 mov	 eax,es:[bx+1000h]
1  1121	    01AE  66| C1 E8 04			 shr	 eax,4
1  1122	    01B2  32 C0				 xor	 al,al
1  1123						 ; preparamos la tabla de p ginas
1  1124	    01B4  66| A3 054Er			 mov	 vcpi_cr3,eax
1  1125						 ; preparamos la estructura de registros para el salto
1  1126	    01B8  66| B8 00000000s		 mov	 eax,txdata
1  1127	    01BE  66| C1 E0 04			 shl	 eax,4
1  1128	    01C2  66| 01 06 0552r		 add	 vcpi_gdtr,eax
1  1129	    01C7  66| 01 06 0556r		 add	 vcpi_idtr,eax
1  1130	    01CC  66| 81 06 055Er     +		 add	 vcpi_cs_eip,offset c32_init
   1131		  00001A42r
1  1132	    01D5  C3				 ret
1  1133
1  1134	    01D6				 vcpi_init_error:
1  1135	    01D6  BA 035Dr				 mov	 dx,offset vcpi_init_err_msg
1  1136	    01D9  E8 0BC3				 call	 printf
1  1137	    01DC  E9 0826				 jmp	 fin
1  1138
1  1139	    01DF			 vcpi_init	 endp
1  1140					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 21
DarkX.ASM



1  1141
   1142					 INCLUDE	 dpmi.inc
1  1143		  =0007			 SELECTORS	 equ 7	  ; no queremos	los 4 del VCPI ni el del PSP
1  1144					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1145	    01DF			 dpmi_error:
1  1146					 ; DS =	D16_SEL
1  1147						 ; ponemos la real mode	call structure
1  1148	    01DF  1E				 push	 ds
1  1149	    01E0  07				 pop	 es
1  1150	    01E1  66| BF 00000407r		 mov	 edi,offset dpmi_rm_call
1  1151	    01E7  67| C6 47 1C 09		 mov	 byte ptr [edi+1Ch],9
1  1152	    01EC  67| C7 47 24 0000s		 mov	 word ptr [edi+24h],txdata
1  1153	    01F2  67| C7 47 14 03A6r		 mov	 word ptr [edi+14h],offset dpmi_init_error
1  1154					 ;	  mov	  word ptr [di+30h],txpila
1  1155					 ;	  mov	  word ptr [di+2Eh],size txpila
1  1156	    01F8  BB 0021			 mov	 bx,21h
1  1157	    01FB  33 C9				 xor	 cx,cx
1  1158	    01FD  B8 0300			 mov	 ax,300h
1  1159	    0200  CD 31				 int	 31h
1  1160	    0202  E9 081F			 jmp	 no_vcpi_end
1  1161
1  1162					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1163
1  1164	    0205			 save_dpmi_data	 proc
1  1165	    0205  BA 0380r			 mov	 dx,offset dpmi_32b_error
1  1166	    0208  F6 C3	01			 test	 bl,1
1  1167	    020B  0F 84	0B84			 jz	 error_handle
1  1168						 ASSUME	 DS:txdata
1  1169	    020F  B8 0000s			 mov	 ax,txdata
1  1170	    0212  8E D8				 mov	 ds,ax
1  1171						 ; guardamos el	DPMI mode-switch entry point
1  1172	    0214  2E: 89 3E 0234r		 mov	 word ptr cs:dpmi_mode_switch,di
1  1173	    0219  2E: 8C 06 0236r		 mov	 word ptr cs:dpmi_mode_switch+2,es
1  1174	    021E  56				 push	 si
1  1175						 ; alojamos la memoria que necesite el DPMI
1  1176	    021F  5B				 pop bx
1  1177	    0220  E8 0BAF			 call	 get_dos_mem
1  1178	    0223  A3 03F1r			 mov	 dpmi_private_buffer,ax
1  1179	    0226  C3				 ret
1  1180	    0227			 save_dpmi_data	 endp
1  1181					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1182
1  1183	    0227			 dpmi_init:
1  1184							 ; cargamos en DS el segmento para corregirlo todo
1  1185	    0227  B8 0000s				 mov	 ax,txdata
1  1186	    022A  8E D8					 mov	 ds,ax
1  1187
1  1188							 ; PM switch
1  1189	    022C  B8 0001				 mov	 ax,1
1  1190	    022F  8E 06	03F1r				 mov	 es,dpmi_private_buffer
1  1191	    0233  9A						 db	 9Ah	 ; CALL	FAR PTR
1  1192	    0234  00000000		 dpmi_mode_switch	 dd 0
1  1193	    0238  FA					 cli			 ; por si acaso...
1  1194	    0239  BA 03A6r				 mov	 dx,offset dpmi_init_error
1  1195	    023C  0F 82	0B53				 jc	 error_handle	 ; estaremos todav¡a en	real
1  1196
1  1197							 ; guardamos el	selector del PSP
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 22
DarkX.ASM



1  1198	    0240  8C 06	0335r				 mov	 psp_selector,es
1  1199
1  1200							 ; guardamos el	selector del entorno
1  1201
1  1202							 ; estamos en protegido
1  1203							 ; alojamos descriptores
1  1204	    0244  33 C0					 xor	 ax,ax
1  1205	    0246  B9 0007				 mov	 cx,SELECTORS
1  1206	    0249  CD 31					 int	 31h
1  1207	    024B  72 92					 jc	 dpmi_error
1  1208	    024D  50					 push	 ax
1  1209
1  1210							 ; miramos el incremento de selector
1  1211	    024E  B8 0003				 mov	 ax,3
1  1212	    0251  CD 31					 int	 31h
1  1213
1  1214	    0253  8B E8					 mov	 bp,ax
1  1215	    0255  5B					 pop	 bx
1  1216
1  1217							 ; corregimos los selectores
1  1218	    0256  66| B9 00000007			 mov	 ecx,SELECTORS
1  1219							 ASSUME	 DS:txdata
1  1220	    025C  66| BF 00000427r			 mov	 edi,offset dpmi_sels
1  1221	    0262  8B D3					 mov	 dx,bx
1  1222	    0264					 suma_sels:
1  1223	    0264  67| 89 17					 mov	 [edi],dx
1  1224	    0267  03 D0						 add	 dx,ax
1  1225	    0269  66| 83 C7 04					 add	 edi,4
1  1226	    026D  E2 F5					 loop	 suma_sels
1  1227
1  1228							 ; averiguamos el PL actual y lo ponemos en los	descriptores
1  1229	    026F  1E					 push	 ds
1  1230	    0270  07					 pop	 es
1  1231	    0271  8C C8					 mov	 ax,cs
1  1232	    0273  0F 02	D0				 lar	 dx,ax	 ; coge	access rights
1  1233	    0276  80 E6	60				 and	 dh,60h	 ; a¡sla PL
1  1234	    0279  66| B9 00000007			 mov	 ecx,SELECTORS
1  1235	    027F  66| BF 0000056Cr			 mov	 edi,offset gdt+8
1  1236	    0285					 pon_dpl:
1  1237	    0285  26: 67| 08 77	05				 or	 es:[edi+5],dh
1  1238	    028A  B8 000C					 mov	 ax,0Ch
1  1239	    028D  CD 31						 int	 31h
1  1240	    028F  0F 82	FF4C					 jc	 dpmi_error
1  1241	    0293  66| 83 C7 08					 add	 edi,8
1  1242	    0297  03 DD						 add	 bx,bp
1  1243	    0299  E2 EA					 loop	 pon_dpl
1  1244							 ; fix-up de selectores
1  1245	    029B  8E 06	042Br				 mov	 es,word ptr dpmi_sels+4
1  1246	    029F  66| BF 00000000s			 mov	 edi,txcode32
1  1247	    02A5  66| C1 E7 04				 shl	 edi,4
1  1248	    02A9  66| 81 C7 00000000r			 add	 edi,offset C32_SEL
1  1249
1  1250	    02B0  66| BE 00000427r			 mov	 esi,offset dpmi_sels
1  1251	    02B6  66| B9 00000007			 mov	 ecx,SELECTORS
1  1252							 ; si los copiamos con MOVSD no	los copia bien (???)
1  1253	    02BC					 copia_sels:
1  1254	    02BC  66| 67| 8B 06					 mov	 eax,[esi]
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 23
DarkX.ASM



1  1255	    02C0  66| 26: 67| 89 07				 mov	 es:[edi],eax
1  1256	    02C5  66| 83 C7 04					 add	 edi,4
1  1257	    02C9  66| 83 C6 04					 add	 esi,4
1  1258	    02CD  E2 ED					 loop copia_sels
1  1259	    02CF  A1 0427r				 mov	 ax,word ptr dpmi_sels
1  1260
1  1261							 ; SS:ESP = D32_SEL:STACK_PTR
1  1262					 ;		  mov	  ss,dpmi_sels+4
1  1263					 ;		  mov	  esp,stack_ptr
1  1264
1  1265							 ; hacemos el fix-up del salto a protegido antes de cargarnos DS
1  1266	    02D2  A3 0536r				 mov	 word ptr prot_code_address+4,ax
1  1267	    02D5  50					 push	 ax
1  1268
1  1269					 ;		  ; pedimos las	direcciones de los procs. de save/restore
1  1270					 ;		  mov	  ax,305h
1  1271					 ;		  int	  31h
1  1272					 ;		  mov	  word ptr dpmi_save_restore_real,cx
1  1273					 ;		  mov	  word ptr dpmi_save_restore_real+2,bx
1  1274					 ;		  mov	  dword	ptr dpmi_save_restore_pm,edi
1  1275					 ;		  mov	  word ptr dpmi_save_restore_pm+4,si
1  1276					 ;		  ; pedimos las	direcciones de switch en raw mode
1  1277					 ;		  mov	  ax,306h
1  1278					 ;		  int	  31h
1  1279					 ;		  mov	  word ptr dpmi_real_to_pm,cx
1  1280					 ;		  mov	  word ptr dpmi_real_to_pm+2,bx
1  1281					 ;		  mov	  dword	ptr dpmi_pm_to_real,edi
1  1282					 ;		  mov	  word ptr dpmi_pm_to_real+4,si
1  1283
1  1284							 ; nos guardamos las excepciones
1  1285	    02D6  32 DB					 xor	 bl,bl
1  1286	    02D8  66| BF 00000443r			 mov	 edi,offset dpmi_exc_handlers
1  1287	    02DE					 guarda_excs:
1  1288	    02DE  B8 0202					 mov	 ax,202h
1  1289	    02E1  CD 31						 int	 31h
1  1290	    02E3  66| 67| 89 17					 mov	 [edi],edx
1  1291	    02E7  67| 89 4F 04					 mov	 [edi+4],cx
1  1292	    02EB  66| 83 C7 06					 add	 edi,6
1  1293	    02EF  FE C3						 inc	 bl
1  1294	    02F1  80 FB	0F				 cmp	 bl,15
1  1295	    02F4  75 E8					 jnz guarda_excs
1  1296							 ; ajustamos las excepciones 0,1,3-0Eh
1  1297	    02F6  59					 pop	 cx
1  1298	    02F7  51					 push	 cx
1  1299	    02F8  32 DB					 xor	 bl,bl
1  1300	    02FA  66| BA 000026F7r			 mov	 edx,offset interrup_redir
1  1301	    0300					 dpmi_set_excs:
1  1302	    0300  B8 0203					 mov	 ax,203h
1  1303	    0303  CD 31						 int	 31h
1  1304	    0305  0F 82	FED6					 jc	 dpmi_error
1  1305	    0309  FE C3						 inc	 bl
1  1306	    030B  66| 83 C2 08					 add	 edx,8
1  1307	    030F  80 FB	0F				 cmp	 bl,15
1  1308	    0312  75 EC					 jnz	 dpmi_set_excs
1  1309	    0314  66| 8B 16 044Fr			 mov	 edx,dword ptr dpmi_exc_handlers+2*6
1  1310	    0319  8B 0E	0453r				 mov	 cx,word ptr dpmi_exc_handlers+2*6+4
1  1311	    031D  B8 0203				 mov	 ax,203h
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 24
DarkX.ASM



1  1312	    0320  B3 02					 mov	 bl,2	 ; la 2	no es excepci¢n...
1  1313	    0322  CD 31					 int	 31h
1  1314	    0324  0F 82	FEB7				 jc	 dpmi_error
1  1315
1  1316							 ; guardamos las interrupciones
1  1317	    0328  32 DB					 xor	 bl,bl
1  1318	    032A  66| BF 00000000s			 mov	 edi,txcode32
1  1319	    0330  66| C1 E7 04				 shl	 edi,4
1  1320	    0334					 guarda_ints:
1  1321	    0334  B8 0204					 mov	 ax,204h
1  1322	    0337  CD 31						 int	 31h
1  1323								 ASSUME	 ES:txcode32
1  1324	    0339  66| 26: 67| 89 97   +				 mov	 dword ptr es:[edi+idt],edx
   1325		  00001EF7r
1  1326	    0342  26: 67| 89 8F	      +				 mov	 word ptr es:[edi+idt+4],cx
   1327		  00001EFBr
1  1328	    034A  66| 83 C7 06					 add	 edi,6
1  1329	    034E  FE C3					 inc bl
1  1330	    0350  75 E2					 jnz guarda_ints
1  1331
1  1332							 ; ponemos las nuevas int's 21h	y 31h
1  1333	    0352  59					 pop	 cx
1  1334	    0353  51					 push	 cx
1  1335	    0354  B3 21					 mov	 bl,21h
1  1336	    0356  66| BA 00000F2Cr			 mov	 edx,offset tx_int21h
1  1337	    035C  B8 0205				 mov	 ax,205h
1  1338	    035F  CD 31					 int	 31h
1  1339	    0361  0F 82	FE7A				 jc	 dpmi_error
1  1340
1  1341	    0365  59					 pop	 cx
1  1342	    0366  B3 31					 mov	 bl,31h
1  1343	    0368  66| BA 0000001Cr			 mov	 edx,offset tx_int31h
1  1344	    036E  B8 0205				 mov	 ax,205h
1  1345	    0371  CD 31					 int	 31h
1  1346	    0373  0F 82	FE68				 jc	 dpmi_error
1  1347
1  1348							 ; rellenamos info varia para la funci¢n OEM 3201h
1  1349	    0377  2E: 67| A1 00000004r			 mov	 ax,cs:D32_SEL
1  1350	    037E  A3 0331r				 mov	 zero_sel,ax
1  1351	    0381  2E: 67| A1 00000014r			 mov	 ax,cs:DATA_SEL
1  1352	    0388  A3 0333r				 mov	 prog_sel,ax
1  1353	    038B  2E: 67| A1 00000018r			 mov	 ax,cs:ENVRN_SEL
1  1354	    0392  A3 0337r				 mov	 env_selector,ax
1  1355							 ASSUME	 ES:txdata
1  1356
1  1357							 ; y nos vamos al programa
1  1358	    0395  66| FF 2E 0532r			 jmp	 fword ptr prot_code_address
1  1359					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1360
   1361					 INCLUDE	 ints16.inc
1  1362					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1363					 ; Standard DPMI 0.9 Real Mode Call and	Interrupt execution with segment pass
1  1364					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1365	    039A			 dpmi_rm_int:
1  1366	    039A  FA				 cli
1  1367
1  1368						 ASSUME	 SS:txdata
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 25
DarkX.ASM



1  1369	    039B  B8 0000s			 mov	 ax,txdata
1  1370	    039E  8E D0				 mov	 ss,ax
1  1371	    03A0  BC 03E9r			 mov	 sp,offset dpmi_rm_call_struc+2Ah
1  1372	    03A3  2E: 8F 06 04BAr		 pop	 word ptr cs:rm_proc_address
1  1373	    03A8  2E: 8F 06 04BCr		 pop	 word ptr cs:rm_proc_address+2
1  1374	    03AD  2E: 8F 06 04B4r		 pop	 cs:stack_frame
1  1375	    03B2  2E: 8F 06 04B6r		 pop	 cs:stack_frame+2
1  1376	    03B7  66| 2E: 83 3E	04B4r +		 cmp	 dword ptr cs:stack_frame,0
   1377		  00
1  1378	    03BE  75 0E				 jnz	 need_a_stack
1  1379	    03C0  2E: C7 06 04B4r 4000		 mov	 cs:stack_frame,size txpr
1  1380	    03C7  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   1381		  0000s
1  1382	    03CE				 need_a_stack:
1  1383	    03CE  2E: A1 04B8r			 mov	 ax,cs:bytes_in_stack
1  1384	    03D2  2E: 29 06 04B4r		 sub	 cs:stack_frame,ax
1  1385	    03D7  66| 36: A1 0504r		 mov	 eax,ss:pm_eax
1  1386	    03DC  2E: A3 0452r			 mov	 cs:int_or_call,ax
1  1387	    03E0  3D 0300			 cmp	 ax,300h
1  1388	    03E3  75 1E				 jnz	 pre_rm_call
1  1389
1  1390						 ; reajustamos la pila para int	en modo	real
1  1391	    03E5  33 DB				 xor	 bx,bx
1  1392	    03E7  2E: 8C 1E 04B2r		 mov	 cs:trash,ds
1  1393	    03EC  8E DB				 mov	 ds,bx
1  1394	    03EE  36: 8A 1E 0508r		 mov	 bl,byte ptr ss:pm_ebx
1  1395	    03F3  C1 E3	02			 shl	 bx,2
1  1396	    03F6  66| 8B 07			 mov	 eax,ds:[bx]
1  1397	    03F9  66| 2E: A3 04BAr		 mov	 cs:rm_proc_address,eax
1  1398	    03FE  2E: 8E 1E 04B2r		 mov	 ds,cs:trash
1  1399
1  1400	    0403			 pre_rm_call:
1  1401	    0403  BC 03BFr			 mov	 sp,offset dpmi_rm_call_struc
1  1402	    0406  66| 61			 popad
1  1403	    0408  2E: 8F 06 04B2r		 pop	 cs:trash	 ; trash = FLAGS para no cambiarlos con	el CMP
1  1404	    040D  07				 pop	 es
1  1405	    040E  1F				 pop	 ds
1  1406	    040F  0F A1				 pop	 fs
1  1407	    0411  0F A9				 pop	 gs
1  1408	    0413  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
1  1409	    0419  2E: 81 3E 0452r 0301		 cmp	 cs:int_or_call,301h
1  1410	    0420  74 05				 jz	 no_flag_save
1  1411	    0422  2E: FF 36 04B2r		 push	 cs:trash	 ; para	formar un stack	frame de interrupci¢n
1  1412	    0427				 no_flag_save:
1  1413	    0427  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1414
1  1415						 ; copiamos los	segmentos a la estructura
1  1416						 ASSUME	 DS:txdata
1  1417	    042C  1E				 push	 ds
1  1418	    042D  68 0000s			 push	 txdata
1  1419	    0430  1F				 pop	 ds
1  1420	    0431  8C 06	04F4r			 mov	 real_es,es
1  1421	    0435  8C 26	04F8r			 mov	 real_fs,fs
1  1422	    0439  8C 2E	04FAr			 mov	 real_gs,gs
1  1423	    043D  8F 06	04F6r			 pop	 real_ds
1  1424
1  1425						 ; restablecemos la pila por defecto por si ha habido int31h/ax=30xh
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 26
DarkX.ASM



1  1426	    0441  2E: C7 06 04B4r 4000		 mov	 cs:stack_frame,size txpr
1  1427	    0448  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   1428		  0000s
1  1429
1  1430	    044F  E9 053C			 jmp	 set_pm		 ; SET_PM nos grabar  el estado
1  1431
1  1432	    0452  ????			 int_or_call	 dw ?
1  1433					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1434					 ; Real	Mode Interrupt execution without segment pass
1  1435					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1436					 ASSUME	 DS:txdata
1  1437	    0454			 rm_int:
1  1438						 ; reajustamos la pila para int	en modo	real
1  1439	    0454  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
1  1440	    045A  33 DB				 xor	 bx,bx
1  1441	    045C  2E: 8C 1E 04B2r		 mov	 cs:trash,ds
1  1442	    0461  8E DB				 mov	 ds,bx
1  1443	    0463  2E: 8A 1E 04B1r		 mov	 bl,cs:int_num
1  1444	    0468  C1 E3	02			 shl	 bx,2
1  1445	    046B  66| 8B 07			 mov	 eax,[bx]
1  1446	    046E  66| 2E: A3 04BAr		 mov	 cs:rm_proc_address,eax
1  1447	    0473  2E: 8E 1E 04B2r		 mov	 ds,cs:trash
1  1448
1  1449	    0478  1E				 push	 ds
1  1450
1  1451	    0479  B8 0000s			 mov	 ax,txdata
1  1452	    047C  8E D8				 mov	 ds,ax
1  1453
1  1454						 ; recuperamos los registros
1  1455	    047E  66| A1 0504r			 mov	 eax,pm_eax
1  1456	    0482  66| 8B 1E 0508r		 mov	 ebx,pm_ebx
1  1457	    0487  66| 8B 0E 050Cr		 mov	 ecx,pm_ecx
1  1458	    048C  66| 8B 16 0510r		 mov	 edx,pm_edx
1  1459	    0491  66| 8B 36 0514r		 mov	 esi,pm_esi
1  1460	    0496  66| 8B 3E 0518r		 mov	 edi,pm_edi
1  1461	    049B  66| 8B 2E 051Cr		 mov	 ebp,pm_ebp
1  1462	    04A0  66| FF 36 0524r		 push	 pm_eflags
1  1463	    04A5  66| 9D			 popfd
1  1464	    04A7  1F				 pop	 ds
1  1465
1  1466	    04A8  9C				 pushf		 ; para	formar un stack	frame de interrupci¢n
1  1467	    04A9  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1468
1  1469	    04AE  E9 04DD			 jmp	 set_pm		 ; SET_PM nos grabar  el estado
1  1470
1  1471	    04B1  ??			 int_num	 db ?
1  1472	    04B2  ????			 trash		 dw ?
1  1473	    04B4  4000 ????		 stack_frame	 dw size txpr,?
1  1474	    04B8  0000			 bytes_in_stack	 dw 0
1  1475	    04BA  ????????		 rm_proc_address dd ?
1  1476					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1477	    04BE			 irq16:
1  1478	    04BE  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
1  1479	    04C4  81 EC	2000			 sub	 sp,(RM_STACKSIZE/2)*4	 ; por si pillamos un proc real	entrando
1  1480	    04C8  9C				 pushf			 ; stack frame de interrupci¢n
1  1481	    04C9  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1482	    04CE  B8 0000s			 mov	 ax,txdata
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 27
DarkX.ASM



1  1483	    04D1  8E D8				 mov	 ds,ax
1  1484	    04D3  FF 26	0530r			 jmp	 set_pm_address
1  1485					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1486
   1487					 INCLUDE	 cback16.inc
1  1488					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1489					 ; Real	Mode Call-Back routines
1  1490					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1491
1  1492					 ; number of needed call-back slots
1  1493		  =0020			 CALLBACKS	 EQU 32
1  1494
1  1495					 ; call-back address table
1  1496	    04D7			 callback_address_table:
1  1497	    04D7  50				 push	 ax
1  1498	    04D8  B8 0000			 mov	 ax,0
1  1499	    04DB  E9 0117			 jmp	 callback_manager
1  1500	    04DE			 end_of_cb_address:    ; we need it to calculate the length
1  1501		  =000F			 CBSLOT=size TCallBack
1  1502					 REPT	 (CALLBACKS-1)
1  1503						 push	 ax
1  1504						 mov	 ax,CBSLOT
1  1505						 jmp	 word ptr callback_manager
1  1506						 CBSLOT=CBSLOT+size TCallBack
1  1507					 ENDM
2  1508	    04DE  50				 push	 ax
2  1509	    04DF  B8 000F			 mov	 ax,CBSLOT
2  1510	    04E2  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1511	    04E7  50				 push	 ax
2  1512	    04E8  B8 001E			 mov	 ax,CBSLOT
2  1513	    04EB  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1514	    04F0  50				 push	 ax
2  1515	    04F1  B8 002D			 mov	 ax,CBSLOT
2  1516	    04F4  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1517	    04F9  50				 push	 ax
2  1518	    04FA  B8 003C			 mov	 ax,CBSLOT
2  1519	    04FD  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1520	    0502  50				 push	 ax
2  1521	    0503  B8 004B			 mov	 ax,CBSLOT
2  1522	    0506  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1523	    050B  50				 push	 ax
2  1524	    050C  B8 005A			 mov	 ax,CBSLOT
2  1525	    050F  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1526	    0514  50				 push	 ax
2  1527	    0515  B8 0069			 mov	 ax,CBSLOT
2  1528	    0518  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1529	    051D  50				 push	 ax
2  1530	    051E  B8 0078			 mov	 ax,CBSLOT
2  1531	    0521  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1532	    0526  50				 push	 ax
2  1533	    0527  B8 0087			 mov	 ax,CBSLOT
2  1534	    052A  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1535	    052F  50				 push	 ax
2  1536	    0530  B8 0096			 mov	 ax,CBSLOT
2  1537	    0533  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1538	    0538  50				 push	 ax
2  1539	    0539  B8 00A5			 mov	 ax,CBSLOT
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 28
DarkX.ASM



2  1540	    053C  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1541	    0541  50				 push	 ax
2  1542	    0542  B8 00B4			 mov	 ax,CBSLOT
2  1543	    0545  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1544	    054A  50				 push	 ax
2  1545	    054B  B8 00C3			 mov	 ax,CBSLOT
2  1546	    054E  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1547	    0553  50				 push	 ax
2  1548	    0554  B8 00D2			 mov	 ax,CBSLOT
2  1549	    0557  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1550	    055C  50				 push	 ax
2  1551	    055D  B8 00E1			 mov	 ax,CBSLOT
2  1552	    0560  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1553	    0565  50				 push	 ax
2  1554	    0566  B8 00F0			 mov	 ax,CBSLOT
2  1555	    0569  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1556	    056E  50				 push	 ax
2  1557	    056F  B8 00FF			 mov	 ax,CBSLOT
2  1558	    0572  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1559	    0577  50				 push	 ax
2  1560	    0578  B8 010E			 mov	 ax,CBSLOT
2  1561	    057B  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1562	    0580  50				 push	 ax
2  1563	    0581  B8 011D			 mov	 ax,CBSLOT
2  1564	    0584  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1565	    0589  50				 push	 ax
2  1566	    058A  B8 012C			 mov	 ax,CBSLOT
2  1567	    058D  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1568	    0592  50				 push	 ax
2  1569	    0593  B8 013B			 mov	 ax,CBSLOT
2  1570	    0596  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1571	    059B  50				 push	 ax
2  1572	    059C  B8 014A			 mov	 ax,CBSLOT
2  1573	    059F  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1574	    05A4  50				 push	 ax
2  1575	    05A5  B8 0159			 mov	 ax,CBSLOT
2  1576	    05A8  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1577	    05AD  50				 push	 ax
2  1578	    05AE  B8 0168			 mov	 ax,CBSLOT
2  1579	    05B1  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1580	    05B6  50				 push	 ax
2  1581	    05B7  B8 0177			 mov	 ax,CBSLOT
2  1582	    05BA  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1583	    05BF  50				 push	 ax
2  1584	    05C0  B8 0186			 mov	 ax,CBSLOT
2  1585	    05C3  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1586	    05C8  50				 push	 ax
2  1587	    05C9  B8 0195			 mov	 ax,CBSLOT
2  1588	    05CC  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1589	    05D1  50				 push	 ax
2  1590	    05D2  B8 01A4			 mov	 ax,CBSLOT
2  1591	    05D5  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1592	    05DA  50				 push	 ax
2  1593	    05DB  B8 01B3			 mov	 ax,CBSLOT
2  1594	    05DE  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1595	    05E3  50				 push	 ax
2  1596	    05E4  B8 01C2			 mov	 ax,CBSLOT
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 29
DarkX.ASM



2  1597	    05E7  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1598	    05EC  50				 push	 ax
2  1599	    05ED  B8 01D1			 mov	 ax,CBSLOT
2  1600	    05F0  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
1  1601
1  1602	000005F5			 Trm_reg	 STRUC
1  1603	00000000  01*(????????)			 rm_edi		 dd ?
1  1604	00000004  01*(????????)			 rm_esi		 dd ?
1  1605	00000008  01*(????????)			 rm_ebp		 dd ?
1  1606	0000000C  01*(????????)					 dd ?
1  1607	00000010  01*(????????)			 rm_ebx		 dd ?
1  1608	00000014  01*(????????)			 rm_edx		 dd ?
1  1609	00000018  01*(????????)			 rm_ecx		 dd ?
1  1610	0000001C  01*(????????)			 rm_eax		 dd ?
1  1611	00000020  01*(????)			 rm_flags	 dw ?
1  1612	00000022  01*(????)			 rm_es		 dw ?
1  1613	00000024  01*(????)			 rm_ds		 dw ?
1  1614	00000026  01*(????)			 rm_fs		 dw ?
1  1615	00000028  01*(????)			 rm_gs		 dw ?
1  1616	0000002A  01*(????)			 rm_ip		 dw ?
1  1617	0000002C  01*(????)			 rm_cs		 dw ?
1  1618	0000002E  01*(????)			 rm_sp		 dw ?
1  1619	00000030  01*(????)			 rm_ss		 dw ?
1  1620	00000032			 ENDS
1  1621
1  1622					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1623					 ; Call-Back Management	procedure with IMS technology (Infinite	Mode Switch)
1  1624					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1625	    05F5			 callback_manager:
1  1626						 ; guardamos el	puntero	de pila	actual en modo real
1  1627	    05F5  2E: 89 26 0692r		 mov	 word ptr cs:pila_real,sp
1  1628	    05FA  2E: 8C 16 0694r		 mov	 word ptr cs:pila_real+2,ss
1  1629						 ; guardamos el	n£mero de call-back para el c¢digo en protegido
1  1630	    05FF  2E: A3 0690r			 mov	 cs:callback_code,ax
1  1631						 ; guardamos el	estado de la CPU
1  1632	    0603  66| 9C			 pushfd
1  1633	    0605  66| 60			 pushad
1  1634	    0607  1E 06	0F A0 0F A8		 push	 ds es fs gs
1  1635
1  1636						 ; protegemos el stack switching
1  1637	    060D  FA				 cli
1  1638
1  1639						 ; ahora que podemos cambiar los flags,	cambiamos 'pila_real'
1  1640	    060E  2E: 83 06 0692r 02		 add	 word ptr cs:pila_real,2	 ; POP AX
1  1641
1  1642						 ; guardamos las direcciones de	cambio de modos
1  1643						 ASSUME	 DS:txdata
1  1644	    0614  B8 0000s			 mov	 ax,txdata
1  1645	    0617  8E D8				 mov	 ds,ax
1  1646	    0619  66| FF 36 0532r		 push	 dword ptr prot_code_address
1  1647	    061E  FF 36	0536r			 push	 word ptr prot_code_address+4
1  1648	    0622  66| 2E: FF 36	0019r		 push	 dword ptr cs:saltito+1
1  1649
1  1650						 ; ponemos las nuevas
1  1651	    0628  66| C7 06 0532r     +		 mov	 dword ptr prot_code_address,offset callback_pm
   1652		  00000E61r
1  1653
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 30
DarkX.ASM



1  1654						 ; guardamos el	stack frame anterior en	la pila	actual
1  1655	    0631  66| 2E: FF 36	0682r		 push	 dword ptr cs:current_stackframe
1  1656						 ; stack frame actual en la variable de	c¢digo
1  1657	    0637  2E: 89 26 0682r		 mov	 word ptr cs:current_stackframe,sp
1  1658	    063C  2E: 8C 16 0684r		 mov	 word ptr cs:current_stackframe+2,ss
1  1659
1  1660	    0641  FF 26	0530r			 jmp	 set_pm_address
1  1661
1  1662	    0645				 cback16_return:
1  1663	    0645  FA				 cli
1  1664						 ; recuperamos el stack	frame
1  1665	    0646  2E: 0F B2 26 0682r		 lss	 sp,dword ptr cs:current_stackframe
1  1666						 ; ponemos el del posible call back anterior
1  1667	    064C  66| 2E: 8F 06	0682r		 pop	 dword ptr cs:current_stackframe
1  1668
1  1669						 ; recuperamos las direcciones de cambio de modo
1  1670	    0652  B8 0000s			 mov	 ax,txdata
1  1671	    0655  8E D8				 mov	 ds,ax
1  1672	    0657  66| 2E: 8F 06	0019r		 pop	 dword ptr cs:saltito+1
1  1673	    065D  8F 06	0536r			 pop	 word ptr prot_code_address+4
1  1674	    0661  66| 8F 06 0532r		 pop	 dword ptr prot_code_address
1  1675
1  1676						 ; recuperamos el estado de la CPU
1  1677	    0666  0F A9	0F A1 07 1F		 pop	 gs fs es ds
1  1678	    066C  66| 61			 popad
1  1679	    066E  66| 9D			 popfd
1  1680
1  1681	    0670  58				 pop	 ax
1  1682
1  1683						 ; restauramos SS,SP,CS,IP y FLAGS de la estructura de modo real	mov
1  1684	    0671  2E: FF 36 068Er		 push	 cs:new_flags
1  1685	    0676  9D				 popf
1  1686	    0677  2E: 0F B2 26 068Ar		 lss	 sp,cs:new_stack
1  1687	    067D  2E: FF 2E 0686r		 jmp	 dword ptr cs:new_code
1  1688
1  1689	    0682  ????????		 current_stackframe	 dd ?
1  1690	    0686  ????????		 new_code		 dd ?
1  1691	    068A  ????????		 new_stack		 dd ?
1  1692	    068E  ????			 new_flags		 dw ?
1  1693	    0690  ????			 callback_code		 dw ?
1  1694	    0692  ????????		 pila_real		 dd ?
1  1695
   1696
   1697
   1698					 ; ////////////////////////////
   1699					 ; PUNTO DE ENTRADA DE DarkX.EXE
   1700					 ; ////////////////////////////
   1701	    0696			 init_pm:
   1702					 ;	  inc	  dx
   1703					 ;	  xor	  ax,2E32h
   1704					 ;	  dec	  dx
   1705					 ;	  xor	  ax,2e32h
   1706
   1707						 ; presentamos el Copyright y el t¡tulo
   1708	    0696  1E				 push	 ds
   1709	    0697  BA 0000r			 mov	 dx,offset copyright_msg
   1710	    069A  E8 0702			 call	 printf
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 31
DarkX.ASM



   1711	    069D  1F				 pop	 ds
   1712
   1713						 ; comprobamos que el DOS sea 3.0+
   1714	    069E  B4 30				 mov	 ah,30h
   1715	    06A0  CD 21				 int	 21h
   1716	    06A2  3C 03				 cmp	 al,3
   1717	    06A4  BA 0144r			 mov	 dx,offset dos_version_error_msg
   1718	    06A7  0F 82	06EE			 jb	 error_handle1
   1719
   1720						 ; buscamos nuestro nombre
   1721	    06AB  8E 06	002C			 mov	 es,ds:[2Ch]
   1722	    06AF  33 FF				 xor	 di,di
   1723	    06B1  B9 FFFF			 mov	 cx,-1
   1724	    06B4  33 C0				 xor	 ax,ax
   1725	    06B6				 cont_searching:
   1726	    06B6  F2> AE			 repnz	 scasb
   1727	    06B8  AE				 scasb
   1728	    06B9  75 FB				 jnz	 cont_searching
   1729	    06BB  83 C7	02			 add	 di,2
   1730	    06BE  66| 33 C9			 xor	 ecx,ecx
   1731	    06C1  8C C1				 mov	 cx,es
   1732	    06C3  66| 0F B7 FF			 movzx	 edi,di
   1733	    06C7  66| C1 E1 04			 shl	 ecx,4
   1734	    06CB  66| 03 CF			 add	 ecx,edi
   1735
   1736						 ; rellenamos info varia
   1737	    06CE  66| 33 DB			 xor	 ebx,ebx
   1738	    06D1  8C DB				 mov	 bx,ds
   1739	    06D3  B8 0000s			 mov	 ax,txdata
   1740	    06D6  8E D8				 mov	 ds,ax
   1741	    06D8  89 1E	04D0r			 mov	 psp_seg,bx
   1742	    06DC  66| C1 E3 04			 shl	 ebx,4
   1743	    06E0  66| 89 1E 0325r		 mov	 psp_offset,ebx
   1744	    06E5  66| 33 DB			 xor	 ebx,ebx
   1745	    06E8  8C C3				 mov	 bx,es
   1746	    06EA  66| C1 E3 04			 shl	 ebx,4
   1747	    06EE  66| 89 1E 0329r		 mov	 env_offset,ebx
   1748	    06F3  66| 89 0E 032Dr		 mov	 program_name_ptr,ecx
   1749	    06F8  B8 0000s			 mov	 ax,disk
   1750	    06FB  A3 0339r			 mov	 disk_seg,ax
   1751						 ; fix-up del descriptor del ENVIRONMENT (necesario bajo todos sistemas)
   1752	    06FE  8E 26	04D0r			 mov	 fs,psp_seg
   1753	    0702  66| 64: 0F B7	06    +		 movzx	 eax,word ptr fs:[2Ch]
   1754		  002C
   1755	    0709  66| C1 E0 04			 shl	 eax,4
   1756	    070D  A3 059Er			 mov	 word ptr env_desc+2,ax
   1757	    0710  66| C1 E8 10			 shr	 eax,16
   1758	    0714  A2 05A0r			 mov	 byte ptr env_desc+4,al
   1759	    0717  88 26	05A3r			 mov	 byte ptr env_desc+7,ah
   1760
   1761	    071B  E8 058A			 call	 cpuid
   1762	    071E  BA 01C2r			 mov	 dx,offset no386_error_msg
   1763	    0721  0F 82	0674			 jc	 error_handle1
   1764	    0725  A3 033Fr			 mov	 cpu_info,ax
   1765	    0728  80 FC	05			 cmp	 ah,5
   1766	    072B  76 02				 jbe	 have_cpu_name
   1767	    072D  B4 05					 mov	 ah,5
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 32
DarkX.ASM



   1768	    072F				 have_cpu_name:
   1769	    072F  50				 push	 ax
   1770	    0730  33 DB				 xor	 bx,bx
   1771	    0732  8A DC				 mov	 bl,ah
   1772	    0734  D1 E3				 shl	 bx,1
   1773	    0736  8B 97	00A6r			 mov	 dx,[bx+cpu_strings-3*2]
   1774	    073A  52				 push	 dx
   1775	    073B  BA 009Br			 mov	 dx,offset cpu_type_msg
   1776	    073E  E8 065E			 call	 printf
   1777	    0741  5A				 pop	 dx
   1778	    0742  E8 065A			 call	 printf
   1779	    0745  58				 pop	 ax
   1780	    0746  80 FC	05			 cmp	 ah,5
   1781	    0749  73 13				 jae	 no_fpu_det_needed
   1782
   1783	    074B  E8 05E9			 call	 fpuid
   1784	    074E  A2 0342r			 mov	 fpu_info,al
   1785	    0751  33 DB				 xor	 bx,bx
   1786	    0753  8A D8				 mov	 bl,al
   1787	    0755  D1 E3				 shl	 bx,1
   1788	    0757  8B 97	00C3r			 mov	 dx,[bx+fpu_strings]
   1789	    075B  E8 0641			 call	 printf
   1790
   1791	    075E				 no_fpu_det_needed:
   1792						 ; cambiamos el	tama¤o del bloque de programa
   1793	    075E  E8 0648			 call	 init_mem
   1794
   1795						 ; comprobamos si hay DPMI
   1796	    0761  B8 1687			 mov	 ax,1687h
   1797	    0764  CD 2F				 int	 2Fh
   1798	    0766  0B C0				 or	 ax,ax
   1799	    0768  75 0B				 jnz	 no_dpmi
   1800
   1801	    076A  80 0E	0341r 02			 or	 system_type,2
   1802	    076F  E8 FA93				 call	 save_dpmi_data
   1803	    0772  E9 01CB				 jmp	 mem_alloc_done
   1804
   1805	    0775				 no_dpmi:
   1806						 ; ponemos un par de selectores
   1807	    0775  B8 0000s			 mov	 ax,txcode32
   1808	    0778  8E D8				 mov	 ds,ax
   1809						 ASSUME	 DS:txcode32
   1810	    077A  67| A1 00000000r		 mov	 ax,C32_SEL
   1811						 ASSUME	 DS:txdata
   1812	    0780  BB 0000s			 mov	 bx,txdata
   1813	    0783  8E DB				 mov	 ds,bx
   1814	    0785  A3 0562r			 mov	 word ptr vcpi_cs_eip+4,ax
   1815	    0788  A3 0536r			 mov	 word ptr prot_code_address+4,ax
   1816
   1817						 ; comprobamos si hay VCPI
   1818						 ; primero miramos si hay vector o no...
   1819	    078B  33 C0				 xor	 ax,ax
   1820	    078D  8E C0				 mov	 es,ax
   1821	    078F  66| 26: 83 3E	019C  +		 cmp	 dword ptr es:[67h*4],0
   1822		  00
   1823	    0796  74 20				 jz	 vcpi_not_present
   1824	    0798  B8 DE00			 mov	 ax,0DE00h
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 33
DarkX.ASM



   1825	    079B  CD 67				 int	 67h
   1826	    079D  0A E4				 or	 ah,ah
   1827	    079F  75 17				 jnz	 vcpi_not_present
   1828							 ASSUME	 DS:txdata
   1829	    07A1  FE 06	0341r				 inc	 system_type
   1830							 save_vcpi_data
1  1831	    07A5  B8 0000s			 mov	 ax,txdata
1  1832	    07A8  8E D8				 mov	 ds,ax
1  1833	    07AA  C7 06	0530r 0090r		 mov	 set_pm_address,offset set_pm_vcpi
1  1834	    07B0  C7 06	0538r 0038r		 mov	 ret_real_address,offset ret_real_vcpi
   1835	    07B6  EB 13					 jmp	 avoid_v86_test
   1836							 ASSUME	 DS:txdata
   1837	    07B8				 vcpi_not_present:
   1838
   1839						 ; si no hay VCPI tampoco, comprobamos si estamos en V86
   1840	    07B8  80 3E	0341r 00		 cmp	 system_type,0
   1841	    07BD  75 0C				 jnz	 avoid_v86_test
   1842	    07BF  0F 01	E0			 smsw	 ax
   1843	    07C2  A8 01				 test	 al,1
   1844						 ; si lo estamos salimos con error
   1845	    07C4  BA 0186r			 mov	 dx,offset v86_error_msg
   1846	    07C7  0F 85	05CE			 jnz	 error_handle1
   1847
   1848						 ; si llegamos aki, estamos en RAW / XMS : lo averiguamos
   1849	    07CB				 avoid_v86_test:
   1850	    07CB  B8 4300			 mov	 ax,4300h
   1851	    07CE  CD 2F				 int	 2Fh
   1852	    07D0  3C 80				 cmp	 al,80h
   1853	    07D2  0F 85	0095			 jnz	 no_xms
   1854	    07D6  B8 4310				 mov	 ax,4310h
   1855	    07D9  CD 2F					 int	 2Fh
   1856	    07DB  89 1E	0347r				 mov	 word ptr xms_entry_point,bx
   1857	    07DF  8C 06	0349r				 mov	 word ptr xms_entry_point+2,es
   1858	    07E3  B4 05					 mov	 ah,5
   1859	    07E5  FF 1E	0347r				 call	 dword ptr xms_entry_point
   1860	    07E9  0B C0					 or	 ax,ax
   1861	    07EB  75 0A					 jnz	 a20_ok
   1862	    07ED  3D 0094				 cmp	 ax,94h		 ; already enabled
   1863	    07F0  BA 0165r				 mov	 dx,offset A20_error_msg
   1864	    07F3  0F 85	05A2				 jnz	 error_handle1
   1865	    07F7					 a20_ok:
   1866							 alloc_xms_mem
1  1867	    07F7  B8 0000s			 mov	 ax,txcode32
1  1868	    07FA  8E C0				 mov	 es,ax
1  1869	    07FC  26: 67| C6 05	      +		 mov	 byte ptr es:extended_pointers,0
   1870		  00003228r 00
1  1871	    0805  33 FF				 xor	 di,di
1  1872	    0807				 cont_adding_xms:
1  1873	    0807  B4 08				 mov	 ah,8
1  1874	    0809  32 DB				 xor	 bl,bl
1  1875	    080B  FF 1E	0347r			 call	 dword ptr xms_entry_point
1  1876	    080F  0A DB				 or	 bl,bl
1  1877	    0811  75 55				 jnz	 xms_alloc_done
1  1878	    0813  50				 push	 ax
1  1879	    0814  8B D0				 mov	 dx,ax
1  1880	    0816  B4 09				 mov	 ah,9
1  1881	    0818  FF 1E	0347r			 call	 dword ptr xms_entry_point
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 34
DarkX.ASM



1  1882	    081C  59				 pop	 cx
1  1883	    081D  0B C0				 or	 ax,ax
1  1884	    081F  74 47				 jz	 xms_alloc_done
1  1885	    0821  26: 89 95 3549r		 mov	 word ptr es:[di+xms_handles],dx
1  1886	    0826  26: 67| FE 05	      +		 inc	 byte ptr es:extended_pointers
   1887		  00003228r
1  1888	    082E  B4 0C				 mov	 ah,0Ch
1  1889	    0830  FF 1E	0347r			 call	 dword ptr xms_entry_point
1  1890	    0834  0B C0				 or	 ax, ax
1  1891	    0836  75 0B				 jnz	 page_is_locked	 ; si no la bloquea, no	la a¤adimos a la heap
1  1892	    0838  26: 67| FE 0D	      +			 dec	 byte ptr es:extended_pointers
   1893		  00003228r
1  1894	    0840  E9 0256				 jmp	 cont_adding
1  1895	    0843				 page_is_locked:
1  1896	    0843  66| C1 E2 10			 shl	 edx,16
1  1897	    0847  8B D3				 mov	 dx,bx
1  1898	    0849  66| 0F B7 C9			 movzx	 ecx,cx
1  1899	    084D  66| C1 E1 0A			 shl	 ecx,10
1  1900	    0851  66| 26: 89 95	3229r		 mov	 dword ptr es:[di+extended_pointers+1],edx
1  1901	    0857  66| 26: 89 8D	322Dr		 mov	 dword ptr es:[di+extended_pointers+1+4],ecx
1  1902	    085D  83 C7	08			 add	 di,8
1  1903	    0860  81 FF	0320			 cmp	 di,8*100
1  1904	    0864  74 02				 je	 xms_alloc_done
1  1905	    0866  EB 9F				 jmp	 cont_adding_xms
1  1906	    0868				 xms_alloc_done:
   1907	    0868  E9 00D5				 jmp	 mem_alloc_done
   1908	    086B				 no_xms:
   1909						 ; activamos la	A20 a mano
   1910	    086B  E8 03A9			 call	 enable_A20
   1911						 ; pillamos extendida con int15h
   1912	    086E  B8 0000s			 mov	 ax,txcode32
   1913	    0871  8E C0				 mov	 es,ax
   1914	    0873  26: 67| C6 05	      +		 mov	 byte ptr es:extended_pointers,0
   1915		  00003228r 00
   1916	    087C  B4 88				 mov	 ah,88h
   1917	    087E  CD 15				 int	 15h
   1918	    0880  66| 0F B7 C0			 movzx	 eax,ax
   1919	    0884  66| 0B C0			 or	 eax,eax
   1920	    0887  0F 84	00B5			 jz	 mem_alloc_done		 ; ¨tenemos extendida?
   1921	    088B  66| C1 E0 0A			 shl	 eax,10	 ; *1024 pq lo queremos	en bytes
   1922						 ASSUME	 ES:txcode32
   1923	    088F  26: 67| FE 05	      +		 inc	 byte ptr es:extended_pointers
   1924		  00003228r
   1925	    0897  66| 26: 67| A3      +		 mov	 dword ptr es:extended_pointers+5,eax
   1926		  0000322Dr
   1927						 look_for_extended_beginning
1  1928	    089F  33 C0				 xor	 ax,ax
1  1929	    08A1  8E E0				 mov	 fs,ax
1  1930	    08A3  48				 dec	 ax
1  1931	    08A4  8E E8				 mov	 gs,ax
1  1932	    08A6  64: 8E 26 0066		 mov	 fs,fs:[19h*4+2]
1  1933	    08AB  66| B8 00100000		 mov	 eax,100000h
1  1934	    08B1  66| 64: 81 3E	0012  +		 cmp	 dword ptr fs:[12h],'SIDV'
   1935		  53494456
1  1936	    08BB  75 24				 jnz	 method_2
1  1937	    08BD  66| 64: 8B 16	0016		 mov	 edx,fs:[12h+4]
1  1938	    08C3  66| C1 E2 08			 shl	 edx,8
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 35
DarkX.ASM



1  1939	    08C7  66| C1 EA 08			 shr	 edx,8
1  1940	    08CB  66| 81 FA 0056204B		 cmp	 edx,'V	K'
1  1941	    08D2  75 0D				 jnz	 method_2
1  1942	    08D4  66| 64: A1 002C		 mov	 eax,fs:[2Ch]
1  1943	    08D9  66| C1 E0 08			 shl	 eax,8
1  1944	    08DD  66| C1 E8 08			 shr	 eax,8
1  1945	    08E1				 method_2:
1  1946	    08E1  66| 65: 81 3E	0013  +		 cmp	 dword ptr gs:[16+3],'SIDV'
   1947		  53494456
1  1948	    08EB  75 21				 jnz	 extended_init_found
1  1949	    08ED  65: 80 3E 0017 4B		 cmp	 byte ptr gs:[16+3+4],'K'
1  1950	    08F3  75 19				 jnz	 extended_init_found
1  1951	    08F5  66| 65: 0F B7	16    +		 movzx	 edx,word ptr gs:[16+1Eh]     ;	+16 para el siguiente segmento
   1952		  002E
1  1953	    08FC  66| C1 E2 0A			 shl	 edx,10
1  1954	    0900  66| 81 C2 00100000		 add	 edx,100000h
1  1955	    0907  66| 3B D0			 cmp	 edx,eax
1  1956	    090A  76 02				 jbe	 extended_init_found
1  1957	    090C  66| 92			 xchg	 edx,eax
1  1958	    090E				 extended_init_found:
   1959	    090E  66| 26: 67| A3      +		 mov	 dword ptr es:extended_pointers+1,eax
   1960		  00003229r
   1961	    0916  66| 26: 67| 29 05   +		 sub	 dword ptr es:extended_pointers+5,eax	 ; si empieza despu‚s,
   1962		  0000322Dr
   1963	    091F  66| 26: 67| 81 05   +		 add	 dword ptr es:extended_pointers+5,100000h; es m s peque¤a
   1964		  0000322Dr 00100000
   1965	    092C  66| 26: 67| 83 3D   +		 cmp	 dword ptr es:extended_pointers+5,0	 ; ¨tenemos extendida?
   1966		  0000322Dr 00
   1967	    0936  75 08				 jnz	 mem_alloc_done
   1968	    0938  26: 67| FE 0D	      +			 dec	 byte ptr es:extended_pointers	 ; si no, 0 bloques
   1969		  00003228r
   1970
   1971	    0940				 mem_alloc_done:
   1972						 ; inicializamos los datos comunes
   1973	    0940  E8 0198			 call	 init_data
   1974
   1975						 ; si tenemos DPMI, entramos en	protegido aqu¡ (s¢lo inicializaci¢n)
   1976	    0943  B8 0000s			 mov	 ax,txdata
   1977	    0946  8E D8				 mov	 ds,ax
   1978	    0948  A0 0341r			 mov	 al,system_type
   1979	    094B  A8 02				 test	 al,2
   1980	    094D  74 17				 jz	 no_dpmi_init
   1981					 ;		  call	  alloc_dos_mem
   1982	    094F  BB FFFF				 mov	 bx,-1
   1983	    0952  B4 48					 mov	 ah,48h
   1984	    0954  CD 21					 int	 21h	 ; largest DOS memory block for	info exit
   1985	    0956  66| 0F B7 DB				 movzx	 ebx,bx
   1986	    095A  66| C1 E3 04				 shl	 ebx,4
   1987	    095E  66| 89 1E 031Dr			 mov	 dos_mem_size,ebx
   1988	    0963  E9 F8C1				 jmp	 dpmi_init
   1989
   1990	    0966				 no_dpmi_init:
   1991						 ; si tenemos VCPI lo inicializamos
   1992	    0966  A8 01				 test	 al,1
   1993	    0968  74 03				 jz	 get_all_mem	 ; Si es RAW/XMS no hace falta inicializar nada
   1994
   1995	    096A  E8 F741				 call	 vcpi_init
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 36
DarkX.ASM



   1996
   1997	    096D				 get_all_mem :
   1998						 ; int's 50h-57h = irq's para el redireccionamiento
   1999	    096D  33 C0				 xor	 ax,ax
   2000	    096F  8E D8				 mov	 ds,ax
   2001	    0971  8E C0				 mov	 es,ax
   2002	    0973  BF 0140			 mov	 di,50h*4
   2003	    0976  2E: 0F B6 36 0A68r		 movzx	 si,cs:irq_base
   2004	    097C  C1 E6	02			 shl	 si,2
   2005	    097F  B9 0008			 mov	 cx,8
   2006	    0982  FA				 cli
   2007	    0983  F3> 66| A5			 rep	 movsd
   2008						 ; redireccionamos las irqs
   2009	    0986  B4 50				 mov	 ah,50h
   2010	    0988  E8 0451			 call	 irq_redir
   2011						 ; alojamos toda la memoria del	DOS
   2012	    098B  E8 00FB			 call	 alloc_dos_mem
   2013
   2014					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2015					 ; RUTINA DE SALTO A PROTEGIDO PARA TODOS LOS SISTEMAS (MODO REAL)
   2016					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2017	    098E			 set_pm:
   2018	    098E  9C				 pushf
   2019	    098F  FA				 cli
   2020	    0990  68 0000s			 push	 txdata
   2021	    0993  1F				 pop	 ds
   2022	    0994  8F 06	04F2r			 pop	 word ptr real_flags
   2023	    0998  66| A3 04EEr			 mov	 real_eax,eax
   2024					 ;	  mov	  ax,word ptr pm_eflags
   2025					 ;	  and	  ax,1 SHL 9	      ;	IF will	be 1 if	activated in any mode
   2026					 ;	  or	  word ptr real_flags,ax
   2027	    099C  66| 89 1E 04E2r		 mov	 real_ebx,ebx
   2028	    09A1  66| 89 0E 04EAr		 mov	 real_ecx,ecx
   2029	    09A6  66| 89 16 04E6r		 mov	 real_edx,edx
   2030	    09AB  66| 89 36 04D6r		 mov	 real_esi,esi
   2031	    09B0  66| 89 3E 04D2r		 mov	 real_edi,edi
   2032	    09B5  66| 89 2E 04DAr		 mov	 real_ebp,ebp
   2033	    09BA  FF 26	0530r			 jmp	 set_pm_address
   2034
   2035					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2036					 ; RUTINA DE VUELTA A REAL PARA	TODOS LOS SISTEMAS (MODO PROTEGIDO)
   2037					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2038					 ; como	se ejecuta en segmento de 16 bits, hay que evitar prefijos
   2039	    09BE			 ret_real:
   2040	    09BE  66| 9C			 pushfd
   2041	    09C0  66| 8F 06 0524r		 pop	 dword ptr pm_eflags
   2042	    09C5  FA				 cli
   2043	    09C6  8C 16	037Er			 mov	 pm_ss,ss
   2044	    09CA  66| A3 0504r			 mov	 pm_eax,eax
   2045	    09CE  66| 89 1E 0508r		 mov	 pm_ebx,ebx
   2046	    09D3  66| 89 0E 050Cr		 mov	 pm_ecx,ecx
   2047	    09D8  66| 89 16 0510r		 mov	 pm_edx,edx
   2048	    09DD  66| 89 36 0514r		 mov	 pm_esi,esi
   2049	    09E2  66| 89 3E 0518r		 mov	 pm_edi,edi
   2050	    09E7  66| 89 2E 051Cr		 mov	 pm_ebp,ebp
   2051	    09EC  66| 89 26 0520r		 mov	 pm_esp,esp
   2052	    09F1  FF 26	0538r			 jmp	 ret_real_address
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 37
DarkX.ASM



   2053
   2054					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2055					 ; RUTINAS DE SALIDA AL	SISTEMA	OPERATIVO PARA TODOS LOS SISTEMAS (MODO	REAL)
   2056					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2057					 ; Rutina de salida normal
   2058	    09F5			 s16:
   2059	    09F5  FA				 cli
   2060
   2061						 ; reajustamos la pila para modo real
   2062	    09F6  66| B8 00000000s		 mov	 eax,txpila
   2063	    09FC  8E D0				 mov	 ss,ax
   2064	    09FE  66| C1 E0 04			 shl	 eax,4
   2065	    0A02  66| 2B E0			 sub	 esp,eax
   2066
   2067	    0A05				 fin:
   2068	    0A05  B8 0000s			 mov	 ax,txdata
   2069	    0A08  8E D8				 mov	 ds,ax
   2070	    0A0A  F6 06	0341r 01		 test	 system_type,1
   2071	    0A0F  74 13				 jz	 no_vcpi_end
   2072							 ; avisamos al VCPI de que restauramos las irq's
   2073	    0A11  B8 DE0A				 mov	 ax,0DE0Ah
   2074	    0A14  CD 67					 int	 67h
   2075	    0A16  33 DB					 xor	 bx,bx
   2076	    0A18  2E: 8A 1E 0A68r			 mov	 bl,cs:irq_base
   2077	    0A1D  B8 DE0B				 mov	 ax,0DE0Bh
   2078	    0A20  FA					 cli
   2079	    0A21  CD 67					 int	 67h
   2080	    0A23  FB					 sti
   2081
   2082	    0A24				 no_vcpi_end:
   2083	    0A24  2E: 8A 26 0A68r		 mov	 ah,cs:irq_base
   2084	    0A29  E8 03B0			 call	 irq_redir
   2085	    0A2C				 exit_redirless:
   2086	    0A2C  66| 83 3E 0347r 00		 cmp	 dword ptr xms_entry_point,0
   2087	    0A32  74 2E				 jz	 no_xms_allocated
   2088							 free_xms_mem
1  2089	    0A34  B8 0000s			 mov	 ax,txcode32
1  2090	    0A37  8E D8				 mov	 ds,ax
1  2091	    0A39  B8 0000s			 mov	 ax,txdata
1  2092	    0A3C  8E C0				 mov	 es,ax
1  2093	    0A3E  BE 3549r			 mov	 si,offset xms_handles
1  2094	    0A41  67| 0F B6 0D	      +		 movzx	 cx,byte ptr extended_pointers
   2095		  00003228r
1  2096	    0A49  0B C9				 or	 cx,cx
1  2097	    0A4B  74 15				 jz	 xms_mem_freed
1  2098	    0A4D				 free_xms_blocks:
1  2099	    0A4D  8B 14					 mov	 dx,[si]
1  2100	    0A4F  B4 0D					 mov	 ah,0Dh		 ; UNLOCK block
1  2101	    0A51  26: FF 1E 0347r			 call	 dword ptr es:xms_entry_point
1  2102	    0A56  B4 0A					 mov	 ah,0Ah		 ; FREE	block
1  2103	    0A58  26: FF 1E 0347r			 call	 dword ptr es:xms_entry_point
1  2104	    0A5D  83 C6	08				 add	 si,8
1  2105	    0A60  E2 EB				 loop	 free_xms_blocks
1  2106	    0A62				 xms_mem_freed:
   2107	    0A62				 no_xms_allocated:
   2108	    0A62  FB				 sti		 ; activamos irqs por si hubo excepci¢n	despu‚s	de CLI
   2109	    0A63  B8 4C00			 mov	 ax,4C00h
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 38
DarkX.ASM



   2110	    0A66  CD 21				 int	 21h
   2111
   2112	    0A68  08			 irq_base	 db 8
   2113					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2114
   2115					 ; Rutina de salida por	excepci¢n con informaci¢n de depuraci¢n
   2116	    0A69			 debug_info:
   2117	    0A69  FA				 cli
   2118
   2119	    0A6A  B8 0000s			 mov	 ax,txdata
   2120	    0A6D  8E D8				 mov	 ds,ax
   2121
   2122						 ; reajustamos la pila para modo real
   2123	    0A6F  66| B8 00000000s		 mov	 eax,txpila
   2124	    0A75  8E D0				 mov	 ss,ax
   2125	    0A77  66| C1 E0 04			 shl	 eax,4
   2126	    0A7B  66| 2B E0			 sub	 esp,eax
   2127
   2128	    0A7E  B8 0003			 mov	 ax,3
   2129	    0A81  CD 10				 int	 10h
   2130
   2131	    0A83  BA 06CEr			 mov	 dx,offset debug_info_msg
   2132	    0A86  E9 030A			 jmp	 error_handle
   2133
   2134					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2135					 ; RUTINA DE INICIALIZACION DE DATOS COMUNES A TODOS LOS SISTEMAS (MODO	REAL)
   2136					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2137
   2138	    0A89			 alloc_dos_mem	 proc
   2139
   2140						 ; alojamos la memoria en real por si tenemos un DPMI paginador	de %$#&!
   2141	    0A89  B8 0000s			 mov	 ax,txcode32
   2142	    0A8C  8E D8				 mov	 ds,ax
   2143						 ASSUME	 DS:txcode32
   2144	    0A8E  67| C6 05 00002EFFr +		 mov	 byte ptr dos_pointers,0
   2145		  00
   2146	    0A96  BF 2F00r			 mov	 di,offset dos_pointers+1
   2147	    0A99				 cont_adding:
   2148	    0A99  B4 48				 mov	 ah,48h
   2149	    0A9B  BB FFFF			 mov	 bx,0FFFFh
   2150	    0A9E  CD 21				 int	 21h
   2151	    0AA0  83 FB	02			 cmp	 bx,2
   2152	    0AA3  72 32				 jb	 dos_heap_done
   2153	    0AA5  53				 push	 bx
   2154	    0AA6  B4 48				 mov	 ah,48h
   2155	    0AA8  CD 21				 int	 21h
   2156	    0AAA  59				 pop	 cx
   2157	    0AAB  72 2C				 jc	 heap_error
   2158	    0AAD  67| FE 05 00002EFFr		 inc	 byte ptr dos_pointers
   2159						 ASSUME	 DS:txdata
   2160	    0AB4  66| 33 DB			 xor	 ebx,ebx
   2161	    0AB7  8B D8				 mov	 bx,ax
   2162	    0AB9  66| C1 E3 04			 shl	 ebx,4
   2163	    0ABD  66| 0F B7 C9			 movzx	 ecx,cx
   2164	    0AC1  66| C1 E1 04			 shl	 ecx,4
   2165	    0AC5  66| 89 1D			 mov	 [di],ebx
   2166	    0AC8  66| 89 4D 04			 mov	 [di+4],ecx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 39
DarkX.ASM



   2167	    0ACC  83 C7	08			 add	 di,8
   2168	    0ACF  81 FF	3220r			 cmp	 di,offset dos_pointers+8*100+1
   2169	    0AD3  74 02				 je	 dos_heap_done
   2170	    0AD5  EB C2				 jmp	 cont_adding
   2171	    0AD7				 dos_heap_done:
   2172	    0AD7  F8				 clc
   2173	    0AD8  C3				 ret
   2174
   2175	    0AD9				 heap_error:
   2176	    0AD9  F9				 stc
   2177	    0ADA  C3				 ret
   2178
   2179	    0ADB			 alloc_dos_mem	 endp
   2180
   2181					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2182
   2183	    0ADB			 init_data	 proc
   2184
   2185						 ; inicializamos el stack frame	para interrupciones reales
   2186	    0ADB  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   2187		  0000s
   2188
   2189	    0AE2  FC				 cld
   2190	    0AE3  B8 0000s			 mov	 ax,txcode32
   2191	    0AE6  8E C0				 mov	 es,ax
   2192	    0AE8  B8 0000s			 mov	 ax,txdata
   2193	    0AEB  8E D8				 mov	 ds,ax
   2194
   2195						 ASSUME	 DS:txdata
   2196	    0AED  F6 06	0341r 02		 test	 system_type,2
   2197	    0AF2  75 4C				 jnz	 no_gen_idt
   2198						 ; GENERAMOS LA	IDT
   2199	    0AF4  B8 0008			 mov	 ax,1 SHL 3	 ; C32_SEL con RAW/XMS y VCPI
   2200	    0AF7  66| C1 E0 10			 shl	 eax,16
   2201						 ASSUME	 DS:txcode32
   2202	    0AFB  B8 26F7r			 mov	 ax,offset interrup_redir
   2203	    0AFE  BF 1EF7r			 mov	 di,offset idt
   2204	    0B01  32 C9				 xor	 cl,cl
   2205	    0B03  FC				 cld
   2206	    0B04				 gen_idt:
   2207	    0B04  66| AB				 stosd
   2208	    0B06  66| 26: C7 05	      +			 mov	 dword ptr es:[di],8E00h
   2209		  00008E00
   2210	    0B0E  83 C7	04				 add	 di,4
   2211	    0B11  05 0008				 add	 ax,8
   2212	    0B14  FE C9				 dec	 cl
   2213	    0B16  75 EC				 jnz	 gen_idt
   2214
   2215						 ASSUME	 ES:txcode32
   2216	    0B18  B8 001Cr			 mov	 ax,offset tx_int31h
   2217	    0B1B  66| 26: 67| A3      +		 mov	 es:[idt+8*31h],eax
   2218		  0000207Fr
   2219	    0B23  B8 0F2Cr			 mov	 ax,offset tx_int21h
   2220	    0B26  66| 26: 67| A3      +		 mov	 es:[idt+8*21h],eax
   2221		  00001FFFr
   2222
   2223						 ; fix-up del descriptor del PSP (no necesario bajo DPMI)
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 40
DarkX.ASM



   2224						 ASSUME	 DS:txdata
   2225	    0B2E  66| A1 0325r			 mov	 eax,psp_offset
   2226	    0B32  A3 05A6r			 mov	 word ptr psp_desc+2,ax
   2227	    0B35  66| C1 E8 10			 shr	 eax,16
   2228	    0B39  A2 05A8r			 mov	 byte ptr psp_desc+4,al
   2229	    0B3C  88 26	05ABr			 mov	 byte ptr psp_desc+7,ah
   2230
   2231	    0B40				 no_gen_idt:
   2232						 ; preparamos la tabla de redireccionamiento de	interrupciones
   2233	    0B40  BF 26F7r			 mov	 di,offset interrup_redir
   2234	    0B43  32 C9				 xor	 cl,cl
   2235	    0B45  66| B8 E900B050		 mov	 eax,0E900B050h		 ; PUSH	EAX , MOV AL,00h , JMP
   2236	    0B4B  66| BB FFFFE27B		 mov	 ebx,offset real_int-offset interrup_redir-8 ; desplazamiento salto
   2237	    0B51				 gen_ints:
   2238	    0B51  66| AB				 stosd
   2239	    0B53  66| 93				 xchg	 ebx,eax
   2240	    0B55  66| AB				 stosd
   2241	    0B57  66| 93				 xchg	 ebx,eax
   2242	    0B59  66| 05 00010000			 add	 eax,10000h	 ; inc.	c¢digo interrupci¢n
   2243	    0B5F  66| 83 EB 08				 sub	 ebx,8		 ; dec.	desp. salto
   2244	    0B63  FE C9				 dec	 cl
   2245	    0B65  75 EA				 jnz	 short gen_ints
   2246						 ; arreglamos las irq's
   2247	    0B67  B8 E0BE			 mov	 ax,offset real_irq-(offset interrup_redir+8*50h)-8
   2248	    0B6A  BF 297Br			 mov	 di,offset interrup_redir+8*50h+4
   2249	    0B6D  B9 0008			 mov	 cx,8	 ; irqs. bajas
   2250	    0B70				 fix_irqs:
   2251	    0B70  AB					 stosw
   2252	    0B71  66| 83 C7 06				 add	 edi,2+4
   2253	    0B75  2D 0008				 sub	 ax,8
   2254	    0B78  E2 F6				 loop	 fix_irqs
   2255						 ; arreglamos las excepciones
   2256	    0B7A  B8 E3ED			 mov	 ax,offset exceptions-offset interrup_redir-8
   2257	    0B7D  BF 26FBr			 mov	 di,offset interrup_redir+4
   2258	    0B80  AB				 stosw					 ; exc.0
   2259	    0B81  2D 0008			 sub	 ax,8
   2260	    0B84  26: 89 45 06			 mov	 word ptr es:[di-2+8],ax	 ; exc.1
   2261	    0B88  2D 0010			 sub	 ax,8*2
   2262	    0B8B  83 C7	16			 add	 di,3*8-2			 ; exc.3
   2263	    0B8E  B1 0C				 mov	 cl,14-3+1			 ; hasta la 0Eh
   2264	    0B90				 repara_excs:
   2265	    0B90  AB					 stosw
   2266	    0B91  2D 0008				 sub	 ax,8
   2267	    0B94  83 C7	06				 add	 di,8-2
   2268	    0B97  FE C9				 dec	 cl
   2269	    0B99  75 F5				 jnz	 repara_excs
   2270
   2271						 ASSUME	 DS:txdata
   2272						 ; ARREGLAMOS LA GDT
   2273						 ; ponemos la base del descriptor de datos de 16 bits (	txdata )
   2274	    0B9B  66| B8 00000000s		 mov	 eax,txdata
   2275	    0BA1  66| C1 E0 04			 shl	 eax,4
   2276	    0BA5  A3 0586r			 mov	 word ptr d16_desc+2,ax
   2277	    0BA8  66| C1 E8 10			 shr	 eax,16
   2278	    0BAC  A2 0588r			 mov	 byte ptr d16_desc+4,al
   2279
   2280						 ; base	del de c¢digo de 32 bits
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 41
DarkX.ASM



   2281	    0BAF  66| B8 00000000s		 mov	 eax,txcode32
   2282	    0BB5  66| C1 E0 04			 shl	 eax,4
   2283	    0BB9  A3 056Er			 mov	 word ptr code_descriptor+2,ax
   2284	    0BBC  66| C1 E8 10			 shr	 eax,16
   2285	    0BC0  A2 0570r			 mov	 byte ptr code_descriptor+4,al
   2286
   2287						 ; base	del de c¢digo de 16 bits
   2288	    0BC3  66| B8 00000000s		 mov	 eax,txcode
   2289	    0BC9  66| C1 E0 04			 shl	 eax,4
   2290	    0BCD  A3 057Er			 mov	 word ptr c16_desc+2,ax
   2291	    0BD0  66| C1 E8 10			 shr	 eax,16
   2292	    0BD4  A2 0580r			 mov	 byte ptr c16_desc+4,al
   2293
   2294						 ; direcci¢n de	entrada	inicial	en PM
   2295	    0BD7  66| C7 06 0532r     +		 mov	 prot_code_address,offset c32_init
   2296		  00001A42r
   2297
   2298						 ; direcciones de 32 bits de la	IDT y la GDT
   2299	    0BE0  66| B8 00000000s		 mov	 eax,txdata
   2300	    0BE6  66| C1 E0 04			 shl	 eax,4
   2301	    0BEA  66| 05 00000564r		 add	 eax,offset gdt		   ; direcci¢n GDT (32 bits)
   2302	    0BF0  66| A3 053Er			 mov	 gdt_base,eax
   2303
   2304	    0BF4  66| B8 00000000s		 mov	 eax,txcode32
   2305	    0BFA  66| C1 E0 04			 shl	 eax,4
   2306						 ASSUME	 DS:txcode32
   2307	    0BFE  66| 05 00001EF7r		 add	 eax,offset idt
   2308						 ASSUME	 DS:txdata
   2309	    0C04  66| A3 0544r			 mov	 idt_base,eax		   ; base de IDT
   2310
   2311						 ; habilitamos el punto	de entrada en RM a la rutina de	interrupci¢n real
   2312						 ASSUME	 DS:txcode
   2313	    0C08  2E: C7 06 0019r     +		 mov	 word ptr cs:saltito+1,offset rm_int
   2314		  0454r
   2315	    0C0F  2E: C7 06 001Br     +		 mov	 word ptr cs:saltito+3,txcode
   2316		  0000s
   2317						 ASSUME	 DS:txdata
   2318
   2319	    0C16  C3				 ret
   2320
   2321	    0C17			 init_data	 endp
   2322					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2323					 ; Rutina de activaci¢n	de la l¡nea A20	por hard
   2324					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2325	    0C17			 enable_A20	 proc		 ; Thanx go to Tran ;D
   2326	    0C17  33 C0				 xor	 ax,ax
   2327	    0C19  8E E0				 mov	 fs,ax
   2328	    0C1B  48				 dec	 ax
   2329	    0C1C  8E E8				 mov	 gs,ax
   2330	    0C1E  E8 003E			 call	 test_A20
   2331	    0C21  74 28				 jz	 A20_enabled
   2332	    0C23  E4 92				 in	 al,92h			      ;	para PS/2
   2333	    0C25  0C 02				 or	 al,2
   2334	    0C27  EB 00				 jmp	 $+2
   2335	    0C29  EB 00				 jmp	 $+2
   2336	    0C2B  EB 00				 jmp	 $+2
   2337	    0C2D  E6 92				 out	 92h,al
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 42
DarkX.ASM



   2338	    0C2F  E8 002D			 call	 test_A20
   2339	    0C32  74 17				 jz	 A20_enabled
   2340	    0C34  E8 0015			 call	 A20_check_state	      ;	para AT
   2341	    0C37  75 47				 jnz	 wait_for_A20
   2342	    0C39  B0 D1				 mov	 al,0d1h
   2343	    0C3B  E6 64				 out	 64h,al
   2344	    0C3D  E8 000C			 call	 A20_check_state
   2345	    0C40  75 3E				 jnz	 wait_for_A20
   2346	    0C42  B0 DF				 mov	 al,0dfh
   2347	    0C44  E6 60				 out	 60h,al
   2348	    0C46  E8 0003			 call	 A20_check_state
   2349	    0C49  EB 35				 jmp	 wait_for_A20
   2350	    0C4B				 A20_enabled:
   2351	    0C4B  C3				 ret
   2352	    0C4C			 enable_A20	 endp
   2353					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2354	    0C4C			 A20_check_state proc
   2355	    0C4C  66| B9 00020000		 mov	 ecx,20000h
   2356	    0C52				 wait_that_state:
   2357	    0C52  EB 00				 jmp	 $+2
   2358	    0C54  EB 00				 jmp	 $+2
   2359	    0C56  EB 00				 jmp	 $+2
   2360	    0C58  E4 64				 in	 al,64h
   2361	    0C5A  A8 02				 test	 al,2
   2362	    0C5C  E0 F4				 loopnz	 wait_that_state
   2363	    0C5E  C3				 ret
   2364	    0C5F			 A20_check_state endp
   2365					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2366	    0C5F			 test_A20	 proc
   2367	    0C5F  64: A0 0000			 mov	 al,fs:[0]
   2368	    0C63  8A E0				 mov	 ah,al
   2369	    0C65  F6 D0				 not	 al
   2370	    0C67  65: FF 36 0010		 push	 word ptr gs:[10h]
   2371	    0C6C  65: A2 0010			 mov	 gs:[10h],al
   2372	    0C70  64: 3A 26 0000		 cmp	 ah,fs:[0]
   2373	    0C75  64: 88 26 0000		 mov	 fs:[0],ah
   2374	    0C7A  65: 8F 06 0010		 pop	 word ptr gs:[10h]
   2375	    0C7F  C3				 ret
   2376	    0C80			 test_A20	 endp
   2377					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2378	    0C80			 wait_for_A20	 proc
   2379	    0C80  B0 36				 mov	 al,36h
   2380	    0C82  E6 43				 out	 43h,al
   2381	    0C84  32 C0				 xor	 al,al
   2382	    0C86  E6 40				 out	 40h,al
   2383	    0C88  E6 40				 out	 40h,al
   2384	    0C8A  B9 0800			 mov	 cx,800h
   2385	    0C8D			 A20_bucle1:
   2386	    0C8D  E8 FFCF			 call	 test_A20
   2387	    0C90  74 B9				 je	 A20_enabled
   2388	    0C92  E4 40				 in	 al,40h
   2389	    0C94  E4 40				 in	 al,40h
   2390	    0C96  8A E0				 mov	 ah,al
   2391	    0C98			 A20_bucle2:
   2392	    0C98  E4 40				 in	 al,40h
   2393	    0C9A  E4 40				 in	 al,40h
   2394	    0C9C  3A C4				 cmp	 al,ah
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 43
DarkX.ASM



   2395	    0C9E  74 F8				 je	 A20_bucle2
   2396	    0CA0  E2 EB				 loop	 A20_bucle1
   2397	    0CA2  BA 0165r			 mov	 dx,offset A20_error_msg
   2398	    0CA5  E9 00F1			 jmp	 error_handle1
   2399	    0CA8			 wait_for_A20	 endp
   2400					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2401					 ; Procedimiento de identificaci¢n de la CPU
   2402					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2403	    0CA8			 cpuid	 proc
   2404					 ; OUTPUT -> CF	set if no 386 or better	detected
   2405					 ;	     CF	clear if 386 or	better detected
   2406					 ;		 if CPUID supported
   2407					 ;			 AX = code returned by CPUID if	supported
   2408					 ;			      (	AH = 5 if Pentium , ...	)
   2409					 ;		 if CPUID not supported
   2410					 ;			 AH = cpu family
   2411					 ;				 03h = 386
   2412					 ;				 04h = 486
   2413					 ;			 AL = 0
   2414	    0CA8  66| 9C			 pushfd
   2415	    0CAA  FA				 cli	 ; no queremos ninguna irq por si acaso
   2416						 ; comprobamos si tenemos un 386 como m¡nimo
   2417	    0CAB  32 E4				 xor	 ah,ah
   2418	    0CAD  50				 push	 ax
   2419	    0CAE  9D				 popf
   2420	    0CAF  9C				 pushf
   2421	    0CB0  58				 pop	 ax
   2422	    0CB1  80 E4	F0			 and	 ah,0f0h
   2423	    0CB4  80 FC	F0			 cmp	 ah,0f0h
   2424	    0CB7  74 7A	90 90			 jz	 no_386
   2425	    0CBB  B4 F0				 mov	 ah,0f0h
   2426	    0CBD  50				 push	 ax
   2427	    0CBE  9D				 popf
   2428	    0CBF  9C				 pushf
   2429	    0CC0  58				 pop	 ax
   2430	    0CC1  80 E4	F0			 and	 ah,0f0h
   2431	    0CC4  74 6D				 jz	 no_386
   2432	    0CC6  B8 0300			 mov	 ax,300h	 ; 386 por el momento
   2433						 ; comprobamos tenemos 486
   2434	    0CC9  66| 8B CC			 mov	 ecx,esp
   2435	    0CCC  66| 83 E4 FC			 and	 esp,0FFFFFFFCh	 ; as¡ evitamos	un AC fault en el 486
   2436	    0CD0  66| 9C			 pushfd
   2437	    0CD2  66| 5B			 pop	 ebx
   2438	    0CD4  66| 8B D3			 mov	 edx,ebx
   2439	    0CD7  66| 81 E2 00040000		 and	 edx,40000h
   2440	    0CDE  66| 81 F3 00040000		 xor	 ebx,40000h	 ; cambiamos el	bit de AC
   2441	    0CE5  66| 53			 push	 ebx
   2442	    0CE7  66| 9D			 popfd
   2443	    0CE9  66| 9C			 pushfd
   2444	    0CEB  66| 5B			 pop	 ebx
   2445	    0CED  66| 81 E3 00040000		 and	 ebx,40000h
   2446	    0CF4  66| 8B E1			 mov	 esp,ecx
   2447	    0CF7  66| 3B DA			 cmp	 ebx,edx
   2448	    0CFA  74 33				 je	 id_done
   2449	    0CFC  FE C4				 inc	 ah		 ; de momento, tenemos un 486
   2450	    0CFE  66| 9C			 pushfd
   2451	    0D00  66| 5B			 pop	 ebx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 44
DarkX.ASM



   2452	    0D02  66| 8B D3			 mov	 edx,ebx
   2453	    0D05  66| 81 F3 00200000		 xor	 ebx,200000h
   2454	    0D0C  66| 53			 push	 ebx
   2455	    0D0E  66| 9D			 popfd
   2456	    0D10  66| 9C			 pushfd
   2457	    0D12  66| 5B			 pop	 ebx
   2458	    0D14  66| 81 E3 00200000		 and	 ebx,200000h
   2459	    0D1B  66| 81 E2 00200000		 and	 edx,200000h
   2460	    0D22  66| 3B DA			 cmp	 ebx,edx
   2461	    0D25  74 08				 je	 id_done
   2462
   2463						 ; tiene CPUID (puede ser 486)
   2464	    0D27  66| B8 00000001		 mov	 eax,1
   2465	    0D2D  0F A2				 db	 0fh,0a2h
   2466	    0D2F				 id_done:
   2467	    0D2F  66| 9D			 popfd
   2468	    0D31  F8				 clc
   2469	    0D32  C3				 ret
   2470
   2471	    0D33			 no_386:
   2472	    0D33  66| 9D			 popfd
   2473	    0D35  F9				 stc
   2474	    0D36  C3				 ret
   2475
   2476	    0D37			 cpuid	 endp
   2477					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2478					 ; Procedimiento de identificaci¢n de la FPU
   2479					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2480	    0D37			 fpuid	 proc	 ; inspired on CPUID32.ASM by ??? ;)
   2481					 ; OUTPUT -> AL	= FPU type ( 00h = no present ;	02h = 287 ; 03h	= 387 ;	04h = 487+ )
   2482	    0D37  32 C0				 xor	 al,al
   2483	    0D39  DB E3				 fninit				 ; reseteamos el estado	de la FPU
   2484	    0D3B  2E: C7 06 0D91r 5A5A		 mov	 cs:fpu_status,5A5Ah
   2485	    0D42  2E: DD 3E 0D91r		 fnstsw	 cs:fpu_status		 ; comprobamos el estado
   2486	    0D47  2E: 80 3E 0D91r 00		 cmp	 byte ptr cs:fpu_status,0
   2487	    0D4D  75 41				 jne	 fpu_found		 ; any FPU on system :(
   2488	    0D4F  2E: D9 3E 0D91r		 fnstcw	 cs:fpu_status		 ; miramos el control word
   2489	    0D54  2E: 8B 1E 0D91r		 mov	 bx,cs:fpu_status
   2490	    0D59  81 E3	103F			 and	 bx,103fh
   2491	    0D5D  80 FB	3F			 cmp	 bl,3Fh
   2492	    0D60  75 2E				 jne	 fpu_found		 ; no FPU <:'(
   2493						 ; Si llegamos aqu¡, hay FPU
   2494						 ; 486+	-> 487 compatible
   2495						 ; 386	-> 287 o 387: lo averiguamos
   2496	    0D62  B8 0000s			 mov	 ax,txdata
   2497	    0D65  8E D8				 mov	 ds,ax
   2498	    0D67  A1 033Fr			 mov	 ax,cpu_info
   2499	    0D6A  80 FC	04			 cmp	 ah,4
   2500	    0D6D  72 04				 jb	 no_487
   2501	    0D6F  B0 04					 mov	 al,4
   2502	    0D71  EB 1D					 jmp	 fpu_found
   2503	    0D73				 no_487:
   2504						 ; para	saber si es 287	o 387 miramos 'infinity'
   2505	    0D73  D9 E8				 fld1
   2506	    0D75  D9 EE				 fldz
   2507	    0D77  DE F9				 fdiv			 ; tenemos +infinito
   2508	    0D79  D9 C0				 fld	 st
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 45
DarkX.ASM



   2509	    0D7B  D9 E0				 fchs			 ; formamos -infinito
   2510	    0D7D  DE D9				 fcompp			 ; si nos dice que +inf.=-inf.,	es un 287
   2511	    0D7F  9B 2E: DD 3E 0D91r		 fstsw	 cs:fpu_status	 ; necesitamos los flags
   2512	    0D85  2E: A1 0D91r			 mov	 ax,cs:fpu_status
   2513	    0D89  B0 02				 mov	 al,2
   2514	    0D8B  9E				 sahf
   2515	    0D8C  74 02				 jz	 fpu_found	 ; si son iguales, 287
   2516	    0D8E  FE C0				 inc	 al		 ; si no, 387
   2517	    0D90				 fpu_found:
   2518	    0D90  C3				 ret
   2519	    0D91  ????			 fpu_status	 dw ?
   2520	    0D93			 fpuid	 endp
   2521					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2522					 ; RUTINAS GENERALES DE	GESTION	PARA TODOS LOS SISTEMAS	(MODO REAL)
   2523					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2524
   2525	    0D93			 error_handle:
   2526	    0D93  E8 0009			 call	 printf
   2527	    0D96  E9 FC6C			 jmp	 fin
   2528
   2529	    0D99			 error_handle1:
   2530	    0D99  E8 0003			 call	 printf
   2531	    0D9C  E9 FC8D			 jmp	 exit_redirless
   2532
   2533					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2534
   2535	    0D9F			 printf	 proc
   2536
   2537	    0D9F  B8 0000s			 mov	 ax,txdata
   2538	    0DA2  8E D8				 mov	 ds,ax
   2539	    0DA4  B4 09				 mov	 ah,9
   2540	    0DA6  CD 21				 int	 21h
   2541	    0DA8  C3				 ret
   2542
   2543	    0DA9			 printf	 endp
   2544
   2545					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2546
   2547	    0DA9			 init_mem	 proc
   2548
   2549						 ; cambiamos el	tama¤o del bloque reservado para nuestro programa
   2550	    0DA9  66| BB 00000000s		 mov	 ebx,disk
   2551	    0DAF  66| 81 EB 00000000s		 sub	 ebx,txdata
   2552	    0DB6  66| C1 E3 04			 shl	 ebx,4
   2553	    0DBA  66| 81 C3 00008000		 add	 ebx,size disk_buffer
   2554	    0DC1  66| C1 EB 04			 shr	 ebx,4
   2555	    0DC5  83 C3	11			 add	 bx,11h	 ; redondeamos sumando un p rrafo + 16
   2556						 ASSUME	 DS:txdata
   2557	    0DC8  A1 04D0r			 mov	 ax,psp_seg
   2558	    0DCB  8E C0				 mov	 es,ax
   2559	    0DCD  B4 4A				 mov	 ah,4Ah
   2560	    0DCF  CD 21				 int	 21h
   2561	    0DD1  C3				 ret
   2562
   2563	    0DD2			 init_mem	 endp
   2564
   2565					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 46
DarkX.ASM



   2566
   2567	    0DD2			 get_dos_mem	 proc
   2568
   2569	    0DD2  B4 48				 mov	 ah,48h
   2570	    0DD4  CD 21				 int	 21h
   2571	    0DD6  BA 04AAr			 mov	 dx,offset not_enough_mem
   2572					 ;	  pop	  ecx	  ; si salimos,	la pila	estar  limpia
   2573	    0DD9  72 B8				 jc	 error_handle
   2574					 ;	  push	  ecx
   2575	    0DDB  C3				 ret
   2576
   2577	    0DDC			 get_dos_mem	 endp
   2578
   2579					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2580
   2581	    0DDC			 irq_redir	 proc
   2582					 ; INPUT -> AH = base de IRQ's 0-7
   2583
   2584	    0DDC  FA				 cli
   2585
   2586						 ; enmascaramos	todas las irq's
   2587	    0DDD  B0 FF				 mov	 al,0FFh
   2588	    0DDF  E6 21				 out	 21h,al
   2589	    0DE1  EB 00				 jmp	 short $+2	 ; delay
   2590
   2591	    0DE3  B0 11				 mov	 al,10001b	 ; level, master, ICW4 on
   2592	    0DE5  E6 20				 out	 20h,al		 ; ICW1
   2593	    0DE7  EB 00				 jmp	 short $+2
   2594
   2595	    0DE9  8A C4				 mov	 al,ah		 ; INT AH = nueva base de irq's
   2596	    0DEB  E6 21				 out	 21h,al		 ; ICW2
   2597	    0DED  EB 00				 jmp	 short $+2
   2598
   2599	    0DEF  B0 04				 mov	 al,4		 ; pq estamos en un AT
   2600	    0DF1  E6 21				 out	 21h,al		 ; ICW3
   2601	    0DF3  EB 00				 jmp	 short $+2
   2602
   2603	    0DF5  B0 01				 mov	 al,1		 ; modo	8086, EOI normal
   2604	    0DF7  E6 21				 out	 21h,al		 ; ICW4
   2605	    0DF9  EB 00				 jmp	 short $+2
   2606
   2607	    0DFB  32 C0				 xor	 al,al		 ; desenmascaramos las irq's
   2608	    0DFD  E6 21				 out	 21h,al
   2609
   2610	    0DFF  FB				 sti
   2611
   2612	    0E00  C3				 ret
   2613
   2614	    0E01			 irq_redir	 endp
   2615
   2616					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2617	    0E01			 TXCODE	 ENDS
   2618
   2619					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2620					 ; SEGMENTO DE CODIGO DE 32 BITS ( 'ENTRY POINT' AL PROGRAMA )
   2621					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2622
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 47
DarkX.ASM



   2623	00000000			 TXCODE32  SEGMENT PARA	USE32 'CODE32'
   2624					 ASSUME	   CS:txcode32,SS:txpila,DS:txdata
   2625
   2626					 ; ponemos los selectores en el	segmento de c¢digo para	referenciar con	CS
   2627	00000000  0008 0000		 C32_SEL		 dw 1 SHL 3,0
   2628	00000004  0010 0000		 D32_SEL		 dw 2 SHL 3,0
   2629	00000008  0018 0000		 C16_SEL		 dw 3 SHL 3,0
   2630	0000000C  0020 0000		 D16_SEL		 dw 4 SHL 3,0
   2631	00000010  0028 0000		 CODE_SEL		 dw 5 SHL 3,0
   2632	00000014  0030 0000		 DATA_SEL		 dw 6 SHL 3,0
   2633	00000018  0038 0000		 ENVRN_SEL		 dw 7 SHL 3,0
   2634
   2635					 INCLUDE		 dpmisup.inc
1  2636					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2637					 ; Standard DPMI 0.9 INT 31h support routines
1  2638					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2639	0000001C			 tx_int31h:
1  2640						 ; TX32	OEM functions
1  2641	0000001C  66| 3D 3200			 cmp	 ax,3200h	 ; get system information
1  2642	00000020  0F 84	000008A8		 jz	 get_sys_info
1  2643	00000026  66| 3D 3201			 cmp	 ax,3201h	 ; get program information
1  2644	0000002A  0F 84	000008E3		 jz	 get_program_info
1  2645
1  2646						 ; for DOS32 compatibility
1  2647	00000030  66| 3D EE00			 cmp	 ax,0EE00h
1  2648	00000034  0F 84	00000930		 jz	 dos32_info	 ; get DOS32 version
1  2649	0000003A  66| 3D EE02			 cmp	 ax,0EE02h
1  2650	0000003E  0F 84	000008FF		 jz	 dos32_sys_info	 ; get DOS32 address information
1  2651
1  2652	00000044  1E				 push	 ds
1  2653	00000045  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2654						 ASSUME	 DS:txdata
1  2655	0000004C  67| F6 06 0341r 02		 test	 system_type,2
1  2656	00000052  1F				 pop	 ds
1  2657	00000053  0F 85	000000DD		 jnz	 dpmi_handles_standard_funcs
1  2658
1  2659	00000059  66| 3D 0500			 cmp	 ax,500h
1  2660	0000005D  0F 84	00000358		 jz	 ext_mem_info	 ; get free memory info
1  2661	00000063  66| 3D 0501			 cmp	 ax,501h
1  2662	00000067  0F 84	00000397		 jz	 ext_mem_alloc	 ; allocate memory block
1  2663	0000006D  66| 3D 0502			 cmp	 ax,502h
1  2664	00000071  0F 84	000003E0		 jz	 ext_mem_free	 ; free	memory block
1  2665	00000077  66| 3D 0503			 cmp	 ax,503h
1  2666	0000007B  0F 84	0000040E		 jz	 ext_mem_resize	 ; resize memory block
1  2667
1  2668	00000081  66| 3D 0100			 cmp	 ax,100h
1  2669	00000085  0F 84	00000230		 jz	 dos_mem_alloc	 ; allocate DOS	memory
1  2670	0000008B  66| 3D 0101			 cmp	 ax,101h
1  2671	0000008F  0F 84	0000028A		 jz	 dos_mem_free	 ; free	DOS memory block
1  2672	00000095  66| 3D 0102			 cmp	 ax,102h
1  2673	00000099  0F 84	000002BF		 jz	 dos_mem_resize	 ; resize DOS memory block
1  2674
1  2675	0000009F  66| 3D 0200			 cmp	 ax,200h	 ; get real mode interrupt vector
1  2676	000000A3  0F 84	000007DF		 jz	 get_rm_int_vec
1  2677	000000A9  66| 3D 0201			 cmp	 ax,201h
1  2678	000000AD  0F 84	000007F9		 jz	 set_rm_int_vec	 ; set real mode interrupt vector
1  2679
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 48
DarkX.ASM



1  2680	000000B3  66| 3D 0300			 cmp	 ax,300h
1  2681	000000B7  0F 84	00000087		 jz	 make_rm_int	 ; simulate RM interrupt
1  2682	000000BD  66| 3D 0301			 cmp	 ax,301h
1  2683	000000C1  0F 84	0000007D		 jz	 make_rm_int	 ; RM call with	FAR RET	frame
1  2684	000000C7  66| 3D 0302			 cmp	 ax,302h
1  2685	000000CB  74 77				 jz	 make_rm_int	 ; RM call with	IRET frame
1  2686
1  2687	000000CD  66| 3D 0303			 cmp	 ax,303h
1  2688	000000D1  0F 84	000006FB		 jz	 callback_alloc	 ; allocate real mode call-back	address
1  2689	000000D7  66| 3D 0304			 cmp	 ax,304h
1  2690	000000DB  0F 84	00000766		 jz	 callback_free	 ; free	real mode call-back address
1  2691
1  2692	000000E1  66| 3D 0204			 cmp	 ax,204h
1  2693	000000E5  0F 84	0000054A		 jz	 get_int_vector
1  2694	000000EB  66| 3D 0205			 cmp	 ax,205h
1  2695	000000EF  0F 84	00000586		 jz	 set_int_vector
1  2696
1  2697	000000F5  66| 0B C0			 or	 ax,ax
1  2698	000000F8  0F 84	000003F5		 jz	 alloc_desc	 ; allocate LDT	descriptors
1  2699	000000FE  66| 3D 0001			 cmp	 ax,1
1  2700	00000102  0F 84	00000468		 jz	 free_desc	 ; free	LDT descriptor
1  2701	00000108  66| 3D 0003			 cmp	 ax,3
1  2702	0000010C  0F 84	0000048C		 jz	 next_desc	 ; get next selector increment value
1  2703	00000112  66| 3D 000C			 cmp	 ax,0Ch
1  2704	00000116  0F 84	0000048C		 jz	 set_desc	 ; set descriptor
1  2705	0000011C  66| 3D 0006			 cmp	 ax,6
1  2706	00000120  0F 84	000004C7		 jz	 get_seg_base	 ; get segment base
1  2707
1  2708	00000126  66| 3D 0800			 cmp	 ax,0800h
1  2709	0000012A  0F 84	00000593		 jz	 map_memory
1  2710
1  2711						 ; si no es una	funci¢n	soportada, salimos con CF = 1
1  2712	00000130  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2713	00000135  CF				 iretd
1  2714
1  2715	00000136				 dpmi_handles_standard_funcs:
1  2716	00000136  9C				 pushfd
1  2717	00000137  2E: FF 1D 0000201Dr		 call	 fword ptr cs:[idt+31h*6]
1  2718	0000013E  9C				 pushfd
1  2719	0000013F  8F 44	24 08			 pop	 dword ptr ss:[esp+4*2]	 ; ponemos los flags devueltos
1  2720	00000143  CF				 iretd
1  2721
1  2722					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2723					 ; Real	Mode Services for Interrupt and	Far Call execution
1  2724					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2725	00000144			 make_rm_int:
1  2726	00000144  60				 pushad
1  2727	00000145  06 57				 push	 es edi
1  2728	00000147  66| 8C DA			 mov	 dx,ds
1  2729	0000014A  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2730	00000151  66| 67| 8C 06	0378r		 mov	 pm_es,es
1  2731	00000157  66| 67| 8C 26	037Ar		 mov	 pm_fs,fs
1  2732	0000015D  66| 67| 8C 2E	037Cr		 mov	 pm_gs,gs
1  2733	00000163  66| 67| 89 16	0376r		 mov	 pm_ds,dx
1  2734						 ; copiamos en pila el n£mero de WORDS indicados por CX
1  2735	00000169  66| 0B C9			 or	 cx,cx
1  2736	0000016C  74 4E				 jz	 no_stack_parameters
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 49
DarkX.ASM



1  2737	0000016E  8B F4				 mov	 esi,esp
1  2738	00000170  83 C6	34			 add	 esi,13*4	 ; justo antes del CS:EIP, EFLAGS, ...
1  2739	00000173  0F B7	C9			 movzx	 ecx,cx
1  2740	00000176  16				 push	 ss
1  2741	00000177  1F				 pop	 ds
1  2742						 ; ajustamos el	puntero	a la pila real
1  2743	00000178  26: 8B 57 2E			 mov	 edx,dword ptr es:[edi+2Eh]
1  2744	0000017C  0B D2				 or	 edx,edx
1  2745	0000017E  75 0B				 jnz	 no_default_stack
1  2746	00000180  66| BA 0000s				 mov	 dx,txpila_real
1  2747	00000184  C1 E2	10				 shl	 edx,16
1  2748	00000187  66| BA 4000				 mov	 dx,size txpr
1  2749	0000018B				 no_default_stack:
1  2750	0000018B  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  2751						 ; guardamos el	n£mero de BYTES	en pila
1  2752	00000192  BD 00000000s			 mov	 ebp,txcode
1  2753	00000197  C1 E5	04			 shl	 ebp,4
1  2754						 ASSUME	 ES:txcode
1  2755	0000019A  D1 E1				 shl	 ecx,1
1  2756	0000019C  66| 26: 89 8D	      +		 mov	 word ptr es:[ebp+bytes_in_stack],cx
   2757		  000004B8r
1  2758						 ; calculamos el offset	lineal de la pila real
1  2759	000001A4  33 FF				 xor	 edi,edi
1  2760	000001A6  66| 8B FA			 mov	 di,dx
1  2761	000001A9  81 E2	FFFF0000		 and	 edx,0FFFF0000h
1  2762	000001AF  C1 EA	0C			 shr	 edx,16-4
1  2763	000001B2  03 FA				 add	 edi,edx
1  2764	000001B4  2B F9				 sub	 edi,ecx
1  2765						 ; lo copiamos todo
1  2766	000001B6  D1 E9				 shr	 ecx,1
1  2767	000001B8  FC				 cld
1  2768	000001B9  F3> 66| A5			 rep	 movsw
1  2769
1  2770	000001BC				 no_stack_parameters:
1  2771						 ; copiamos la estructura del DPMI
1  2772						 ; (as¡	no tiene pq estar en el	primer Mb)
1  2773	000001BC  5E				 pop	 esi
1  2774	000001BD  1F				 pop	 ds
1  2775	000001BE  1E				 push	 ds
1  2776	000001BF  56				 push	 esi
1  2777	000001C0  BF 000003BFr			 mov	 edi,offset dpmi_rm_call_struc
1  2778	000001C5  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  2779	000001CC  B9 00000019			 mov	 ecx,32h/2
1  2780	000001D1  FC				 cld
1  2781	000001D2  F3> 66| A5			 rep	 movsw
1  2782						 ; corregimos el salto a real
1  2783	000001D5  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2784	000001DC  BF 00000000s			 mov	 edi,txcode
1  2785	000001E1  C1 E7	04			 shl	 edi,4
1  2786						 ASSUME	 DS:txcode
1  2787	000001E4  66| C7 87 00000019r +		 mov	 word ptr ds:[edi+saltito+1],offset dpmi_rm_int
   2788		  039Ar
1  2789						 ; corregimos el salto de vuelta a protegido
1  2790						 ASSUME	 ES:txdata
1  2791	000001ED  26: 67| C7 06	0532r +		 mov	 es:prot_code_address,offset back_from_dpmi_int
   2792		  00000212r
1  2793
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 50
DarkX.ASM



1  2794	000001F7  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2795	000001FE  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  2796	00000205  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  2797						 pushd	 ret_real
2  2798	0000020C  68				 db 68h
2  2799	0000020D  09BEr	0000			 dw offset ret_real,0
1  2800	00000211  CB				 retf
1  2801
1  2802	00000212				 back_from_dpmi_int:
1  2803	00000212  FA				 cli
1  2804						 ; restauramos el salto	a real
1  2805	00000213  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2806	0000021A  BB 00000000s			 mov	 ebx,txcode
1  2807	0000021F  C1 E3	04			 shl	 ebx,4
1  2808	00000222  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset rm_int
   2809		  0454r
1  2810
1  2811						 ; copiamos los	valores	de la pila real
1  2812						 ASSUME	 DS:txdata
1  2813	0000022B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2814	00000232  67| 8B 3E 0520r		 mov	 edi,pm_esp
1  2815	00000237  83 C7	34			 add	 edi,13*4	 ; POP ES,POP EDI,POPAD,POP EIP,POP CS,POPFD
1  2816	0000023A  67| 8E 06 037Er		 mov	 es,pm_ss
1  2817						 ASSUME	 DS:txcode
1  2818	0000023F  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2819	00000246  BE 00000000s			 mov	 esi,txcode
1  2820	0000024B  C1 E6	04			 shl	 esi,4
1  2821	0000024E  33 C9				 xor	 ecx,ecx
1  2822	00000250  66| 8B 8E 000004B8r		 mov	 cx,[esi+bytes_in_stack]
1  2823	00000257  66| 0B C9			 or	 cx,cx
1  2824	0000025A  74 1F				 jz	 no_return_vals
1  2825	0000025C  66| C7 86 000004B8r +		 mov	 [esi+bytes_in_stack],0
   2826		  0000
1  2827	00000265  BE 00000000s			 mov	 esi,txpila_real
1  2828	0000026A  C1 E6	04			 shl	 esi,4
1  2829	0000026D  81 C6	00004000		 add	 esi,size txpr
1  2830	00000273  2B F1				 sub	 esi,ecx
1  2831	00000275  D1 E9				 shr	 ecx,1
1  2832	00000277  FC				 cld
1  2833	00000278  F3> 66| A5			 rep	 movsw
1  2834						 ASSUME	 DS:txdata
1  2835
1  2836	0000027B				 no_return_vals:
1  2837						 ; volvemos a poner bien la direcci¢n de retorno a protegido
1  2838	0000027B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2839						 ASSUME	 DS:txdata
1  2840	00000282  67| C7 06 0532r     +		 mov	 prot_code_address,offset pm_ret_point
   2841		  000009EAr
1  2842						 ; copiamos todos los valores obtenidos	en la estructura
1  2843	0000028B  67| 8E 16 037Er		 mov	 ss,pm_ss
1  2844	00000290  67| 8B 26 0520r		 mov	 esp,pm_esp
1  2845	00000295  5F 07				 pop	 edi es
1  2846	00000297  BE 000004D2r			 mov	 esi,offset rm_regs_struc
1  2847	0000029C  B9 00000019			 mov	 ecx,32h/2
1  2848	000002A1  FC				 cld
1  2849	000002A2  F3> 66| A5			 rep	 movsw
1  2850						 ; restauramos los registros
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 51
DarkX.ASM



1  2851	000002A5  61				 popad
1  2852						 ; restauramos los selectores de protegido
1  2853	000002A6  67| 8E 06 0378r		 mov	 es,pm_es
1  2854	000002AB  67| 8E 26 037Ar		 mov	 fs,pm_fs
1  2855	000002B0  67| 8E 2E 037Cr		 mov	 gs,pm_gs
1  2856	000002B5  67| 8E 1E 0376r		 mov	 ds,pm_ds
1  2857	000002BA  CF				 iretd
1  2858
1  2859					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2860					 ; DOS Memory Management Services
1  2861					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2862					 ASSUME	 DS:txcode32
1  2863	000002BB			 dos_mem_alloc:
1  2864	000002BB  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1	 ; CF =	1 por si hay error
1  2865	000002C0  1E 53	51			 push	 ds ebx	ecx
1  2866	000002C3  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2867	000002CA  B8 00000000s			 mov	 eax,txcode32
1  2868	000002CF  C1 E0	04			 shl	 eax,4
1  2869	000002D2  80 B8	00002EFFr 00		 cmp	 byte ptr [eax+dos_pointers],0
1  2870	000002D9  74 3A				 jz	 no_dos_heap_error
1  2871	000002DB  05 00002EF7r			 add	 eax,offset dos_heap_info
1  2872	000002E0  0F B7	CB			 movzx	 ecx,bx
1  2873	000002E3  C1 E1	04			 shl	 ecx,4
1  2874	000002E6  50				 push	 eax
1  2875	000002E7  E8 00000F92			 call	 malloc
1  2876	000002EC  58				 pop	 eax
1  2877	000002ED  0B DB				 or	 ebx,ebx
1  2878	000002EF  74 10				 jz	 dos_alloc_error
1  2879	000002F1  8B C3				 mov	 eax,ebx
1  2880	000002F3  C1 E8	04			 shr	 eax,4	 ; estar  alineada a p rrafo pq	lo est 	toda la	heap
1  2881	000002F6  8B D0				 mov	 edx,eax ; selector = segmento para handling posterior
1  2882	000002F8  59 5B	1F			 pop	 ecx ebx ds
1  2883	000002FB  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh ; CF = 0 pq	no hay error
1  2884	00000300  CF				 iretd
1  2885	00000301			 dos_alloc_error:
1  2886						 ; buscamos el bloque m s grande memoria para devolverlo en BX
1  2887	00000301  E8 00001166			 call	 getmeminfo
1  2888	00000306  8B D8				 mov	 ebx,eax
1  2889	00000308  C1 EB	04			 shr	 ebx,4
1  2890	0000030B  66| B8 0008			 mov	 ax,8			 ; error code =	not enough memory
1  2891	0000030F  59				 pop	 ecx
1  2892	00000310  83 C4	04			 add	 esp,4
1  2893	00000313  1F				 pop	 ds
1  2894					 ;	  or	  byte ptr ss:[esp+4*2],1 ; CF = 1 por si error
1  2895	00000314  CF				 iretd
1  2896	00000315			 no_dos_heap_error:
1  2897	00000315  59 5B	1F			 pop	 ecx ebx ds
1  2898	00000318  66| B8 0008			 mov	 ax,8			 ; error 8 = not enough	memory
1  2899	0000031C  33 DB				 xor	 ebx,ebx		 ; 0 paragraphs	available
1  2900	0000031E  CF				 iretd
1  2901					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2902	0000031F			 dos_mem_free:
1  2903	0000031F  1E 50	53 51			 push	 ds eax	ebx ecx
1  2904	00000323  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2905	0000032A  BB 00000000s			 mov	 ebx,txcode32
1  2906	0000032F  C1 E3	04			 shl	 ebx,4
1  2907	00000332  80 BB	00002EFFr 00		 cmp	 byte ptr [ebx+dos_pointers],0
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 52
DarkX.ASM



1  2908	00000339  74 15				 jz	 no_dos_heap_error1
1  2909	0000033B  0F B7	DA			 movzx	 ebx,dx
1  2910	0000033E  C1 E3	04			 shl	 ebx,4
1  2911	00000341  E8 00000F91			 call	 free
1  2912	00000346  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2913	0000034A  80 64	24 08 FC		 and	 byte ptr ss:[esp+4*2],0FCh
1  2914	0000034F  CF				 iretd
1  2915	00000350			 no_dos_heap_error1:
1  2916	00000350  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2917	00000354  66| B8 0009			 mov	 ax,9			 ; error 9 = invalid block segment
1  2918	00000358  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2919	0000035D  CF				 iretd
1  2920					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2921	0000035E			 dos_mem_resize:
1  2922	0000035E  1E 50	51 52			 push	 ds eax	ecx edx
1  2923	00000362  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2924	00000369  B8 00000000s			 mov	 eax,txcode32
1  2925	0000036E  C1 E0	04			 shl	 eax,4
1  2926	00000371  80 B8	00002EFFr 00		 cmp	 byte ptr [eax+dos_pointers],0
1  2927	00000378  74 33				 jz	 no_dos_heap_error2
1  2928	0000037A  05 00002EF7r			 add	 eax,offset dos_heap_info
1  2929	0000037F  0F B7	CB			 movzx	 ecx,bx
1  2930	00000382  C1 E1	04			 shl	 ecx,4
1  2931	00000385  0F B7	DA			 movzx	 ebx,dx
1  2932	00000388  C1 E3	04			 shl	 ebx,4
1  2933	0000038B  50 56	57			 push	 eax esi edi
1  2934	0000038E  E8 00000FAB			 call	 realloc
1  2935	00000393  5F 5E	58 5A			 pop	 edi esi eax edx
1  2936	00000397  0B DB				 or	 ebx,ebx
1  2937	00000399  0F 84	FFFFFF62		 jz	 dos_alloc_error
1  2938	0000039F  C1 EB	04			 shr	 ebx,4
1  2939	000003A2  8B D3				 mov	 edx,ebx
1  2940	000003A4  59 58	1F			 pop	 ecx eax ds
1  2941	000003A7  80 64	24 08 FC		 and	 byte ptr ss:[esp+4*2],0FCh
1  2942	000003AC  CF				 iretd
1  2943	000003AD			 no_dos_heap_error2:
1  2944	000003AD  5A 59	58 1F			 pop	 edx ecx eax ds
1  2945	000003B1  66| B8 0009			 mov	 ax,9			 ; error 9 = invalid block segment
1  2946	000003B5  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2947	000003BA  CF				 iretd
1  2948
1  2949					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2950					 ; Extended Memory Management Services
1  2951					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2952	000003BB			 ext_mem_info:
1  2953	000003BB  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2954	000003C0  1E 50	53 51 57		 push	 ds eax	ebx ecx	edi
1  2955	000003C5  33 C0				 xor	 eax,eax
1  2956	000003C7  48				 dec	 eax
1  2957	000003C8  B9 0000000C			 mov	 ecx,30h/4
1  2958	000003CD  FC				 cld
1  2959	000003CE  F3> AB			 rep	 stosd
1  2960	000003D0  5F				 pop	 edi
1  2961	000003D1  40				 inc	 eax
1  2962	000003D2  26: 89 07			 mov	 es:[edi],eax	 ; 0 bytes si no hay heap
1  2963	000003D5  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2964	000003DC  B8 00000000s			 mov	 eax,txcode32
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 53
DarkX.ASM



1  2965	000003E1  C1 E0	04			 shl	 eax,4
1  2966	000003E4  80 B8	00003228r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  2967	000003EB  74 12				 jz	 no_ext_heap_error
1  2968	000003ED  05 00003220r			 add	 eax,offset extended_heap_info
1  2969	000003F2  E8 00001075			 call	 getmeminfo
1  2970	000003F7  26: 89 07			 mov	 es:[edi],eax
1  2971	000003FA  80 64	24 18 FC		 and	 byte ptr ss:[esp+4*6],0FCh
1  2972	000003FF				 no_ext_heap_error:
1  2973	000003FF  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2974	00000403  CF				 iretd
1  2975					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2976	00000404			 ext_mem_alloc:
1  2977	00000404  50 53	51 1E			 push	 eax ebx ecx ds
1  2978	00000408  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2979	0000040F  B8 00000000s			 mov	 eax,txcode32
1  2980	00000414  C1 E0	04			 shl	 eax,4
1  2981	00000417  80 B8	00003228r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  2982	0000041E  74 2D				 jz	 alloc_error	 ; salta si no hay heap
1  2983	00000420  05 00003220r			 add	 eax,offset extended_heap_info
1  2984	00000425  C1 E3	10			 shl	 ebx,16
1  2985	00000428  81 E1	0000FFFF		 and	 ecx,0FFFFh
1  2986	0000042E  0B CB				 or	 ecx,ebx
1  2987	00000430  E8 00000E49			 call	 malloc
1  2988	00000435  0B DB				 or	 ebx,ebx
1  2989	00000437  74 14				 jz	 alloc_error
1  2990	00000439  1F				 pop	 ds
1  2991	0000043A  8B CB				 mov	 ecx,ebx
1  2992	0000043C  C1 EB	10			 shr	 ebx,16
1  2993	0000043F  8B F3				 mov	 esi,ebx			 ; handle = linear address
1  2994	00000441  8B F9				 mov	 edi,ecx
1  2995	00000443  83 C4	08			 add	 esp,4*2
1  2996	00000446  58				 pop	 eax
1  2997	00000447  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  2998	0000044C  CF				 iretd
1  2999	0000044D			 alloc_error:
1  3000	0000044D  1F 59	5B 58			 pop	 ds ecx	ebx eax
1  3001	00000451  80 4C	24 08 01		 or	 byte ptr ss:[esp+2*4],1	 ; CF =	1 si por si hay	error
1  3002	00000456  CF				 iretd
1  3003					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3004	00000457			 ext_mem_free:
1  3005	00000457  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3006	0000045C  1E 50	53 51			 push	 ds eax	ebx ecx
1  3007	00000460  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3008	00000467  BB 00000000s			 mov	 ebx,txcode32
1  3009	0000046C  C1 E3	04			 shl	 ebx,4
1  3010	0000046F  80 BB	00003228r 00		 cmp	 byte ptr [ebx+extended_pointers],0
1  3011	00000476  74 12				 jz	 ext_free_error
1  3012	00000478  8B DE				 mov	 ebx,esi
1  3013	0000047A  C1 E3	10			 shl	 ebx,16
1  3014	0000047D  66| 8B DF			 mov	 bx,di
1  3015	00000480  E8 00000E52			 call	 free
1  3016	00000485  80 64	24 18 FE		 and	 byte ptr ss:[esp+4*6],0FEh
1  3017	0000048A				 ext_free_error:
1  3018	0000048A  59 5B	58 1F			 pop	 ecx ebx eax ds
1  3019	0000048E  CF				 iretd
1  3020					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3021	0000048F			 ext_mem_resize:
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 54
DarkX.ASM



1  3022	0000048F  50 52	53 51 56 57 1E		 push	 eax edx ebx ecx esi edi ds
1  3023	00000496  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3024	0000049D  B8 00000000s			 mov	 eax,txcode32
1  3025	000004A2  C1 E0	04			 shl	 eax,4
1  3026	000004A5  80 B8	00003228r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  3027	000004AC  74 38				 jz	 realloc_error
1  3028	000004AE  05 00003220r			 add	 eax,offset extended_heap_info
1  3029	000004B3  81 E1	0000FFFF		 and	 ecx,0FFFFh
1  3030	000004B9  C1 E3	10			 shl	 ebx,16
1  3031	000004BC  0B CB				 or	 ecx,ebx
1  3032	000004BE  8B DE				 mov	 ebx,esi
1  3033	000004C0  C1 E3	10			 shl	 ebx,16
1  3034	000004C3  66| 8B DF			 mov	 bx,di
1  3035	000004C6  E8 00000E73			 call	 realloc
1  3036	000004CB  0B DB				 or	 ebx,ebx
1  3037	000004CD  74 17				 jz	 realloc_error
1  3038	000004CF  1F				 pop	 ds
1  3039	000004D0  8B FB				 mov	 edi,ebx
1  3040	000004D2  8B F3				 mov	 esi,ebx
1  3041	000004D4  C1 EE	10			 shr	 esi,16
1  3042	000004D7  8B DE				 mov	 ebx,esi
1  3043	000004D9  8B CF				 mov	 ecx,edi
1  3044	000004DB  83 C4	10			 add	 esp,4*4
1  3045	000004DE  5A 58				 pop	 edx eax
1  3046	000004E0  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3047	000004E5  CF				 iretd
1  3048	000004E6			 realloc_error:
1  3049	000004E6  1F 5F	5E 59 5B 5A 58		 pop	 ds edi	esi ecx	ebx edx	eax
1  3050	000004ED  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3051	000004F2  CF				 iretd
1  3052
1  3053					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3054					 ; LDT Access Services
1  3055					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3056					 ASSUME	 DS:txdata
1  3057	000004F3			 alloc_desc:
1  3058	000004F3  50 1E	53			 push	 eax ds	ebx
1  3059	000004F6  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3060	000004FD  33 C0				 xor	 eax,eax
1  3061	000004FF  BB 0000000A			 mov	 ebx,FREE_DESCS
1  3062	00000504  0F B7	C9			 movzx	 ecx,cx
1  3063
1  3064	00000507				 search_free_descs:
1  3065	00000507  0B DB					 or	 ebx,ebx
1  3066	00000509  74 5C					 jz	 not_enough_descs
1  3067	0000050B  80 B8	0000061Cr 00			 cmp	 byte ptr [eax+free_descs_handles],0
1  3068	00000512  74 06					 jz	 found_one_slot
1  3069	00000514  40					 inc	 eax
1  3070	00000515  4B				 dec	 ebx
1  3071	00000516  75 EF				 jnz	 search_free_descs
1  3072	00000518  EB 4D				 jmp	 not_enough_descs
1  3073	0000051A				 found_one_slot:
1  3074	0000051A  51 50				 push	 ecx eax
1  3075	0000051C				 find_the_rest:
1  3076	0000051C  80 B8	0000061Cr 00			 cmp	 byte ptr [eax+free_descs_handles],0
1  3077	00000523  75 06					 jnz	 couldnt_find_em
1  3078	00000525  40					 inc	 eax
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 55
DarkX.ASM



1  3079	00000526  4B					 dec	 ebx
1  3080	00000527  E2 F3				 loop	 find_the_rest
1  3081	00000529  EB 06				 jmp	 found_descs
1  3082	0000052B				 couldnt_find_em:
1  3083	0000052B  83 C4	04			 add	 esp,4
1  3084	0000052E  59				 pop	 ecx
1  3085	0000052F  EB D6				 jmp	 search_free_descs
1  3086
1  3087	00000531				 found_descs:
1  3088	00000531  58 59	5B			 pop	 eax ecx ebx
1  3089	00000534  50 51				 push	 eax ecx
1  3090	00000536				 alloc_em:
1  3091	00000536  FE 80	0000061Cr			 inc	 byte ptr [eax+free_descs_handles]
1  3092	0000053C  C7 04	C5 000005CCr  +			 mov	 dword ptr [eax*8+free_descs_start],0
   3093		  00000000
1  3094	00000547  C7 04	C5 000005D0r  +			 mov	 dword ptr [eax*8+free_descs_start+4],0C09300h
   3095		  00C09300
1  3096	00000552  40					 inc	 eax
1  3097	00000553  E2 E1				 loop	 alloc_em
1  3098	00000555  59 58				 pop	 ecx eax
1  3099	00000557  83 C0	0C			 add	 eax,NUM_DESCS
1  3100	0000055A  C1 E0	03			 shl	 eax,3
1  3101	0000055D  1F				 pop	 ds
1  3102	0000055E  83 C4	04			 add	 esp,4
1  3103	00000561  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3104	00000566  CF				 iretd
1  3105
1  3106	00000567				 not_enough_descs:
1  3107	00000567  5B 1F	58			 pop	 ebx ds	eax
1  3108	0000056A  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3109	0000056F  CF				 iretd
1  3110					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3111	00000570			 free_desc:
1  3112	00000570  1E 53				 push	 ds ebx
1  3113	00000572  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3114	00000579  0F B7	DB			 movzx	 ebx,bx
1  3115	0000057C  66| C1 EB 03			 shr	 bx,3
1  3116	00000580  80 4C	24 10 01		 or	 byte ptr ss:[esp+4*4],1
1  3117	00000585  80 FB	0C			 cmp	 bl,NUM_DESCS
1  3118	00000588  72 11				 jb	 free_desc_error
1  3119	0000058A  80 FB	16			 cmp	 bl,NUM_DESCS+FREE_DESCS
1  3120	0000058D  73 0C				 jae	 free_desc_error
1  3121	0000058F  C6 83	00000610r 00		 mov	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3122	00000596  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3123	0000059B				 free_desc_error:
1  3124	0000059B  5B 1F				 pop	 ebx ds
1  3125	0000059D  CF				 iretd
1  3126					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3127	0000059E			 next_desc:
1  3128	0000059E  66| B8 0008			 mov	 ax,8
1  3129	000005A2  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3130	000005A7  CF				 iretd
1  3131					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3132	000005A8			 set_desc:
1  3133	000005A8  1E 53				 push	 ds ebx
1  3134	000005AA  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3135	000005B1  0F B7	DB			 movzx	 ebx,bx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 56
DarkX.ASM



1  3136	000005B4  66| C1 EB 03			 shr	 bx,3
1  3137	000005B8  80 4C	24 10 01		 or	 byte ptr ss:[esp+4*4],1
1  3138	000005BD  83 FB	0C			 cmp	 ebx,NUM_DESCS
1  3139	000005C0  72 28				 jb	 set_desc_error
1  3140	000005C2  83 FB	16			 cmp	 ebx,NUM_DESCS+FREE_DESCS
1  3141	000005C5  73 23				 jae	 set_desc_error
1  3142	000005C7  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3143	000005CE  74 1A				 jz	 set_desc_error
1  3144	000005D0  26: FF 37			 push	 dword ptr es:[edi]
1  3145	000005D3  8F 04	DD 00000564r		 pop	 dword ptr [ebx*8+gdt]
1  3146	000005DA  26: FF 77 04			 push	 dword ptr es:[edi+4]
1  3147	000005DE  8F 04	DD 00000568r		 pop	 dword ptr [ebx*8+gdt+4]
1  3148	000005E5  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3149	000005EA				 set_desc_error:
1  3150	000005EA  5B 1F				 pop	 ebx ds
1  3151	000005EC  CF				 iretd
1  3152					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3153	000005ED			 get_seg_base:
1  3154	000005ED  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3155	000005F2  53 1E				 push	 ebx ds
1  3156	000005F4  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3157	000005FB  0F B7	DB			 movzx	 ebx,bx
1  3158	000005FE  66| C1 EB 03			 shr	 bx,3
1  3159	00000602  66| 83 FB 16			 cmp	 bx,NUM_DESCS+FREE_DESCS
1  3160	00000606  73 2A				 jae	 get_seg_base_error
1  3161	00000608  66| 83 FB 0C			 cmp	 bx,NUM_DESCS
1  3162	0000060C  72 09				 jb	 get_this_base
1  3163	0000060E  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3164	00000615  74 1B				 jz	 get_seg_base_error
1  3165	00000617				 get_this_base:
1  3166	00000617  66| 8B 14 DD	      +		 mov	 dx,word ptr [ebx*8+gdt+2]
   3167		  00000566r
1  3168	0000061F  8A 0C	DD 00000568r		 mov	 cl,byte ptr [ebx*8+gdt+4]
1  3169	00000626  8A 2C	DD 0000056Br		 mov	 ch,byte ptr [ebx*8+gdt+7]
1  3170	0000062D  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3171	00000632				 get_seg_base_error:
1  3172	00000632  1F 5B				 pop	 ds ebx
1  3173	00000634  CF				 iretd
1  3174
1  3175					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3176					 ; Interrupt Vector Services
1  3177					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3178					 ASSUME	 DS:txcode32
1  3179	00000635			 get_int_vector:
1  3180	00000635  1E 50	53			 push	 ds eax	ebx
1  3181	00000638  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3182	0000063F  B8 00000000s			 mov	 eax,txcode32
1  3183	00000644  C1 E0	04			 shl	 eax,4
1  3184	00000647  0F B6	DB			 movzx	 ebx,bl
1  3185	0000064A  80 FB	08			 cmp	 bl,8
1  3186	0000064D  72 08				 jb	 no_irq_fixup1
1  3187	0000064F  80 FB	0F			 cmp	 bl,15
1  3188	00000652  77 03				 ja	 no_irq_fixup1
1  3189	00000654  80 C3	48				 add	 bl,50h-8	 ; irq's redireccionadas
1  3190	00000657				 no_irq_fixup1:
1  3191	00000657  66| 8B 8C D8	      +		 mov	 cx,word ptr [ebx*8+eax+idt+2]
   3192		  00001EF9r
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 57
DarkX.ASM



1  3193	0000065F  66| 8B 94 D8	      +		 mov	 dx,word ptr [ebx*8+eax+idt+6]
   3194		  00001EFDr
1  3195	00000667  C1 E2	10			 shl	 edx,16
1  3196	0000066A  66| 8B 94 D8	      +		 mov	 dx,word ptr [ebx*8+eax+idt]
   3197		  00001EF7r
1  3198	00000672  5B 58	1F			 pop	 ebx eax ds
1  3199	00000675  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3200	0000067A  CF				 iretd
1  3201					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3202	0000067B			 set_int_vector:
1  3203	0000067B  1E 50	53			 push	 ds eax	ebx
1  3204	0000067E  FA				 cli
1  3205	0000067F  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3206	00000686  B8 00000000s			 mov	 eax,txcode32
1  3207	0000068B  C1 E0	04			 shl	 eax,4
1  3208	0000068E  0F B6	DB			 movzx	 ebx,bl
1  3209	00000691  80 FB	08			 cmp	 bl,8
1  3210	00000694  72 08				 jb	 no_irq_fixup2
1  3211	00000696  80 FB	0F			 cmp	 bl,15
1  3212	00000699  77 03				 ja	 no_irq_fixup2
1  3213	0000069B  80 C3	48				 add	 bl,50h-8
1  3214	0000069E				 no_irq_fixup2:
1  3215	0000069E  66| 89 8C D8	      +		 mov	 word ptr [ebx*8+eax+idt+2],cx
   3216		  00001EF9r
1  3217	000006A6  66| 89 94 D8	      +		 mov	 word ptr [ebx*8+eax+idt],dx
   3218		  00001EF7r
1  3219	000006AE  C1 EA	10			 shr	 edx,16
1  3220	000006B1  66| 89 94 D8	      +		 mov	 word ptr [ebx*8+eax+idt+6],dx
   3221		  00001EFDr
1  3222	000006B9  FB				 sti
1  3223	000006BA  5B 58	1F			 pop	 ebx eax ds
1  3224	000006BD  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3225	000006C2  CF				 iretd
1  3226					 ASSUME	 DS:txdata
1  3227
1  3228					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3229					 ; Memory Mapping Services
1  3230					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3231	000006C3			 map_memory:
1  3232	000006C3  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3233	000006C8  1E				 push	 ds
1  3234	000006C9  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3235	000006D0  67| F6 06 0341r 01		 test	 system_type,1
1  3236	000006D6  0F 84	000000EB		 jz	 no_mapping_needed
1  3237	000006DC  FA					 cli
1  3238							 ; s¢lo	hacemos	algo si	tenemos	VCPI
1  3239	000006DD  60					 pushad
1  3240	000006DE  06					 push	 es
1  3241	000006DF  66| 53				 push	 bx
1  3242	000006E1  66| 51				 push	 cx
1  3243	000006E3  5B					 pop	 ebx		 ; EBX = linear	address	of region
1  3244	000006E4  66| 81 E3 F000			 and	 bx,0F000h	 ; 4Kb alignment
1  3245	000006E9  81 FB	00100000			 cmp	 ebx,100000h	 ; si est  en el primer	Mb
1  3246	000006EF  0F 86	000000D4			 jbe	 no_pageable	 ; no se puede paginar
1  3247	000006F5  66| 56				 push	 si
1  3248	000006F7  66| 57				 push	 di
1  3249	000006F9  59					 pop	 ecx		 ; ECX = size of region	in bytes
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 58
DarkX.ASM



1  3250	000006FA  0B C9					 or	 ecx,ecx
1  3251	000006FC  0F 84	000000C7			 jz	 no_pageable
1  3252	00000702  66| 81 C1 0FFF			 add	 cx,0FFFh
1  3253	00000707  66| 81 E1 F000			 and	 cx,0F000h	 ; 4Kb multiple
1  3254	0000070C  C1 E9	0A				 shr	 ecx,10		 ; size/1024
1  3255
1  3256							 ; alojamos 1Kb	por cada 1Mb que queramos paginar
1  3257	0000070F  53 51					 push	 ebx ecx
1  3258	00000711  66| B8 0100				 mov	 ax,100h
1  3259	00000715  8B D9					 mov	 ebx,ecx
1  3260	00000717  C1 EB	04				 shr	 ebx,4		 ; /16 -> p rrafos
1  3261	0000071A  66| 81 C3 0100			 add	 bx,4096/16	 ; para	alinear	a 4Kb
1  3262	0000071F  CD 31					 int	 31h
1  3263	00000721  59 5B					 pop	 ecx ebx
1  3264	00000723  0F 82	000000A0			 jc	 no_pageable
1  3265	00000729  66| 05 00FF				 add	 ax,0FFh
1  3266	0000072D  66| 25 FF00				 and	 ax,0FF00h	 ; alineamos
1  3267	00000731  0F B7	C0				 movzx	 eax,ax
1  3268	00000734  C1 E0	04				 shl	 eax,4	 ; EAX = linear	address	of first entry
1  3269
1  3270							 ; buscamos p ginas con	el present bit = 0
1  3271	00000737  2E: 8E 05 00000004r			 mov	 es,cs:D32_SEL
1  3272	0000073E  67| 8B 3E 0355r			 mov	 edi,page_dir_base
1  3273	00000743  8B D1					 mov	 edx,ecx
1  3274	00000745  66| 81 C2 0FFF			 add	 dx,0FFFh
1  3275	0000074A  66| 81 E2 F000			 and	 dx,0F000h
1  3276	0000074F  C1 EA	0C				 shr	 edx,12		 ; EDX = page dir. entries needed
1  3277	00000752  67| 8B 2E 0359r			 mov	 ebp,page_dir_entries
1  3278	00000757					 search_nopresent_entries:
1  3279	00000757  52						 push	 edx
1  3280	00000758  26: F6 07 01					 test	 byte ptr es:[edi],1
1  3281	0000075C  75 0E						 jnz	 present_entry
1  3282	0000075E						 look_for_enough_space:
1  3283	0000075E  26: F6 07 01						 test	 byte ptr es:[edi],1
1  3284	00000762  75 08							 jnz	 present_entry
1  3285	00000764  83 C7	04						 add	 edi,4
1  3286	00000767  4A						 dec	 edx
1  3287	00000768  75 F4						 jnz	 look_for_enough_space
1  3288	0000076A  EB 09						 jmp	 found_space_for_paging
1  3289	0000076C						 present_entry:
1  3290	0000076C  83 C7	04					 add	 edi,4
1  3291	0000076F  5A						 pop	 edx
1  3292	00000770  4D					 dec	 ebp
1  3293	00000771  75 E4					 jnz	 search_nopresent_entries
1  3294	00000773  EB 54					 jmp	 no_pageable
1  3295
1  3296	00000775					 found_space_for_paging:
1  3297	00000775  5A					 pop	 edx
1  3298	00000776  C1 E2	02				 shl	 edx,2
1  3299	00000779  2B FA					 sub	 edi,edx	  ; EDI	-> group of free entries
1  3300
1  3301							 ; entradas del	directorio de p gs. = tablas de	p gs.
1  3302	0000077B  8B D1					 mov	 edx,ecx
1  3303	0000077D  66| 81 C2 0FFF			 add	 dx,0FFFh	  ; round up size to 4Mb
1  3304	00000782  66| 81 E2 F000			 and	 dx,0F000h
1  3305	00000787  C1 EA	0C				 shr	 edx,12
1  3306	0000078A  50					 push	 eax
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 59
DarkX.ASM



1  3307	0000078B  0C 07					 or	 al,7
1  3308	0000078D  57					 push	 edi
1  3309	0000078E  FC					 cld
1  3310	0000078F					 set_dir_entries:
1  3311	0000078F  AB						 stosd
1  3312	00000790  05 00001000					 add	 eax,1000h
1  3313	00000795  4A					 dec	 edx
1  3314	00000796  75 F7					 jnz	 set_dir_entries
1  3315	00000798  5F 58					 pop	 edi eax
1  3316
1  3317	0000079A  C1 E9	02				 shr	 ecx,2		 ; size/4Kb
1  3318	0000079D  80 CB	67				 or	 bl,67h		 ; dirty,accessed,user,writeable,present
1  3319	000007A0					 map_the_region:
1  3320	000007A0  26: 89 18					 mov	 es:[eax],ebx
1  3321	000007A3  81 C3	00001000				 add	 ebx,1000h
1  3322	000007A9  83 C0	04					 add	 eax,4
1  3323	000007AC  E2 F2					 loop	 map_the_region
1  3324	000007AE  67| 2B 3E 0351r			 sub	 edi,dir_base
1  3325	000007B3  C1 E7	14				 shl	 edi,20
1  3326	000007B6  57					 push	 edi
1  3327	000007B7  66| 59 66| 5B				 pop	 cx bx
1  3328	000007BB  07					 pop	 es
1  3329	000007BC  66| 89 5C 24 10			 mov	 ss:[esp+4*4],bx
1  3330	000007C1  66| 89 4C 24 18			 mov	 ss:[esp+4*6],cx
1  3331	000007C6  61					 popad
1  3332	000007C7				 no_mapping_needed:
1  3333	000007C7  1F				 pop	 ds
1  3334	000007C8  CF				 iretd
1  3335
1  3336	000007C9				 no_pageable:
1  3337	000007C9  07				 pop	 es
1  3338	000007CA  61				 popad
1  3339	000007CB  80 4C	24 0C 01		 or	 byte ptr ss:[esp+4*3],1
1  3340	000007D0  EB F5				 jmp	 no_mapping_needed
1  3341
1  3342					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3343					 ; Real	Mode Call-Back Services
1  3344					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3345					 ASSUME	 DS:txdata
1  3346	000007D2			 callback_alloc:
1  3347	000007D2  50 53	51 52			 push	 eax ebx ecx edx
1  3348	000007D6  66| 8C DB			 mov	 bx,ds
1  3349	000007D9  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3350	000007E0  B9 00000020			 mov	 ecx,CALLBACKS
1  3351	000007E5  33 C0				 xor	 eax,eax
1  3352	000007E7				 search_a_free_callback:
1  3353	000007E7  80 B8	00000CFFr 00			 cmp	 [eax+callback_data.callback_state],FREE_CB
1  3354	000007EE  74 0F					 jz	 cb_found
1  3355	000007F0  83 C0	0F				 add	 eax,size TCallback
1  3356	000007F3  E2 F2				 loop	 search_a_free_callback
1  3357						 ; error: no more free call-back addresses
1  3358	000007F5  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3359	000007F9  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3360	000007FE  CF				 iretd
1  3361
1  3362	000007FF				 cb_found:
1  3363	000007FF  C6 80	00000CFFr 01		 mov	 [eax+callback_data.callback_state],ALLOCATED_CB    ; now it's allocated
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 60
DarkX.ASM



1  3364	00000806  89 B0	00000D02r		 mov	 [eax+callback_data.pm_proc_to_call.loffset],esi
1  3365	0000080C  66| 89 98 00000D06r		 mov	 [eax+callback_data.pm_proc_to_call.selector],bx
1  3366	00000813  89 B8	00000D08r		 mov	 [eax+callback_data.rm_call_struc.loffset],edi
1  3367	00000819  66| 8C 80 00000D0Cr		 mov	 [eax+callback_data.rm_call_struc.selector],es
1  3368	00000820  8E DB				 mov	 ds,bx	 ; segment restore
1  3369	00000822  5A 59				 pop	 edx ecx
1  3370	00000824  66| B9 0000s			 mov	 cx,txcode
1  3371						 ; OFFSET = (EAX / size	TCallback) * size CallbackSlot
1  3372	00000828  BB 0000000F			 mov	 ebx,size TCallback
1  3373	0000082D  33 D2				 xor	 edx,edx
1  3374	0000082F  F7 F3				 div	 ebx
1  3375	00000831  BB 00000007			 mov	 ebx,offset end_of_cb_address-offset callback_address_table
1  3376	00000836  F7 E3				 mul	 ebx
1  3377	00000838  05 000004D7r			 add	 eax,offset callback_address_table
1  3378	0000083D  8B D0				 mov	 edx,eax	 ; CX:DX -> call-back address
1  3379	0000083F  5B 58				 pop	 ebx eax
1  3380	00000841  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3381	00000846  CF				 iretd
1  3382					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3383	00000847			 callback_free:
1  3384	00000847  50 53	51 52			 push	 eax ebx ecx edx
1  3385	0000084B  66| BB 04D7r			 mov	 bx,offset callback_address_table
1  3386	0000084F  33 C0				 xor	 eax,eax
1  3387	00000851  B9 00000020			 mov	 ecx,CALLBACKS
1  3388	00000856				 search_address:
1  3389	00000856  66| 3B DA				 cmp	 bx,dx
1  3390	00000859  74 13					 jz	 address_found
1  3391	0000085B  66| 83 C3 07				 add	 bx,offset end_of_cb_address-offset callback_address_table
1  3392	0000085F  83 C0	0F				 add	 eax,size TCallback
1  3393	00000862  E2 F2				 loop	 search_address
1  3394	00000864  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3395	00000868  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3396	0000086D  CF				 iretd
1  3397
1  3398	0000086E				 address_found:
1  3399	0000086E  1E				 push	 ds
1  3400	0000086F  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3401	00000876  C6 80	00000CFFr 00		 mov	 [eax+callback_data.callback_state],FREE_CB ; now it's free
1  3402	0000087D  1F				 pop	 ds
1  3403	0000087E  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3404	00000882  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3405	00000887  CF				 iretd
1  3406
1  3407					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3408					 ; Real	Mode Interrupt Management Functions
1  3409					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3410	00000888			 get_rm_int_vec:
1  3411	00000888  1E 53				 push	 ds ebx
1  3412	0000088A  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3413	00000891  0F B6	DB			 movzx	 ebx,bl
1  3414	00000894  66| 8B 14 9D	      +		 mov	 dx,[ebx*4]
   3415		  00000000
1  3416	0000089C  66| 8B 0C 9D	      +		 mov	 cx,[ebx*4+2]
   3417		  00000002
1  3418	000008A4  5B 1F				 pop	 ebx ds
1  3419	000008A6  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3420	000008AB  CF				 iretd
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 61
DarkX.ASM



1  3421					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3422	000008AC			 set_rm_int_vec:
1  3423	000008AC  1E				 push	 ds
1  3424	000008AD  0F B6	DB			 movzx	 ebx,bl
1  3425	000008B0  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3426	000008B7  66| 89 14 9D	      +		 mov	 [ebx*4],dx
   3427		  00000000
1  3428	000008BF  66| 89 0C 9D	      +		 mov	 [ebx*4+2],cx
   3429		  00000002
1  3430	000008C7  1F				 pop	 ds
1  3431	000008C8  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3432	000008CD  CF				 iretd
1  3433					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3434
1  3435
1  3436
   3437					 INCLUDE		 oemfuncs.inc	 ; DarkX OEM functions
1  3438		  =0062			 TX32_VERSION	 EQU 0098
1  3439
1  3440					 ASSUME	 DS:txdata
1  3441					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3442					 ; TX32	OEM functions
1  3443					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3444	000008CE			 get_sys_info:
1  3445					 ; OUTPUT -> AX	= cpu info
1  3446					 ;		 AH = cpu family ; AL =	b7..4: model
1  3447					 ;					b3..0: stepping
1  3448					 ;	     ( CPUID return code where available and 0300h or 0400h for	386
1  3449					 ;	      and 486 respectively )
1  3450					 ;	     BL	= FPU type
1  3451					 ;		  ( 00h	= not present ;	02h = 287 ; 03h	= 387 ;	04h = 487 )
1  3452					 ;	     CL	= system type
1  3453					 ;		  ( 01h	= RAW ;	02h = XMS ; 03h	= VCPI ; 04h = DPMI )
1  3454	000008CE  1E				 push	 ds
1  3455	000008CF  E8 00000016			 call	 determine_sys
1  3456	000008D4  8A CA				 mov	 cl,dl
1  3457	000008D6  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3458	000008DD  66| 67| A1 033Fr		 mov	 ax,cpu_info
1  3459	000008E2  67| 8A 1E 0342r		 mov	 bl,fpu_info
1  3460	000008E7  1F				 pop	 ds
1  3461	000008E8  66| CF			 iret
1  3462
1  3463	000008EA			 determine_sys	  proc
1  3464					 ; OUTPUT -> DL	= system type with output format
1  3465					 ;	     ( 01 = RAW	, 02 = XMS , 04	= VCPI , 08 = DPMI )
1  3466	000008EA  1E				 push	 ds
1  3467	000008EB  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3468	000008F2  33 C0				 xor	 eax,eax
1  3469	000008F4  67| A0 0341r			 mov	 al,system_type
1  3470	000008F8  2E: 8A 90 00000910r		 mov	 dl,cs:[eax+sys_type_vals]
1  3471	000008FF  80 FA	01			 cmp	 dl,1
1  3472	00000902  75 0A				 jnz	 sys_determined
1  3473	00000904  67| 83 3E 0347r 00			 cmp	 xms_entry_point,0
1  3474	0000090A  74 02					 jz	 sys_determined
1  3475	0000090C  FE C2					 inc	 dl
1  3476	0000090E				 sys_determined:
1  3477	0000090E  1F				 pop	 ds
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 62
DarkX.ASM



1  3478	0000090F  C3				 ret
1  3479	00000910  01 04	08		 sys_type_vals	 db 1,4,8
1  3480	00000913			 determine_sys	 endp
1  3481					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3482	00000913			 get_program_info:
1  3483					 ; INPUT  -> DS:ESI -> buffer for TX32 information
1  3484					 ;	     ECX = size	of buffer (for not overflowing with later versions)
1  3485					 ;
1  3486					 ; OUTPUT -> AX	= TX32 version in binary (v0.98	-> AX=0062h, for example)
1  3487					 ;			 AH = major version
1  3488					 ;			 AL = minor version
1  3489					 ;	     DS:ESI -> info buffer filled with a maximum of ECX	bytes
1  3490					 ;
1  3491					 ;		 Format	of info	buffer for TX32	v0.98:
1  3492					 ;
1  3493					 ;		 Offset	 Size	 Description
1  3494					 ;		 00h	 DWORD	 Program base (zero with LE's)
1  3495					 ;		 04h	 DWORD	 PSP offset relative to	program	base
1  3496					 ;		 08h	 DWORD	 Environment offset rel. to prog. base
1  3497					 ;		 0Ch	 DWORD	 ASCIIZ	exe name offset	rel. to	prog. base
1  3498					 ;		 10h	 WORD	 Zero based 4Gb	data selector
1  3499					 ;		 12h	 WORD	 Program based 4Gb data	selector
1  3500					 ;		 14h	 WORD	 PSP based 100h	bytes data selector
1  3501					 ;		 16h	 WORD	 Real mode disk	buffer segment
1  3502					 ;				 (used for disk	data interchange between real
1  3503					 ;				  mode and protected mode)
1  3504
1  3505	00000913  1E 06	56 57 51		 push	 ds es esi edi ecx
1  3506	00000918  0B C9				 or	 ecx,ecx
1  3507	0000091A  74 1D				 jz	 program_info_done
1  3508	0000091C  83 F9	18			 cmp	 ecx,24
1  3509	0000091F  76 05				 jbe	 length_ok
1  3510	00000921  B9 00000018				 mov	 ecx,24
1  3511	00000926				 length_ok:
1  3512	00000926  1E 56				 push	 ds esi
1  3513	00000928  5F 07				 pop	 edi es
1  3514	0000092A  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3515	00000931  BE 00000321r			 mov	 esi,offset exe_info_struc
1  3516	00000936  FC				 cld
1  3517	00000937  F3> A4			 rep	 movsb
1  3518	00000939				 program_info_done:
1  3519	00000939  66| B8 0062			 mov	 ax,TX32_VERSION	 ; version number
1  3520	0000093D  59 5F	5E 07 1F		 pop	 ecx edi esi es	ds
1  3521	00000942  CF				 iretd
1  3522					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3523
   3524					 INCLUDE		 dos32sup.inc	 ; DOS32 basic support
1  3525					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3526					 ; DOS32 basic support routines
1  3527					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3528					 ASSUME	 DS:txdata
1  3529	00000943			 dos32_sys_info:
1  3530	00000943  1E				 push	 ds
1  3531	00000944  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3532	0000094B  67| 8B 1E 0321r		 mov	 ebx,program_offset
1  3533	00000950  67| 8B 16 033Br		 mov	 edx,exe_size
1  3534	00000955  67| 8B 36 0325r		 mov	 esi,psp_offset
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 63
DarkX.ASM



1  3535	0000095A  67| 8B 3E 0329r		 mov	 edi,env_offset
1  3536	0000095F  67| 8B 0E 032Dr		 mov	 ecx,program_name_ptr
1  3537	00000964  66| B8 0000s			 mov	 ax,disk
1  3538	00000968  1F				 pop	 ds
1  3539	00000969  CF				 iretd
1  3540					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3541	0000096A			 dos32_info:
1  3542	0000096A  E8 FFFFFF7B			 call	 determine_sys	 ; DL =	system type
1  3543	0000096F  33 C0				 xor	 eax,eax	 ; DOS32 version = 0.0 cause nothing is	implemented
1  3544	00000971  66| 2E: 8B 1D	      +		 mov	 bx,cs:D32_SEL	 ; BX =	selector 32 bits base 0	l¡m. 4Gb
   3545		  00000004r
1  3546	00000979  CF				 iretd
1  3547					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3548
   3549					 INCLUDE		 ints32.inc
1  3550					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3551	0000097A			 real_int:
1  3552	0000097A  53				 push	 ebx
1  3553	0000097B  8B 5C	24 10			 mov	 ebx,ss:[esp+4*4]
1  3554	0000097F  81 E3	00000200		 and	 ebx,1 SHL 9
1  3555	00000985  9C				 pushfd
1  3556	00000986  09 1C	24			 or	 ss:[esp],ebx
1  3557	00000989  9D				 popfd
1  3558						 ; nos guardamos los segmentos
1  3559						 ASSUME	 DS:txdata
1  3560	0000098A  66| 8C DB			 mov	 bx,ds
1  3561	0000098D  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
1  3562	00000994  66| 67| 89 1E	0376r		 mov	 pm_ds,bx
1  3563	0000099A  66| 67| 8C 06	0378r		 mov	 pm_es,es
1  3564	000009A0  66| 67| 8C 26	037Ar		 mov	 pm_fs,fs
1  3565	000009A6  66| 67| 8C 2E	037Cr		 mov	 pm_gs,gs
1  3566						 ; ponemos el int_num
1  3567	000009AC  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_sel
1  3568	000009B3  BB 00000000s			 mov	 ebx,txcode
1  3569	000009B8  8D 1C	DD 00000000		 lea	 ebx,[ebx*8]	 ; as¡,	no modificamos los flags
1  3570	000009BF  8D 1C	5D 00000000		 lea	 ebx,[ebx*2]
1  3571						 ASSUME	 DS:txcode
1  3572	000009C6  88 83	000004B1r		 mov	 [ebx+int_num],al
1  3573	000009CC  5B				 pop	 ebx
1  3574	000009CD  58				 pop	 eax
1  3575
1  3576	000009CE				 need_real_segs:	 ; funny label (he,he...)
1  3577	000009CE  9C				 pushfd
1  3578	000009CF  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3579	000009D6  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3580	000009DD  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3581						 pushd	 ret_real
2  3582	000009E4  68				 db 68h
2  3583	000009E5  09BEr	0000			 dw offset ret_real,0
1  3584	000009E9  CF				 iretd
1  3585
1  3586	000009EA			 pm_ret_point:
1  3587	000009EA  FA				 cli
1  3588
1  3589						 ; ajustamos pila para modo protegido
1  3590						 ASSUME	 DS:txdata
1  3591	000009EB  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 64
DarkX.ASM



1  3592						 ; primero restauramos SS:ESP de protegido para	poder usar pila
1  3593	000009F2  67| 8B 26 0520r		 mov	 esp,pm_esp
1  3594	000009F7  67| 8E 16 037Er		 mov	 ss,pm_ss
1  3595
1  3596						 ; restauramos todos los registros de modo real
1  3597	000009FC  66| 67| A1 04F2r		 mov	 ax,real_flags
1  3598	00000A01  66| 89 44 24 08		 mov	 ss:[esp+4*2],ax
1  3599	00000A06  67| A1 04EEr			 mov	 eax,real_eax
1  3600	00000A0A  67| 8B 1E 04E2r		 mov	 ebx,real_ebx
1  3601	00000A0F  67| 8B 0E 04EAr		 mov	 ecx,real_ecx
1  3602	00000A14  67| 8B 16 04E6r		 mov	 edx,real_edx
1  3603	00000A19  67| 8B 36 04D6r		 mov	 esi,real_esi
1  3604	00000A1E  67| 8B 3E 04D2r		 mov	 edi,real_edi
1  3605	00000A23  67| 8B 2E 04DAr		 mov	 ebp,real_ebp
1  3606					 ;	  push	  word ptr real_flags
1  3607					 ;	  pop	  word ptr ss:[esp+4*2]	  ; flags devueltos por	la int a protegido
1  3608
1  3609						 ; acabamos restaurando	los registros de segmento
1  3610	00000A28  67| 8E 06 0378r		 mov	 es,pm_es
1  3611	00000A2D  67| 8E 26 037Ar		 mov	 fs,pm_fs
1  3612	00000A32  67| 8E 2E 037Cr		 mov	 gs,pm_gs
1  3613	00000A37  67| 8E 1E 0376r		 mov	 ds,pm_ds	 ; si restauramos antes	DS, no podemos
1  3614									 ; direccionar RET_INFO
1  3615	00000A3C  CF				 iretd
1  3616					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3617	00000A3D			 real_irq:
1  3618					 ; INPUT -> AL = interrupt number
1  3619	00000A3D  60				 pushad
1  3620	00000A3E  1E 06	0F A0 0F A8		 push	 ds es fs gs
1  3621	00000A44  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3622	00000A4B  0F B6	C0			 movzx	 eax,al
1  3623	00000A4E  26: 8B 1C 85	      +		 mov	 ebx,es:[eax*4]	 ; direcci¢n real del handle de	interrupci¢n
   3624		  00000000
1  3625	00000A56  B9 00000000s			 mov	 ecx,txcode
1  3626	00000A5B  C1 E1	04			 shl	 ecx,4
1  3627						 ASSUME	 ES:txcode
1  3628	00000A5E  26: 89 99 000004BAr		 mov	 es:[ecx+rm_proc_address],ebx
1  3629	00000A65  26: FF B1 00000019r		 push	 dword ptr es:[ecx+saltito+1]
1  3630	00000A6C  66| 26: C7 81	      +		 mov	 word ptr es:[ecx+saltito+1],offset irq16
   3631		  00000019r 04BEr
1  3632	00000A76  66| 26: C7 81	      +		 mov	 word ptr es:[ecx+saltito+3],txcode
   3633		  0000001Br 0000s
1  3634	00000A80  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3635						 ASSUME	 DS:txdata
1  3636	00000A87  67| FF 36 0532r		 push	 dword ptr prot_code_address
1  3637	00000A8C  67| FF 36 0536r		 push	 dword ptr prot_code_address+4
1  3638	00000A91  67| C7 06 0532r     +		 mov	 dword ptr prot_code_address,offset back_from_irq16
   3639		  00000AB3r
1  3640	00000A9A  66| 67| 8C 16	037Er		 mov	 pm_ss,ss
1  3641	00000AA0  67| 89 26 0520r		 mov	 pm_esp,esp
1  3642	00000AA5  9C				 pushfd
1  3643	00000AA6  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3644	00000AAD  67| FF 36 0538r		 push	 dword ptr ret_real_address
1  3645	00000AB2  CF				 iretd
1  3646
1  3647	00000AB3				 back_from_irq16:
1  3648	00000AB3  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 65
DarkX.ASM



1  3649	00000ABA  67| 8E 16 037Er		 mov	 ss,pm_ss
1  3650	00000ABF  67| 8B 26 0520r		 mov	 esp,pm_esp
1  3651	00000AC4  67| 8F 06 0536r		 pop	 dword ptr prot_code_address+4
1  3652	00000AC9  67| 8F 06 0532r		 pop	 dword ptr prot_code_address
1  3653	00000ACE  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3654	00000AD5  B9 00000000s			 mov	 ecx,txcode
1  3655	00000ADA  C1 E1	04			 shl	 ecx,4
1  3656						 ASSUME	 DS:txcode
1  3657	00000ADD  8F 81	00000019r		 pop	 dword ptr [ecx+saltito+1]
1  3658						 ASSUME	 DS:txdata
1  3659	00000AE3  0F A9	0F A1 07 1F		 pop	 gs fs es ds
1  3660	00000AE9  61				 popad
1  3661	00000AEA  58				 pop	 eax
1  3662	00000AEB  CF				 iretd
1  3663					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3664
1  3665
   3666					 INCLUDE		 excs32.inc
1  3667					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3668	00000AEC			 exceptions:
1  3669						 ASSUME	 DS:txdata
1  3670						 ; rellenamos el texto de salida con los valores de debugging
1  3671	00000AEC  1E 53	57 51 56 55 52		 push	 ds ebx	edi ecx	esi ebp	edx
1  3672	00000AF3  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
1  3673						 ; n£mero de excepci¢n
1  3674	00000AFA  8A D0				 mov	 dl,al	 ; gate	number
1  3675	00000AFC  BF 00000719r			 mov	 edi,offset exception_number
1  3676	00000B01  32 C9				 xor	 cl,cl
1  3677	00000B03  E8 000002FB			 call	 reg_to_hex
1  3678						 ; ponemos los valores de EDX,EBP,ESI,ECX,EDI y	EBX
1  3679						 ASSUME	 DS:txcode32
1  3680	00000B08  BB 00000006			 mov	 ebx,6
1  3681	00000B0D				 pon_registros:
1  3682	00000B0D  58					 pop	 eax
1  3683	00000B0E  2E: 8B 3C 9D	      +			 mov	 edi,cs:[ebx*4+reg_offsets-4]
   3684		  00000D5Cr
1  3685	00000B16  B1 02					 mov	 cl,2
1  3686	00000B18  53					 push	 ebx
1  3687	00000B19  E8 000002E5				 call	 reg_to_hex
1  3688	00000B1E  5B					 pop	 ebx
1  3689	00000B1F  4B				 dec	 ebx
1  3690	00000B20  75 EB				 jnz	 pon_registros
1  3691						 ASSUME	 DS:txdata
1  3692
1  3693						 ; valor de DS
1  3694	00000B22  58				 pop	 eax	 ; pq estamos en un segmento de	32 bits
1  3695	00000B23  50				 push	 eax
1  3696	00000B24  BF 00000992r			 mov	 edi,offset debug_ds
1  3697	00000B29  B1 01				 mov	 cl,1
1  3698	00000B2B  E8 000002D3			 call	 reg_to_hex
1  3699	00000B30  5B				 pop	 ebx
1  3700	00000B31  BF 000009A1r			 mov	 edi,offset desc_ds
1  3701	00000B36  E8 00000258			 call	 print_desc
1  3702						 ; valor de EAX
1  3703	00000B3B  58				 pop	 eax
1  3704	00000B3C  BF 00000852r			 mov	 edi,offset debug_eax
1  3705	00000B41  B1 02				 mov	 cl,2	 ; 32 bits
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 66
DarkX.ASM



1  3706	00000B43  E8 000002BB			 call	 reg_to_hex
1  3707						 ; valor de ES ( lo hacemos ahora para poder usar ES sin "popearlo" )
1  3708	00000B48  66| 8C C0			 mov	 ax,es
1  3709	00000B4B  BF 000009BFr			 mov	 edi,offset debug_es
1  3710	00000B50  B1 01				 mov	 cl,1
1  3711	00000B52  E8 000002AC			 call	 reg_to_hex
1  3712	00000B57  66| 8C C3			 mov	 bx,es
1  3713	00000B5A  BF 000009CEr			 mov	 edi,offset desc_es
1  3714	00000B5F  E8 0000022F			 call	 print_desc
1  3715						 ; si estamos bajo DPMI, tenemos CS:EIP	de retorno en pila y no	nos interesa
1  3716	00000B64  67| F6 06 0341r 02		 test	 system_type,2
1  3717	00000B6A  74 05				 jz	 no_tenemos_el_gusto
1  3718	00000B6C  83 C4	0C				 add	 esp,3*4
1  3719	00000B6F  EB 0B					 jmp	 no_error_code
1  3720	00000B71				 no_tenemos_el_gusto:
1  3721						 ; volcamos el opcode causante del error
1  3722	00000B71  80 FA	0E			 cmp	 dl,14		 ; s¢lo	las int's 9-13 tendr n 'error code' en pila
1  3723	00000B74  77 06				 ja	 no_error_code
1  3724	00000B76  80 FA	09			 cmp	 dl,9
1  3725	00000B79  72 01				 jb	 no_error_code
1  3726	00000B7B  58					 pop	 eax	 ; info	de debugging de	la CPU
1  3727	00000B7C				 no_error_code:
1  3728	00000B7C  58				 pop	 eax	 ; EIP
1  3729	00000B7D  5B				 pop	 ebx	 ; CS
1  3730	00000B7E  53				 push	 ebx
1  3731	00000B7F  50				 push	 eax
1  3732	00000B80  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  3733	00000B87  67| F6 06 0341r 02		 test	 system_type,2
1  3734	00000B8D  74 13				 jz	 normal_gdt
1  3735	00000B8F  50					 push	 eax
1  3736	00000B90  66| B8 000B				 mov	 ax,0Bh
1  3737	00000B94  BF 00000564r				 mov	 edi,offset gdt
1  3738	00000B99  CD 31					 int	 31h
1  3739	00000B9B  72 48					 jc	 invalid_code_selector
1  3740	00000B9D  33 DB					 xor	 ebx,ebx
1  3741	00000B9F  58					 pop	 eax
1  3742	00000BA0  EB 06					 jmp	 continua_volcado
1  3743	00000BA2				 normal_gdt:
1  3744						 ; vamos a hacerlo con el selector de 4Gb por si el de c¢digo es s¢lo ejecutable
1  3745	00000BA2  0F B7	DB			 movzx	 ebx,bx		 ; selector c¢digo
1  3746	00000BA5  80 E3	F8			 and	 bl,11111000b	 ; limpiamos el	requested PL y nos queda BX = descriptor * 8
1  3747						 ASSUME	 ES:txdata
1  3748	00000BA8				 continua_volcado:
1  3749	00000BA8  26: 8A 8B 0000056Br		 mov	 cl,byte ptr es:[ebx+7+gdt] ; CL = bits	24-31 de la base
1  3750	00000BAF  C1 E1	18			 shl	 ecx,24
1  3751	00000BB2  26: 8B 9B 00000566r		 mov	 ebx,dword ptr es:[ebx+2+gdt] ;	bits 0-23 de la	base
1  3752	00000BB9  81 E3	00FFFFFF		 and	 ebx,(1	SHL 24)-1	 ; limpiamos los 8 bits	superiores
1  3753	00000BBF  0B D9				 or	 ebx,ecx		 ; formamos la base completa
1  3754	00000BC1  03 D8				 add	 ebx,eax		 ; le sumamos el OFFSET
1  3755	00000BC3  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3756	00000BCA  BF 0000079Ar			 mov	 edi,offset crash_code
1  3757	00000BCF  B9 00000008			 mov	 ecx,8
1  3758	00000BD4				 vuelca_code:
1  3759	00000BD4  26: 8A 03				 mov	 al,es:[ebx]
1  3760	00000BD7  E8 00000269				 call	 bin_to_hex
1  3761	00000BDC  66| 89 07				 mov	 ds:[edi],ax
1  3762	00000BDF  83 C7	03				 add	 edi,3
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 67
DarkX.ASM



1  3763	00000BE2  43					 inc	 ebx
1  3764	00000BE3  E2 EF				 loop	 vuelca_code
1  3765
1  3766	00000BE5				 invalid_code_selector:
1  3767						 ; valor de EIP
1  3768	00000BE5  58				 pop	 eax	 ; EIP
1  3769	00000BE6  B1 02				 mov	 cl,2
1  3770	00000BE8  BF 0000078Br			 mov	 edi,offset debug_eip
1  3771	00000BED  E8 00000211			 call	 reg_to_hex
1  3772						 ; valor de CS
1  3773	00000BF2  58				 pop	 eax	 ; CS
1  3774	00000BF3  50				 push	 eax
1  3775	00000BF4  B1 01				 mov	 cl,1
1  3776	00000BF6  BF 00000786r			 mov	 edi,offset debug_cs
1  3777	00000BFB  E8 00000203			 call	 reg_to_hex
1  3778	00000C00  67| A1 0786r			 mov	 eax,dword ptr debug_cs
1  3779	00000C04  67| A3 0965r			 mov	 dword ptr debug_cs1,eax
1  3780	00000C08  5B				 pop	 ebx
1  3781	00000C09  BF 00000974r			 mov	 edi,offset desc_cs
1  3782	00000C0E  E8 00000180			 call	 print_desc
1  3783						 ; valor de FS
1  3784	00000C13  66| 8C E0			 mov	 ax,fs
1  3785	00000C16  BF 000009ECr			 mov	 edi,offset debug_fs
1  3786	00000C1B  B1 01				 mov	 cl,1
1  3787	00000C1D  E8 000001E1			 call	 reg_to_hex
1  3788	00000C22  66| 8C E3			 mov	 bx,fs
1  3789	00000C25  BF 000009FBr			 mov	 edi,offset desc_fs
1  3790	00000C2A  E8 00000164			 call	 print_desc
1  3791						 ; valor de GS
1  3792	00000C2F  66| 8C E8			 mov	 ax,gs
1  3793	00000C32  BF 00000A19r			 mov	 edi,offset debug_gs
1  3794	00000C37  B1 01				 mov	 cl,1
1  3795	00000C39  E8 000001C5			 call	 reg_to_hex
1  3796	00000C3E  66| 8C EB			 mov	 bx,gs
1  3797	00000C41  BF 00000A28r			 mov	 edi,offset desc_gs
1  3798	00000C46  E8 00000148			 call	 print_desc
1  3799						 ; valor de SS
1  3800	00000C4B  67| F6 06 0341r 02		 test	 system_type,2
1  3801	00000C51  74 06				 jz	 no_ss_de_pila
1  3802	00000C53  8B 44	24 08				 mov	 eax,ss:[esp+2*4]
1  3803	00000C57  EB 03					 jmp	 ss_de_pila
1  3804	00000C59				 no_ss_de_pila:
1  3805	00000C59  66| 8C D0			 mov	 ax,ss
1  3806	00000C5C				 ss_de_pila:
1  3807	00000C5C  B1 01				 mov	 cl,1
1  3808	00000C5E  BF 00000A46r			 mov	 edi,offset debug_ss
1  3809	00000C63  50				 push	 eax
1  3810	00000C64  E8 0000019A			 call	 reg_to_hex
1  3811	00000C69  5B				 pop	 ebx
1  3812	00000C6A  67| A1 0A46r			 mov	 eax,dword ptr debug_ss
1  3813	00000C6E  67| A3 07CCr			 mov	 dword ptr debug_ss0,eax
1  3814	00000C72  BF 00000A55r			 mov	 edi,offset desc_ss
1  3815	00000C77  E8 00000117			 call	 print_desc
1  3816						 ; valor de los	EFLAGS
1  3817	00000C7C  58				 pop	 eax
1  3818	00000C7D  50				 push	 eax
1  3819	00000C7E  B1 02				 mov	 cl,2
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 68
DarkX.ASM



1  3820	00000C80  BF 000008E3r			 mov	 edi,offset debug_flags
1  3821	00000C85  E8 00000179			 call	 reg_to_hex
1  3822						 ; valor de ESP	antes de la excepci¢n
1  3823	00000C8A  8B C4				 mov	 eax,esp
1  3824	00000C8C  83 C0	04			 add	 eax,4	 ; EFLAGS
1  3825	00000C8F  67| F6 06 0341r 02		 test	 system_type,2
1  3826	00000C95  74 04				 jz	 normal_esp
1  3827	00000C97  8B 44	24 04				 mov	 eax,ss:[esp+1*4]
1  3828	00000C9B				 normal_esp:
1  3829	00000C9B  B1 02				 mov	 cl,2
1  3830	00000C9D  BF 000008CFr			 mov	 edi,offset debug_esp
1  3831	00000CA2  E8 0000015C			 call	 reg_to_hex
1  3832	00000CA7  67| A1 08CFr			 mov	 eax,dword ptr debug_esp
1  3833	00000CAB  67| A3 07D1r			 mov	 dword ptr debug_esp0,eax
1  3834	00000CAF  67| A1 08D3r			 mov	 eax,dword ptr debug_esp+4
1  3835	00000CB3  67| A3 07D5r			 mov	 dword ptr debug_esp0+4,eax
1  3836						 ; volcamos la pila
1  3837	00000CB7  BE 00000003			 mov	 esi,3
1  3838	00000CBC  BD 00000004			 mov	 ebp,4
1  3839	00000CC1  BF 000007E0r			 mov	 edi,offset stack_cont1
1  3840	00000CC6  66| 8C D0			 mov	 ax,ss
1  3841	00000CC9  8E C0				 mov	 es,ax
1  3842	00000CCB  03 EC				 add	 ebp,esp
1  3843	00000CCD  67| F6 06 0341r 02		 test	 system_type,2
1  3844	00000CD3  74 0B				 jz	 vuelca_pila
1  3845	00000CD5  66| 8B 44 24 08		 mov	 ax,ss:[esp+2*4]
1  3846	00000CDA  8B 6C	24 04			 mov	 ebp,ss:[esp+1*4]
1  3847	00000CDE  8E C0				 mov	 es,ax
1  3848	00000CE0				 vuelca_pila:
1  3849	00000CE0  26: 8B 45 00				 mov	 eax,es:[ebp]
1  3850	00000CE4  B1 02					 mov	 cl,2
1  3851	00000CE6  55					 push	 ebp
1  3852	00000CE7  E8 00000117				 call	 reg_to_hex
1  3853	00000CEC  5D					 pop	 ebp
1  3854	00000CED  83 C5	04				 add	 ebp,4
1  3855	00000CF0  83 C7	09				 add	 edi,9
1  3856	00000CF3  4E				 dec	 esi
1  3857	00000CF4  75 EA				 jnz	 vuelca_pila
1  3858						 ; vamos a rellenar el campo de	info sobre el error
1  3859	00000CF6  0F B6	F2			 movzx	 esi,dl
1  3860	00000CF9  D1 E6				 shl	 esi,1	 ; * 2
1  3861	00000CFB  0F B7	B6 00000626r		 movzx	 esi,word ptr [esi + error_string_table]
1  3862	00000D02  BF 000006D5r			 mov	 edi,offset error_string
1  3863	00000D07  33 C9				 xor	 ecx,ecx
1  3864	00000D09				 put_err_strn:
1  3865	00000D09  8A 06					 mov	 al,[esi]
1  3866	00000D0B  0A C0					 or	 al,al
1  3867	00000D0D  74 07					 jz	 end_put
1  3868	00000D0F  88 07					 mov	 [edi],al
1  3869	00000D11  47					 inc	 edi
1  3870	00000D12  46					 inc	 esi
1  3871	00000D13  49				 dec	 ecx
1  3872	00000D14  75 F3				 jnz	 put_err_strn
1  3873	00000D16				 end_put:
1  3874
1  3875						 ; hacemos un acknowledge a los	PIC por	si la excepci¢n	ocurri¢	en
1  3876						 ; una IRQ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 69
DarkX.ASM



1  3877	00000D16  B0 20				 mov	 al,20h		 ; acknowledge
1  3878	00000D18  E6 20				 out	 20h,al		 ; master PIC
1  3879	00000D1A  E6 A0				 out	 0A0h,al	 ; slave PIC
1  3880
1  3881	00000D1C  67| F6 06 0341r 02		 test	 system_type,2
1  3882	00000D22  75 54				 jnz	 dpmi_exception_exit
1  3883
1  3884						 ; vamos a modificar el	salto para que salga la	info de	debugging
1  3885	00000D24  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3886	00000D2B  BB 00000000s			 mov	 ebx,txcode
1  3887	00000D30  C1 E3	04			 shl	 ebx,4
1  3888						 ASSUME	 DS:txcode
1  3889	00000D33  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset debug_info
   3890		  0A69r
1  3891	00000D3C  66| C7 83 0000001Br +		 mov	 word ptr [ebx+saltito+3],txcode
   3892		  0000s
1  3893
1  3894	00000D45  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3895	00000D4C  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3896	00000D53  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3897						 pushd	 ret_real
2  3898	00000D5A  68				 db 68h
2  3899	00000D5B  09BEr	0000			 dw offset ret_real,0
1  3900	00000D5F  CF				 iretd
1  3901
1  3902					 ASSUME	 DS:txdata
1  3903	00000D60  00000864r 000008ABr +	 reg_offsets	 dd offset debug_ebx,offset debug_edi,offset debug_ecx
   3904		  00000876r
1  3905	00000D6C  00000899r 000008BDr +			 dd offset debug_esi,offset debug_ebp,offset debug_edx
   3906		  00000888r
1  3907
1  3908					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3909
1  3910	00000D78			 dpmi_exception_exit:
1  3911					 ; DS =	D16_SEL
1  3912
1  3913	00000D78  9D				 popfd
1  3914	00000D79  5B				 pop	 ebx
1  3915	00000D7A  58				 pop	 eax
1  3916	00000D7B  FA				 cli
1  3917	00000D7C  8E D0				 mov	 ss,ax
1  3918	00000D7E  8B E3				 mov	 esp,ebx
1  3919
1  3920	00000D80  67| FE 06 04A9r		 inc	 dpmi_exception_flag
1  3921	00000D85  9C				 pushfd
1  3922	00000D86  2E: FF 35 00000000r		 push	 dword ptr cs:C32_SEL
1  3923						 pushd	 salida_dpmi
2  3924	00000D8D  68				 db 68h
2  3925	00000D8E  1E68r	0000			 dw offset salida_dpmi,0
1  3926	00000D92  CF				 iretd
1  3927
1  3928					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3929
1  3930	00000D93			 print_desc	 proc
1  3931					 ; INPUT  -> BX	= selector ; DS:EDI = direcci¢n	de destino
1  3932	00000D93  67| F6 06 0341r 02		 test	 system_type,2
1  3933	00000D99  74 31				 jz	 normal_sel
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 70
DarkX.ASM



1  3934	00000D9B  06 57					 push	 es edi
1  3935	00000D9D  66| B8 000B				 mov	 ax,0Bh
1  3936	00000DA1  2E: 8E 05 0000000Cr			 mov	 es,cs:D16_SEL
1  3937	00000DA8  BF 00000564r				 mov	 edi,offset gdt
1  3938	00000DAD  CD 31					 int	 31h
1  3939	00000DAF  5F 07					 pop	 edi es
1  3940	00000DB1  73 17					 jnc	 sel_ok
1  3941	00000DB3  06						 push	 es
1  3942	00000DB4  2E: 8E 05 0000000Cr				 mov	 es,cs:D16_SEL
1  3943	00000DBB  B9 00000017					 mov	 ecx,7*3+2
1  3944	00000DC0  BE 000006B7r					 mov	 esi,offset invalid_sel_msg
1  3945	00000DC5  FC						 cld
1  3946	00000DC6  F3> A4					 rep	 movsb
1  3947	00000DC8  07						 pop	 es
1  3948	00000DC9  C3						 ret
1  3949	00000DCA					 sel_ok:
1  3950	00000DCA  33 DB					 xor	 ebx,ebx
1  3951	00000DCC				 normal_sel:
1  3952	00000DCC  0F B7	DB			 movzx	 ebx,bx
1  3953					 ;	  and	  bl,11111000b
1  3954	00000DCF  C1 EB	03			 shr	 ebx,3
1  3955	00000DD2  66| 83 FB 16			 cmp	 bx,NUM_DESCS+FREE_DESCS
1  3956	00000DD6  73 2A				 jae	 no_volcado_desc
1  3957	00000DD8  66| 83 FB 0C			 cmp	 bx,NUM_DESCS
1  3958	00000DDC  72 09				 jb	 volcado_desc
1  3959						 ASSUME	 DS:txdata
1  3960	00000DDE  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3961	00000DE5  74 1B				 jz	 no_volcado_desc
1  3962	00000DE7				 volcado_desc:
1  3963	00000DE7  C1 E3	03			 shl	 ebx,3
1  3964	00000DEA  B1 08				 mov	 cl,8
1  3965	00000DEC				 vuelca_desc:
1  3966	00000DEC  8A 83	00000564r			 mov	 al,byte ptr [ebx+gdt]
1  3967	00000DF2  E8 0000004E				 call	 bin_to_hex
1  3968	00000DF7  66| 89 07				 mov	 [edi],ax
1  3969	00000DFA  83 C7	03				 add	 edi,3
1  3970	00000DFD  43					 inc	 ebx
1  3971	00000DFE  FE C9				 dec cl
1  3972	00000E00  75 EA				 jnz vuelca_desc
1  3973	00000E02				 no_volcado_desc:
1  3974	00000E02  C3				 ret
1  3975	00000E03			 print_desc	 endp
1  3976
1  3977					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3978
1  3979	00000E03			 reg_to_hex	 proc
1  3980					 ; INPUT -> EAX	= number to convert ; DS:EDI ->	destino
1  3981					 ;	    CL = 8/16/32 bit register (2=EAX ; 1=AX ; 0=AL)
1  3982
1  3983	00000E03  32 DB				 xor	 bl,bl
1  3984	00000E05  0A C9				 or	 cl,cl
1  3985	00000E07  74 0A				 jz	 es_al
1  3986	00000E09  80 F9	01			 cmp	 cl,1
1  3987	00000E0C  74 0B				 jz	 es_ax
1  3988	00000E0E  80 F9	02			 cmp	 cl,2
1  3989	00000E11  74 0F				 jz	 es_eax
1  3990	00000E13				 es_al:
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 71
DarkX.ASM



1  3991	00000E13  B1 01					 mov	 cl,1
1  3992	00000E15  33 ED					 xor	 ebp,ebp
1  3993	00000E17  EB 10					 jmp	 convert
1  3994	00000E19				 es_ax:
1  3995	00000E19  B1 02					 mov	 cl,2
1  3996	00000E1B  BD 00000002				 mov	 ebp,2
1  3997	00000E20  EB 07					 jmp	 convert
1  3998	00000E22				 es_eax:
1  3999	00000E22  B1 04					 mov	 cl,4
1  4000	00000E24  BD 00000006				 mov	 ebp,6
1  4001	00000E29				 convert:
1  4002	00000E29  51					 push	 ecx
1  4003	00000E2A  8A CB					 mov	 cl,bl
1  4004	00000E2C  50					 push	 eax
1  4005	00000E2D  D3 E8					 shr	 eax,cl
1  4006	00000E2F  E8 00000011				 call	 bin_to_hex
1  4007	00000E34  66| 89 04 2F				 mov	 [edi+ebp],ax
1  4008	00000E38  58					 pop	 eax
1  4009	00000E39  59					 pop	 ecx
1  4010	00000E3A  83 ED	02				 sub	 ebp,2
1  4011	00000E3D  80 C3	08				 add	 bl,8
1  4012	00000E40  FE C9				 dec	 cl
1  4013	00000E42  75 E5				 jnz	 convert
1  4014	00000E44  C3				 ret
1  4015	00000E45			 reg_to_hex	 endp
1  4016
1  4017					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4018
1  4019	00000E45			 bin_to_hex	 proc
1  4020					 ; INPUT  -> AL	= byte to convert
1  4021					 ; OUTPUT -> AX	= hex value
1  4022
1  4023	00000E45  8A E0				 mov	 ah,al
1  4024	00000E47  80 E4	0F			 and	 ah,0fh
1  4025	00000E4A  80 FC	09			 cmp	 ah,9
1  4026	00000E4D  76 03				 jbe	 cifra0
1  4027	00000E4F  80 C4	07				 add	 ah,'A'-'9'-1
1  4028	00000E52				 cifra0:
1  4029	00000E52  80 C4	30			 add	 ah,'0'
1  4030	00000E55  C0 E8	04			 shr	 al,4
1  4031	00000E58  3C 09				 cmp	 al,9
1  4032	00000E5A  76 02				 jbe	 cifra1
1  4033	00000E5C  04 07					 add	 al,'A'-'9'-1
1  4034	00000E5E				 cifra1:
1  4035	00000E5E  04 30				 add	 al,'0'
1  4036	00000E60  C3				 ret
1  4037
1  4038	00000E61			 bin_to_hex	 endp
1  4039
1  4040					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4041
   4042					 INCLUDE		 cback32.inc	 ; call-back's 32 bit code
1  4043	00000E61			 callback_pm:
1  4044	00000E61  FA				 cli
1  4045						 ; preparamos los datos	de entrada para	el call-back
1  4046	00000E62  66| 2E: A1 00000004r		 mov	 ax,cs:D32_SEL
1  4047	00000E69  8E D8				 mov	 ds,ax
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 72
DarkX.ASM



1  4048	00000E6B  8E D0				 mov	 ss,ax
1  4049	00000E6D  BB 00000000s			 mov	 ebx,txcode
1  4050	00000E72  C1 E3	04			 shl	 ebx,4
1  4051						 ASSUME	 DS:txcode
1  4052						 ; puntero a la	estructura de call-backs
1  4053	00000E75  0F B7	83 00000690r		 movzx	 eax,word ptr [ebx+callback_code]
1  4054						 ; DS:ESI -> real mode stack frame (SS:SP)
1  4055	00000E7C  0F B7	8B 00000692r		 movzx	 ecx,word ptr [ebx+pila_real]	; real mode SP
1  4056	00000E83  0F B7	B3 00000694r		 movzx	 esi,word ptr [ebx+pila_real+2]	; real mode SS
1  4057	00000E8A  8B D6				 mov	 edx,esi
1  4058	00000E8C  8B E9				 mov	 ebp,ecx
1  4059	00000E8E  C1 E6	04			 shl	 esi,4
1  4060	00000E91  03 F1				 add	 esi,ecx
1  4061						 ; ES:EDI -> real mode call structure
1  4062	00000E93  B9 00000000s			 mov	 ecx,txdata
1  4063	00000E98  C1 E1	04			 shl	 ecx,4
1  4064						 ASSUME	 DS:txdata
1  4065	00000E9B  8B BC	01 00000D08r		 mov	 edi,[ecx+eax+callback_data.rm_call_struc.loffset]   ; real mode
1  4066	00000EA2  8E 84	01 00000D0Cr		 mov	 es,[ecx+eax+callback_data.rm_call_struc.selector]   ; call struc.
1  4067						 ; SS:SP de real y CS:IP del call-back a la estructura
1  4068	00000EA9  66| 26: 89 6F	2E		 mov	 es:[edi.rm_sp],bp
1  4069	00000EAE  66| 26: 89 57	30		 mov	 es:[edi.rm_ss],dx
1  4070	00000EB3  66| 8B 94 01	      +		 mov	 dx,[ecx+eax+callback_data.rm_entry_point]
   4071		  00000D00r
1  4072	00000EBB  66| 26: 89 57	2A		 mov	 es:[edi.rm_ip],dx
1  4073	00000EC0  66| 26: C7 47	2C    +		 mov	 es:[edi.rm_cs],txcode
   4074		  0000s
1  4075						 ; SS:ESP -> locked protected mode API stack
1  4076					 ;	  mov	  esp,txpila
1  4077					 ;	  shl	  esp,4
1  4078					 ;	  add	  esp,size tx_pila-4*(PM_STACKSIZE/2)  ; we are	not using stack	before this
1  4079	00000EC7  8B A1	00000520r		 mov	 esp,[ecx+pm_esp]
1  4080	00000ECD  8E 91	0000037Er		 mov	 ss,[ecx+pm_ss]
1  4081	00000ED3  1E 53				 push	 ds ebx
1  4082	00000ED5  9C				 pushfd		 ; procedure will return with IRETD
1  4083	00000ED6  FF 9C	01 00000D02r		 call	 fword ptr [ecx+eax+callback_data.pm_proc_to_call]
1  4084
1  4085						 ; ES:EDI -> real mode call structure to restore
1  4086	00000EDD  5B 1F				 pop	 ebx ds
1  4087						 ; preparamos CS,IP,SS,SP y FLAGS de la	estructura para	modo real
1  4088						 ASSUME	 DS:txcode
1  4089	00000EDF  26: 8B 47 2A			 mov	 eax,dword ptr es:[edi.rm_ip]
1  4090	00000EE3  89 83	00000686r		 mov	 [ebx+new_code],eax
1  4091	00000EE9  26: 8B 47 2E			 mov	 eax,dword ptr es:[edi.rm_sp]
1  4092	00000EED  89 83	0000068Ar		 mov	 [ebx+new_stack],eax
1  4093	00000EF3  66| 26: 8B 47	20		 mov	 ax,es:[edi.rm_flags]
1  4094	00000EF8  66| 89 83 0000068Er		 mov	 [ebx+new_flags],ax
1  4095
1  4096						 ; saltamos a modo real	de nuevo
1  4097	00000EFF  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset cback16_return
   4098		  0645r
1  4099	00000F08  66| C7 83 0000001Br +		 mov	 word ptr [ebx+saltito+3],txcode
   4100		  0000s
1  4101						 ASSUME	 DS:txdata
1  4102	00000F11  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  4103	00000F18  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4104	00000F1F  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 73
DarkX.ASM



1  4105	00000F26  67| FF 36 0538r		 push	 dword ptr ret_real_address
1  4106	00000F2B  CB				 retf
1  4107
   4108					 INCLUDE		 int21oem.inc
1  4109					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4110					 ; INT 21h Standard DOS	Services
1  4111					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4112	00000F2C			 tx_int21h:
1  4113	00000F2C  80 FC	3F				 cmp	 ah,3Fh			 ; read	from file
1  4114	00000F2F  0F 84	00000188			 jz	 read_file
1  4115	00000F35  80 FC	40				 cmp	 ah,40h			 ; write to file
1  4116	00000F38  0F 84	00000222			 jz	 write_file
1  4117	00000F3E  80 FC	3D				 cmp	 ah,3Dh			 ; open	existing file
1  4118	00000F41  0F 84	0000014B			 jz	 generic_file_service
1  4119	00000F47  80 FC	3C				 cmp	 ah,3Ch			 ; create file
1  4120	00000F4A  0F 84	00000142			 jz	 generic_file_service
1  4121	00000F50  80 FC	39				 cmp	 ah,39h			 ; create subdirectory
1  4122	00000F53  0F 84	00000139			 jz	 generic_file_service
1  4123	00000F59  80 FC	3A				 cmp	 ah,3Ah			 ; remove subdirectory
1  4124	00000F5C  0F 84	00000130			 jz	 generic_file_service
1  4125	00000F62  80 FC	3B				 cmp	 ah,3Bh			 ; change subdirectory
1  4126	00000F65  0F 84	00000127			 jz	 generic_file_service
1  4127	00000F6B  80 FC	41				 cmp	 ah,41h			 ; delete file
1  4128	00000F6E  0F 84	0000011E			 jz	 generic_file_service
1  4129	00000F74  66| 3D 4300				 cmp	 ax,4300h		 ; get file attributes
1  4130	00000F78  0F 84	00000114			 jz	 generic_file_service
1  4131	00000F7E  66| 3D 4301				 cmp	 ax,4301h		 ; set file attributes
1  4132	00000F82  0F 84	0000010A			 jz	 generic_file_service
1  4133	00000F88  80 FC	4E				 cmp	 ah,4Eh			 ; find	first matching file
1  4134	00000F8B  0F 84	00000101			 jz	 generic_file_service
1  4135	00000F91  80 FC	5B				 cmp	 ah,5Bh			 ; create new file
1  4136	00000F94  0F 84	000000F8			 jz	 generic_file_service
1  4137
1  4138	00000F9A  80 FC	09				 cmp	 ah,9			 ; write to standard output
1  4139	00000F9D  0F 84	00000098			 je	 print_string
1  4140	00000FA3  80 FC	62				 cmp	 ah,62h			 ; get PSP selector
1  4141	00000FA6  0F 84	0000024E			 jz	 get_psp_sel
1  4142	00000FAC  80 FC	4C				 cmp	 ah,4Ch			 ; end program
1  4143	00000FAF  74 22					 je	 fin_programa
1  4144	00000FB1  1E					 push	 ds
1  4145	00000FB2  2E: 8E 1D 0000000Cr			 mov	 ds,cs:D16_SEL
1  4146							 ASSUME	 DS:txdata
1  4147	00000FB9  67| F6 06 0341r 02			 test	 system_type,2
1  4148	00000FBF  1F					 pop	 ds
1  4149	00000FC0  75 08					 jnz	 dpmi_int21_pass
1  4150	00000FC2  50					 push	 eax	    ; si no, la	tratamos con el	handler	normal
1  4151	00000FC3  B0 21					 mov	 al,21h
1  4152	00000FC5  E9 FFFFF9B0				 jmp	 real_int
1  4153
1  4154	00000FCA					 dpmi_int21_pass:
1  4155	00000FCA  9C					 pushfd
1  4156	00000FCB  2E: FF 1D 00001FBDr			 call	 fword ptr cs:[idt+21h*6]
1  4157	00000FD2  CF					 iretd
1  4158
1  4159					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4160					 ; DOS Program Termination Service
1  4161					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 74
DarkX.ASM



1  4162	00000FD3			 fin_programa:
1  4163	00000FD3  83 C4	0C				 add	 esp,3*4
1  4164	00000FD6  9C					 pushfd
1  4165	00000FD7  2E: FF 35 00000000r			 push	 dword ptr cs:C32_sel
1  4166							 pushd	 salida
2  4167	00000FDE  68				 db 68h
2  4168	00000FDF  1E24r	0000			 dw offset salida,0
1  4169	00000FE3  CF					 iretd
1  4170
1  4171					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4172					 ; Common DOS RM Call
1  4173					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4174	00000FE4			 dos_int	 proc
1  4175					 ; INPUT -> BP = DS/ES value ; Registers as needed by INT 21H
1  4176	00000FE4  06				 push	 es
1  4177	00000FE5  16				 push	 ss
1  4178	00000FE6  07				 pop	 es
1  4179	00000FE7  33 FF				 xor	 edi,edi
1  4180	00000FE9  57				 push	 edi
1  4181	00000FEA  57				 push	 edi
1  4182	00000FEB  57				 push	 edi
1  4183	00000FEC  66| 55			 push	 bp
1  4184	00000FEE  66| 55			 push	 bp
1  4185	00000FF0  66				 db	 66h		 ; <----- para WORD en segmento	de 32 bits
1  4186	00000FF1  66| 9C			 pushf
1  4187	00000FF3  60				 pushad
1  4188	00000FF4  8B FC				 mov	 edi,esp
1  4189	00000FF6  66| B8 0300			 mov	 ax,300h
1  4190	00000FFA  B3 21				 mov	 bl,21h
1  4191	00000FFC  33 C9				 xor	 ecx,ecx
1  4192	00000FFE  CD 31				 int	 31h
1  4193	00001000  61				 popad
1  4194	00001001  66| 9D			 popf
1  4195	00001003  8D 64	24 10			 lea	 esp,[esp+4*4]	 ; as¡ no modificamos los flags
1  4196	00001007  07				 pop	 es
1  4197	00001008  C3				 ret
1  4198	00001009			 dos_int	 endp
1  4199
1  4200	00001009			 copy_file_name	 proc
1  4201					 ; INPUT -> DS:EDX -> ASCIIZ string
1  4202	00001009  52 06	57 51 50		 push	 edx es	edi ecx	eax
1  4203						 ; copiamos el nombre del archivo a 'print_buffer'
1  4204	0000100E  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4205	00001015  BF 00000000s			 mov	 edi,txcode32
1  4206	0000101A  C1 E7	04			 shl	 edi,4
1  4207	0000101D  81 C7	00003869r		 add	 edi,offset print_buffer
1  4208	00001023  B9 00000080			 mov	 ecx,128
1  4209	00001028				 copy_name:
1  4210	00001028  8A 02					 mov	 al,[edx]
1  4211	0000102A  26: 88 07				 mov	 es:[edi],al
1  4212	0000102D  0A C0					 or	 al,al
1  4213	0000102F  74 04					 jz	 end_of_name
1  4214	00001031  47					 inc	 edi
1  4215	00001032  42					 inc	 edx
1  4216	00001033  E2 F3				 loop	 copy_name
1  4217	00001035				 end_of_name:
1  4218	00001035  58 59	5F 07 5A		 pop	 eax ecx edi es	edx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 75
DarkX.ASM



1  4219	0000103A  C3				 ret
1  4220	0000103B			 copy_file_name	 endp
1  4221
1  4222					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4223					 ; DOS Write to	Standard Device	Service
1  4224					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4225	0000103B			 print_string:
1  4226	0000103B  60					 pushad
1  4227	0000103C  06					 push	 es
1  4228	0000103D  8B F2					 mov	 esi,edx
1  4229	0000103F					 print_another_piece:
1  4230	0000103F  2E: 8E 05 00000004r			 mov	 es,cs:D32_SEL
1  4231	00001046  BF 00000000s				 mov	 edi,txcode32
1  4232	0000104B  C1 E7	04				 shl	 edi,4
1  4233	0000104E  81 C7	00003869r			 add	 edi,offset print_buffer
1  4234	00001054  B9 000007D1				 mov	 ecx,80*25+1
1  4235	00001059					 copy_string:
1  4236	00001059  80 3E	24					 cmp	 byte ptr [esi],'$'
1  4237	0000105C  74 1C						 je	 string_copied
1  4238	0000105E  A4						 movsb
1  4239	0000105F  E2 F8					 loop	 copy_string
1  4240	00001061  26: C6 07 24				 mov	 byte ptr es:[edi],'$'
1  4241	00001065  57					 push	 edi
1  4242	00001066  B4 09					 mov	 ah,9
1  4243	00001068  BA 00003869r				 mov	 edx,offset print_buffer
1  4244	0000106D  BD 00000000s				 mov	 ebp,txcode32
1  4245	00001072  E8 FFFFFF6D				 call	 dos_int
1  4246	00001077  5F					 pop	 edi
1  4247	00001078  EB C5					 jmp	 print_another_piece
1  4248	0000107A					 string_copied:
1  4249	0000107A  26: C6 07 24				 mov	 byte ptr es:[edi],'$'
1  4250	0000107E  B4 09					 mov	 ah,9
1  4251	00001080  BA 00003869r				 mov	 edx,offset print_buffer
1  4252	00001085  BD 00000000s				 mov	 ebp,txcode32
1  4253	0000108A  E8 FFFFFF55				 call	 dos_int
1  4254	0000108F  07					 pop	 es
1  4255	00001090  61					 popad
1  4256	00001091  CF					 iretd
1  4257
1  4258					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4259					 ; Disk	Services
1  4260					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4261	00001092			 generic_file_service:
1  4262					 ; Translates DS:EDX to	DS:DX in DOS memory passing/returning all registers
1  4263					 ; to/from DOS
1  4264	00001092  60				 pushad
1  4265	00001093  06				 push	 es
1  4266	00001094  E8 FFFFFF70			 call	 copy_file_name
1  4267	00001099  BA 00003869r			 mov	 edx,offset print_buffer
1  4268	0000109E  BD 00000000s			 mov	 ebp,txcode32
1  4269	000010A3  E8 FFFFFF3C			 call	 dos_int
1  4270	000010A8  9C				 pushfd
1  4271	000010A9  59				 pop	 ecx
1  4272	000010AA  80 E1	01			 and	 cl,1
1  4273	000010AD  80 64	24 2C FE		 and	 byte ptr ss:[esp+11*4],0FEh
1  4274	000010B2  08 4C	24 2C			 or	 byte ptr ss:[esp+11*4],cl
1  4275	000010B6  89 44	24 20			 mov	 ss:[esp+8*4],eax
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 76
DarkX.ASM



1  4276	000010BA  07				 pop	 es
1  4277	000010BB  61				 popad
1  4278	000010BC  CF				 iretd
1  4279
1  4280	000010BD			 read_file:
1  4281	000010BD  80 64	24 08 FE		 and	 byte ptr ss:[esp+2*4],0FEh
1  4282	000010C2  60				 pushad
1  4283	000010C3  06 1E				 push	 es ds
1  4284	000010C5  1E				 push	 ds
1  4285	000010C6  07				 pop	 es
1  4286	000010C7  51				 push	 ecx
1  4287	000010C8  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  4288	000010CF  8B FA				 mov	 edi,edx
1  4289	000010D1  33 C0				 xor	 eax,eax	 ; INICIO -> 0 bytes le¡dos
1  4290	000010D3  C1 E9	0F			 shr	 ecx,15		 ; 32Kb
1  4291	000010D6  0B C9				 or	 ecx,ecx
1  4292	000010D8  74 1D				 jz	 dont_read_blocks
1  4293	000010DA				 read_32K_blocks:
1  4294	000010DA  50 51					 push	 eax ecx
1  4295	000010DC  66| B9 8000				 mov	 cx,8000h
1  4296	000010E0  E8 0000003F				 call	 read_block
1  4297	000010E5  59					 pop	 ecx
1  4298	000010E6  72 34					 jc	 read_error
1  4299	000010E8  3D 00008000				 cmp	 eax,8000h
1  4300	000010ED  75 28					 jnz	 no_resto3
1  4301	000010EF  58					 pop	 eax
1  4302	000010F0  05 00008000				 add	 eax,8000h
1  4303	000010F5  E2 E3				 loop	 read_32K_blocks
1  4304	000010F7				 dont_read_blocks:
1  4305	000010F7  59				 pop	 ecx
1  4306	000010F8  51				 push	 ecx
1  4307	000010F9  81 E1	00007FFF		 and	 ecx,7FFFh
1  4308	000010FF  0B C9				 or	 ecx,ecx
1  4309	00001101  74 0B				 jz	 no_resto2
1  4310	00001103  50				 push	 eax
1  4311	00001104  E8 0000001B			 call	 read_block
1  4312	00001109  72 11				 jc	 read_error
1  4313	0000110B  5B				 pop	 ebx
1  4314	0000110C  03 C3				 add	 eax,ebx
1  4315	0000110E				 no_resto2:
1  4316	0000110E  59				 pop	 ecx
1  4317	0000110F  1F 07				 pop	 ds es
1  4318	00001111  89 44	24 1C			 mov	 ss:[esp+7*4],eax
1  4319	00001115  61				 popad
1  4320	00001116  CF				 iretd
1  4321
1  4322	00001117				 no_resto3:
1  4323	00001117  5A				 pop	 edx
1  4324	00001118  03 C2				 add	 eax,edx
1  4325					 ;	  pop	  ecx
1  4326	0000111A  EB F2				 jmp	 no_resto2
1  4327
1  4328	0000111C				 read_error:
1  4329	0000111C  5B				 pop	 ebx
1  4330	0000111D  80 4C	24 34 01		 or	 byte ptr ss:[esp+13*4],1
1  4331	00001122  EB EA				 jmp	 no_resto2
1  4332
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 77
DarkX.ASM



1  4333	00001124			 read_block	 proc
1  4334	00001124  BA 00000000r			 mov	 edx,offset disk_buffer
1  4335	00001129  BD 00000000s			 mov	 ebp,disk
1  4336	0000112E  66| B8 3F00			 mov	 ax,3F00h
1  4337	00001132  57				 push	 edi
1  4338	00001133  E8 FFFFFEAC			 call	 dos_int
1  4339	00001138  5F				 pop	 edi
1  4340	00001139  72 24				 jc	 no_resto
1  4341	0000113B  0F B7	C0			 movzx	 eax,ax
1  4342	0000113E  BE 00000000s			 mov	 esi,disk
1  4343	00001143  C1 E6	04			 shl	 esi,4
1  4344	00001146  81 C6	00000000r		 add	 esi,offset disk_buffer
1  4345	0000114C  8B C8				 mov	 ecx,eax
1  4346	0000114E  C1 E9	02			 shr	 ecx,2
1  4347	00001151  FC				 cld
1  4348	00001152  F3> A5			 rep	 movsd
1  4349	00001154  8B C8				 mov	 ecx,eax
1  4350	00001156  83 E1	03			 and	 ecx,3
1  4351	00001159  0B C9				 or	 ecx,ecx
1  4352	0000115B  74 02				 jz	 no_resto
1  4353	0000115D  F3> A4			 rep	 movsb
1  4354	0000115F				 no_resto:
1  4355	0000115F  C3				 ret
1  4356	00001160			 read_block	 endp
1  4357
1  4358	00001160			 write_file:
1  4359	00001160  80 64	24 08 FE		 and	 byte ptr ss:[esp+2*4],0FEh
1  4360	00001165  60				 pushad
1  4361	00001166  06 1E				 push	 es ds
1  4362	00001168  51				 push	 ecx
1  4363	00001169  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4364	00001170  8B F2				 mov	 esi,edx
1  4365	00001172  33 C0				 xor	 eax,eax	 ; INICIO -> 0 bytes le¡dos
1  4366	00001174  C1 E9	0F			 shr	 ecx,15		 ; 32Kb
1  4367	00001177  0B C9				 or	 ecx,ecx
1  4368	00001179  74 1E				 jz	 dont_write_blocks
1  4369	0000117B				 write_32K_blocks:
1  4370	0000117B  50 51					 push	 eax ecx
1  4371	0000117D  B9 00008000				 mov	 ecx,8000h
1  4372	00001182  E8 0000003F				 call	 write_block
1  4373	00001187  59					 pop	 ecx
1  4374	00001188  72 34					 jc	 write_error
1  4375	0000118A  3D 00008000				 cmp	 eax,8000h
1  4376	0000118F  75 28					 jnz	 no_resto5
1  4377	00001191  58					 pop	 eax
1  4378	00001192  05 00008000				 add	 eax,8000h
1  4379	00001197  E2 E2				 loop	 write_32K_blocks
1  4380	00001199				 dont_write_blocks:
1  4381	00001199  59				 pop	 ecx
1  4382	0000119A  51				 push	 ecx
1  4383	0000119B  81 E1	00007FFF		 and	 ecx,7FFFh
1  4384	000011A1  0B C9				 or	 ecx,ecx
1  4385	000011A3  74 0B				 jz	 no_resto4
1  4386	000011A5  50				 push	 eax
1  4387	000011A6  E8 0000001B			 call	 write_block
1  4388	000011AB  72 11				 jc	 write_error
1  4389	000011AD  5B				 pop	 ebx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 78
DarkX.ASM



1  4390	000011AE  03 C3				 add	 eax,ebx
1  4391	000011B0				 no_resto4:
1  4392	000011B0  59				 pop	 ecx
1  4393	000011B1  1F 07				 pop	 ds es
1  4394	000011B3  89 44	24 1C			 mov	 ss:[esp+7*4],eax
1  4395	000011B7  61				 popad
1  4396	000011B8  CF				 iretd
1  4397
1  4398	000011B9				 no_resto5:
1  4399	000011B9  5A				 pop	 edx
1  4400	000011BA  03 C2				 add	 eax,edx
1  4401	000011BC  EB F2				 jmp	 no_resto4
1  4402
1  4403	000011BE				 write_error:
1  4404	000011BE  5B				 pop	 ebx
1  4405	000011BF  80 4C	24 34 01		 or	 byte ptr ss:[esp+13*4],1
1  4406	000011C4  EB EA				 jmp	 no_resto4
1  4407
1  4408	000011C6			 write_block	  proc
1  4409	000011C6  BF 00000000s			 mov	 edi,disk
1  4410	000011CB  C1 E7	04			 shl	 edi,4
1  4411	000011CE  81 C7	00000000r		 add	 edi,offset disk_buffer
1  4412	000011D4  51				 push	 ecx
1  4413	000011D5  C1 E9	02			 shr	 ecx,2
1  4414	000011D8  FC				 cld
1  4415	000011D9  F3> A5			 rep	 movsd
1  4416	000011DB  58				 pop	 eax
1  4417	000011DC  8B C8				 mov	 ecx,eax
1  4418	000011DE  83 E1	03			 and	 ecx,3
1  4419	000011E1  F3> A4			 rep	 movsb
1  4420	000011E3  BA 00000000r			 mov	 edx,offset disk_buffer
1  4421	000011E8  8B C8				 mov	 ecx,eax
1  4422	000011EA  BD 00000000s			 mov	 ebp,disk
1  4423	000011EF  B4 40				 mov	 ah,40h
1  4424	000011F1  E8 FFFFFDEE			 call	 dos_int
1  4425	000011F6  0F B7	C0			 movzx	 eax,ax
1  4426	000011F9  C3				 ret
1  4427	000011FA			 write_block	  endp
1  4428
1  4429	000011FA			 get_psp_sel:
1  4430	000011FA  1E				 push	 ds
1  4431	000011FB  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  4432	00001202  66| 67| 8B 1E	0335r		 mov	 bx,psp_selector
1  4433	00001208  1F				 pop	 ds
1  4434	00001209  CF				 iretd
1  4435
   4436
   4437					 INCLUDE		 memmgr.inc	 ; Memory Manager by Teknik
1  4438					 ; NOTE: All procedures	are called with	DS = 4Gb data segment
1  4439
1  4440					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4441					 ; file: memmgr.asm
1  4442					 ;
1  4443					 ;  Memory manager for Trouble's DOS extender.
1  4444					 ;
1  4445					 ;	 by Teknik/Trouble, November of	1997
1  4446					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 79
DarkX.ASM



1  4447
1  4448					 ;  All	block lengths are a multiple of	4.
1  4449
1  4450	0000120A			 THEAP	 struc
1  4451
1  4452	00000000  01*(????????)		 start	 dd	 ?		 ; ptr to first	block of heap
1  4453	00000004  01*(????????)		 hlen	 dd	 ?		 ; length of heap
1  4454
1  4455	00000008				 ends
1  4456
1  4457	0000120A			 TBLOCK	 struc
1  4458
1  4459	00000000  01*(????????)		 blen	 dd	 ?		 ; block length, without this header
1  4460	00000004  01*(??)		 status	 db	 ?		 ; 'A' allocated, 'F' free
1  4461	00000005  01*(??)		 more	 db	 ?		 ; 'M' more blocks, 'E'	end of heap
1  4462	00000006  01*(????)		 sign	 dw	 ?		 ; block signature "TX", not reversed as TASM does
1  4463	00000008  01*(????????)		 prev	 dd	 ?		 ; offset of previous block header, origin DS
1  4464	0000000C  01*(????????)		 next	 dd	 ?		 ; offset of next block	header,	origin DS
1  4465
1  4466	00000010				 ends
1  4467
1  4468					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4469					 ; Initializes heap. All other procedures assume that this is the first	proc
1  4470					 ; called, just	before doing something.
1  4471					 ;
1  4472					 ;  parameters:
1  4473					 ;    eax - ptr	to heap	info (8	bytes required)
1  4474					 ;    ebx - address of memory (first block)
1  4475					 ;    ecx - length of heap (including headers) (=length	of first block)
1  4476					 ;
1  4477					 ;  modifies:
1  4478					 ;    ecx, eax,	ebx, edx
1  4479					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4480
1  4481	0000120A			 initheap	 proc
1  4482
1  4483	0000120A  8B D3				 mov	 edx, ebx		 ; align heap start...
1  4484	0000120C  83 C3	03			 add	 ebx, 3
1  4485	0000120F  80 E3	FC			 and	 bl, 0fch
1  4486	00001212  2B D3				 sub	 edx, ebx		 ; ...and adjust the length too
1  4487	00001214  2B CA				 sub	 ecx, edx
1  4488	00001216  83 C1	03			 add	 ecx, 3
1  4489	00001219  80 E1	FC			 and	 cl, 0fch
1  4490
1  4491	0000121C  89 48	04			 mov	 [eax.hlen], ecx
1  4492	0000121F  83 E9	10			 sub	 ecx, 16
1  4493	00001222  89 0B				 mov	 [ebx.blen], ecx
1  4494	00001224  C7 43	04 58544546		 mov	 dword ptr [ebx.status], 'XTEF'	 ; free, end, signature...
1  4495	0000122B  33 C9				 xor	 ecx, ecx		 ; ... (TASM reverses this strings :( )
1  4496	0000122D  89 4B	08			 mov	 [ebx.prev], ecx
1  4497	00001230  89 4B	0C			 mov	 [ebx.next], ecx
1  4498
1  4499	00001233  89 18				 mov	 [eax.start], ebx	 ; saves ptr to	the first block
1  4500
1  4501	00001235  C3				 ret
1  4502
1  4503	00001236			 initheap	 endp
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 80
DarkX.ASM



1  4504
1  4505					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4506					 ; Adds	another	block of heap, as heap may not be continuous. This can be
1  4507					 ; done	at any time.
1  4508					 ;
1  4509					 ;  parameters:
1  4510					 ;    eax - ptr	to heap	info
1  4511					 ;    ebx - address of the new block
1  4512					 ;    ecx - length of new block	(including headers)
1  4513					 ;
1  4514					 ;  modifies:
1  4515					 ;    eax, ebx,	ecx, edx
1  4516					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4517
1  4518	00001236			 addheap proc
1  4519
1  4520	00001236  8B D3				 mov	 edx, ebx		 ; align new block start...
1  4521	00001238  83 C3	03			 add	 ebx, 3
1  4522	0000123B  80 E3	FC			 and	 bl, 0fch
1  4523	0000123E  2B D3				 sub	 edx, ebx		 ; ...and adjust the length too
1  4524	00001240  2B CA				 sub	 ecx, edx
1  4525	00001242  83 C1	03			 add	 ecx, 3
1  4526	00001245  80 E1	FC			 and	 cl, 0fch
1  4527
1  4528	00001248  8B 10				 mov	 edx, [eax.start]
1  4529	0000124A  01 48	04			 add	 [eax.hlen], ecx	 ; calc	new heap length
1  4530	0000124D  80 7A	05 45		 ah_lp:	 cmp	 [edx.more], 'E'	 ; searchs last	block
1  4531	00001251  74 05				 je	 ah_add
1  4532	00001253  8B 52	0C			 mov	 edx, [edx.next]
1  4533	00001256  EB F5				 jmp	 short ah_lp
1  4534
1  4535	00001258  C6 42	05 4D		 ah_add: mov	 [edx.more], 'M'	 ; add the new free block
1  4536	0000125C  89 5A	0C			 mov	 [edx.next], ebx
1  4537	0000125F  83 E9	10			 sub	 ecx, 16
1  4538	00001262  89 0B				 mov	 [ebx.blen], ecx
1  4539	00001264  C7 43	04 58544546		 mov	 dword ptr [ebx.status], 'XTEF'
1  4540	0000126B  89 53	08			 mov	 [ebx.prev], edx
1  4541	0000126E  C7 43	0C 00000000		 mov	 [ebx.next], 0
1  4542
1  4543	00001275  83 C3	10			 add	 ebx, 16		 ; ebx -> ptr to *data area*
1  4544	00001278  E8 0000005A			 call	 free			 ; quick way to	possibly collide blocks
1  4545
1  4546	0000127D  C3				 ret
1  4547
1  4548	0000127E			 addheap endp
1  4549
1  4550					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4551					 ; Allocates a memory block.
1  4552					 ;
1  4553					 ;  parameters:
1  4554					 ;    eax - ptr	to heap	info
1  4555					 ;    ecx - length of block to allocate	in bytes
1  4556					 ;
1  4557					 ;  returns:
1  4558					 ;    ebx - ptr	to memory or NULL if not enought memory
1  4559					 ;    ecx - real length	of block (rounded up to	a four multiple)
1  4560					 ;
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 81
DarkX.ASM



1  4561					 ;  modifies:
1  4562					 ;    eax
1  4563					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4564
1  4565	0000127E			 malloc	 proc
1  4566
1  4567	0000127E  8B 18				 mov	 ebx, [eax.start]	 ; search a free block
1  4568	00001280  83 C1	03			 add	 ecx, 3			 ; round up to multiple	of 4
1  4569	00001283  80 E1	FC			 and	 cl, 0fch
1  4570	00001286  80 7B	04 46		 m_lp:	 cmp	 byte ptr [ebx.status],	'F'
1  4571	0000128A  75 3D				 jne	 m_next
1  4572	0000128C  39 0B				 cmp	 dword ptr [ebx.blen], ecx
1  4573	0000128E  72 39				 jb	 m_next
1  4574
1  4575	00001290  83 C1	10			 add	 ecx, 16		 ; allocates block
1  4576	00001293  39 0B				 cmp	 dword ptr [ebx.blen], ecx    ;	if the remainder is less than
1  4577	00001295  72 28				 jb	 dont_split		 ; ... 16 don't	split the block
1  4578
1  4579	00001297  8B 03				 mov	 eax, [ebx.blen]	 ; ebx + ecx ->	ptr to new block
1  4580	00001299  2B C1				 sub	 eax, ecx		 ; ecx = len of	allocated block	+ 16
1  4581	0000129B  89 04	0B			 mov	 [ebx +	ecx.blen], eax
1  4582	0000129E  8B 43	04			 mov	 eax, dword ptr	[ebx.status]	 ; move	status,	more and sign
1  4583	000012A1  89 44	0B 04			 mov	 dword ptr [ebx	+ ecx.status], eax
1  4584	000012A5  89 5C	0B 08			 mov	 [ebx +	ecx.prev], ebx
1  4585	000012A9  8B 43	0C			 mov	 eax, [ebx.next]
1  4586	000012AC  89 44	0B 0C			 mov	 [ebx +	ecx.next], eax
1  4587
1  4588	000012B0  C6 43	05 4D			 mov	 [ebx.more], 'M'	 ; more	blocks
1  4589	000012B4  89 5B	0C			 mov	 [ebx.next], ebx	 ; adjust ptr to next block
1  4590	000012B7  01 4B	0C			 add	 [ebx.next], ecx
1  4591
1  4592	000012BA  83 E9	10			 sub	 ecx, 16
1  4593	000012BD  89 0B				 mov	 [ebx.blen], ecx
1  4594
1  4595	000012BF			 dont_split:
1  4596
1  4597	000012BF  C6 43	04 41			 mov	 [ebx.status], 'A'	 ; allocated block
1  4598
1  4599	000012C3  8B 0B				 mov	 ecx, [ebx.blen]	 ; ecx -> length of block
1  4600	000012C5  83 C3	10			 add	 ebx, 16		 ; ebx -> data area of block
1  4601
1  4602	000012C8  C3				 ret
1  4603
1  4604	000012C9  80 7B	05 4D		 m_next: cmp	 byte ptr [ebx.more], 'M'
1  4605	000012CD  75 05				 jne	 m_end
1  4606	000012CF  8B 5B	0C			 mov	 ebx, [ebx.next]
1  4607	000012D2  EB B2				 jmp	 short m_lp
1  4608
1  4609	000012D4  33 DB			 m_end:	 xor	 ebx, ebx		 ; not enought memory
1  4610
1  4611	000012D6  C3				 ret
1  4612
1  4613	000012D7			 malloc	 endp
1  4614
1  4615					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4616					 ; Coalesces two memory	blocks.
1  4617					 ;
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 82
DarkX.ASM



1  4618					 ;  parameters:
1  4619					 ;    eax - ptr	to lower block
1  4620					 ;    ebx - ptr	to upper block
1  4621					 ;
1  4622					 ;  modifies:
1  4623					 ;    ecx
1  4624					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4625
1  4626					 coalesce macro	label
1  4627
1  4628						 mov	 ecx, eax		 ; are two blocks adjacent?
1  4629						 add	 ecx, [eax.blen]
1  4630						 add	 ecx, 16
1  4631						 cmp	 ecx, ebx
1  4632						 jne	 label
1  4633
1  4634						 mov	 cl, [ebx.more]		 ; copy	more flag
1  4635						 mov	 [eax.more], cl
1  4636						 mov	 ecx, [ebx.next]	 ; relink blocks
1  4637						 mov	 [eax.next], ecx
1  4638						 mov	 [ecx.prev], eax
1  4639						 mov	 ecx, [ebx.blen]	 ; readjust length
1  4640						 add	 ecx, 16
1  4641						 add	 [eax.blen], ecx
1  4642
1  4643						 endm
1  4644
1  4645					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4646					 ; Frees a memory block.
1  4647					 ;
1  4648					 ;  parameters:
1  4649					 ;    ebx - ptr	to data	area of	block
1  4650					 ;
1  4651					 ;  modifies:
1  4652					 ;    eax, ecx,	ebx
1  4653					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4654
1  4655	000012D7			 free	 proc
1  4656
1  4657	000012D7  83 EB	10			 sub	 ebx, 16		 ; ebx -> ptr to block header
1  4658
1  4659	000012DA  C6 43	04 46			 mov	 [ebx.status], 'F'	 ; free	it
1  4660
1  4661	000012DE  8B 43	08			 mov	 eax, [ebx.prev]	 ; coalesce with previous block
1  4662	000012E1  0B C0				 or	 eax, eax
1  4663	000012E3  74 29				 jz	 f_next
1  4664	000012E5  80 78	04 46			 cmp	 [eax.status], 'F'	 ; is free? ...
1  4665	000012E9  75 23				 jne	 f_next
1  4666						 coalesce f_next		 ; ... yes, coalesce it
2  4667	000012EB  8B C8				 mov	 ecx, eax		 ; are two blocks adjacent?
2  4668	000012ED  03 08				 add	 ecx, [eax.blen]
2  4669	000012EF  83 C1	10			 add	 ecx, 16
2  4670	000012F2  3B CB				 cmp	 ecx, ebx
2  4671	000012F4  75 18				 jne	 f_next
2  4672	000012F6  8A 4B	05			 mov	 cl, [ebx.more]		 ; copy	more flag
2  4673	000012F9  88 48	05			 mov	 [eax.more], cl
2  4674	000012FC  8B 4B	0C			 mov	 ecx, [ebx.next]	 ; relink blocks
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 83
DarkX.ASM



2  4675	000012FF  89 48	0C			 mov	 [eax.next], ecx
2  4676	00001302  89 41	08			 mov	 [ecx.prev], eax
2  4677	00001305  8B 0B				 mov	 ecx, [ebx.blen]	 ; readjust length
2  4678	00001307  83 C1	10			 add	 ecx, 16
2  4679	0000130A  01 08				 add	 [eax.blen], ecx
1  4680	0000130C  8B D8				 mov	 ebx, eax		 ; now we have only first free block
1  4681
1  4682	0000130E  8B 43	0C		 f_next: mov	 eax, [ebx.next]	 ; coalesce with next block
1  4683	00001311  0B C0				 or	 eax, eax
1  4684	00001313  74 28				 jz	 f_end
1  4685	00001315  80 78	04 46			 cmp	 [eax.status], 'F'	 ; is free? ...
1  4686	00001319  75 22				 jne	 f_end
1  4687	0000131B  93				 xchg	 eax, ebx
1  4688						 coalesce f_end			 ; ... yes, coalesce it
2  4689	0000131C  8B C8				 mov	 ecx, eax		 ; are two blocks adjacent?
2  4690	0000131E  03 08				 add	 ecx, [eax.blen]
2  4691	00001320  83 C1	10			 add	 ecx, 16
2  4692	00001323  3B CB				 cmp	 ecx, ebx
2  4693	00001325  75 16				 jne	 f_end
2  4694	00001327  8A 4B	05			 mov	 cl, [ebx.more]		 ; copy	more flag
2  4695	0000132A  88 48	05			 mov	 [eax.more], cl
2  4696	0000132D  8B 4B	0C			 mov	 ecx, [ebx.next]	 ; relink blocks
2  4697	00001330  89 48	0C			 mov	 [eax.next], ecx
2  4698	00001333  89 41	08			 mov	 [ecx.prev], eax
2  4699	00001336  8B 0B				 mov	 ecx, [ebx.blen]	 ; readjust length
2  4700	00001338  83 C1	10			 add	 ecx, 16
2  4701	0000133B  01 08				 add	 [eax.blen], ecx
1  4702
1  4703	0000133D			 f_end:
1  4704	0000133D  C3				 ret
1  4705
1  4706	0000133E			 free	 endp
1  4707
1  4708					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4709					 ; Resizes a memory block.
1  4710					 ;
1  4711					 ;  parameters:
1  4712					 ;    eax - ptr	to heap	info (needen for possible mallocs)
1  4713					 ;    ebx - ptr	to data	area of	block
1  4714					 ;    ecx - new	block size
1  4715					 ;
1  4716					 ;  returns:
1  4717					 ;    ebx - new	block ptr, zero	if not enought memory
1  4718					 ;    ecx - new	block size, rounded up to a multiple of	four
1  4719					 ;
1  4720					 ;  modifies:
1  4721					 ;    eax, edx,	esi, edi
1  4722					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4723
1  4724	0000133E			 realloc proc
1  4725
1  4726	0000133E  83 EB	10			 sub	 ebx, 16		 ; ebx -> ptr to block header
1  4727
1  4728	00001341  83 C1	03			 add	 ecx, 3			 ; round size up
1  4729	00001344  80 E1	FC			 and	 cl, 0fch
1  4730	00001347  3B 0B				 cmp	 ecx, [ebx.blen]	 ; is new block	bigger or smaller?
1  4731	00001349  0F 87	0000008B		 ja	 r_big
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 84
DarkX.ASM



1  4732
1  4733						 ; ÍÍÍÍÍ new block size	<= old block size ÍÍÍÍÍ
1  4734
1  4735	0000134F  53				 push	 ebx			 ; block won't change, so save ebx
1  4736
1  4737	00001350  8B 43	0C			 mov	 eax, [ebx.next]	 ; have	we a free block	after?
1  4738	00001353  0B C0				 or	 eax, eax
1  4739	00001355  74 38				 jz	 r_newf
1  4740	00001357  80 78	04 46			 cmp	 [eax.status], 'F'
1  4741	0000135B  75 32				 jne	 r_newf			 ; no, make a new free block (if we can)
1  4742
1  4743						 ; we have a free block	after the resized block, so we move it
1  4744
1  4745	0000135D  8B D3				 mov	 edx, ebx		 ; move	start of free block
1  4746	0000135F  03 D1				 add	 edx, ecx
1  4747	00001361  83 C2	10			 add	 edx, 16
1  4748	00001364  89 53	0C			 mov	 [ebx.next], edx
1  4749	00001367  FF 33				 push	 [ebx.blen]
1  4750	00001369  89 0B				 mov	 [ebx.blen], ecx
1  4751	0000136B  8B DA				 mov	 ebx, edx		 ; ebx -> ptr to free block
1  4752	0000136D  5A				 pop	 edx
1  4753	0000136E  03 10				 add	 edx, [eax.blen]
1  4754	00001370  2B D1				 sub	 edx, ecx		 ; edx = new length of block
1  4755	00001372  89 13				 mov	 [ebx.blen], edx
1  4756	00001374  8B 50	04			 mov	 edx, dword ptr	[eax.status]
1  4757	00001377  89 53	04			 mov	 dword ptr [ebx.status], edx
1  4758	0000137A  8B 50	08			 mov	 edx, [eax.prev]
1  4759	0000137D  89 53	08			 mov	 [ebx.prev], edx
1  4760	00001380  8B 50	0C			 mov	 edx, [eax.next]
1  4761	00001383  89 53	0C			 mov	 [ebx.next], edx
1  4762	00001386  0B D2				 or	 edx, edx
1  4763	00001388  74 47				 jz	 r_s_end
1  4764	0000138A  89 5A	08			 mov	 [edx.prev], ebx
1  4765	0000138D  EB 42				 jmp	 short r_s_end
1  4766
1  4767						 ; we create a new free	block if we can	(i.e. free space >= 16)
1  4768
1  4769	0000138F  8B 13			 r_newf: mov	 edx, [ebx.blen]	 ; calc	the difference
1  4770	00001391  2B D1				 sub	 edx, ecx
1  4771	00001393  83 EA	10			 sub	 edx, 16		 ; we can't resize the block 'cos free
1  4772	00001396  72 39				 jc	 r_s_end		 ;  space is less than 16 bytes...
1  4773	00001398  89 54	0B 10			 mov	 [16 + ebx + ecx.blen],	edx	 ; make	a new block
1  4774	0000139C  8B 43	04			 mov	 eax, dword ptr	[ebx.status]
1  4775	0000139F  89 44	0B 14			 mov	 dword ptr [16 + ebx + ecx.status], eax
1  4776	000013A3  C6 44	0B 14 46		 mov	 [16 + ebx + ecx.status], 'F'
1  4777
1  4778	000013A8  C6 43	05 4D			 mov	 [ebx.more], 'M'	 ; update the resized block
1  4779	000013AC  89 0B				 mov	 [ebx.blen], ecx
1  4780
1  4781	000013AE  8B 43	0C			 mov	 eax, [ebx.next]	 ; relink the heap
1  4782	000013B1  89 44	0B 1C			 mov	 [16 + ebx + ecx.next],	eax
1  4783	000013B5  89 5B	0C			 mov	 [ebx.next], ebx
1  4784	000013B8  01 4B	0C			 add	 [ebx.next], ecx
1  4785	000013BB  83 43	0C 10			 add	 [ebx.next], 16
1  4786	000013BF  89 5C	0B 18			 mov	 [16 + ebx + ecx.prev],	ebx
1  4787	000013C3  0B C0				 or	 eax, eax
1  4788	000013C5  74 0A				 jz	 r_s_end
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 85
DarkX.ASM



1  4789	000013C7  89 58	08			 mov	 [eax.prev], ebx
1  4790	000013CA  01 48	08			 add	 [eax.prev], ecx
1  4791	000013CD  83 40	08 10			 add	 [eax.prev], 16
1  4792
1  4793	000013D1			 r_s_end:
1  4794	000013D1  5B				 pop	 ebx			 ; ebx -> ptr to data area of resized
1  4795	000013D2  83 C3	10			 add	 ebx, 16		 ;  block
1  4796	000013D5  E9 00000091			 jmp	 r_end
1  4797
1  4798						 ; ÍÍÍÍÍ new block size	> old block size ÍÍÍÍÍ
1  4799
1  4800	000013DA  50			 r_big:	 push	 eax			 ; save	ptr to heap info
1  4801	000013DB  8B 43	0C			 mov	 eax, [ebx.next]	 ; check next block to see if is a free
1  4802	000013DE  80 78	04 46			 cmp	 [eax.status], 'F'	 ;  one	and if it's big	enought
1  4803	000013E2  75 5E				 jne	 r_malloc
1  4804
1  4805	000013E4  8B D1				 mov	 edx, ecx
1  4806	000013E6  2B 13				 sub	 edx, [ebx.blen]
1  4807	000013E8  83 EA	10			 sub	 edx, 16		 ; we can use the block	header too
1  4808	000013EB  39 10				 cmp	 [eax.blen], edx
1  4809	000013ED  72 53				 jb	 r_malloc
1  4810
1  4811	000013EF  83 C4	04			 add	 esp, 4			 ; discard ptr to heap info
1  4812
1  4813						 ; we have a free block	just after the resized block and it's big
1  4814						 ;  enought, so	we use it
1  4815
1  4816	000013F2  83 C2	10			 add	 edx, 16		 ; use all the block or	only a little
1  4817	000013F5  39 10				 cmp	 [eax.blen], edx
1  4818	000013F7  76 2D				 jbe	 r_kill
1  4819
1  4820	000013F9  89 0B				 mov	 [ebx.blen], ecx	  ; update lengths
1  4821	000013FB  2B 10				 sub	 edx, [eax.blen]
1  4822	000013FD  F7 DA				 neg	 edx			 ; eax -> ptr old, ebx -> ptr reloc.
1  4823	000013FF  03 CB				 add	 ecx, ebx		 ; ecx -> ptr to new block location
1  4824	00001401  83 C1	10			 add	 ecx, 16
1  4825	00001404  89 11				 mov	 [ecx.blen], edx
1  4826
1  4827	00001406  8B 50	04			 mov	 edx, dword ptr	[eax.status]	 ; copy	old block to new block
1  4828	00001409  89 51	04			 mov	 dword ptr [ecx.status], edx
1  4829
1  4830	0000140C  89 4B	0C			 mov	 [ebx.next], ecx	 ; relink lists
1  4831	0000140F  8B 50	08			 mov	 edx, [eax.prev]
1  4832	00001412  89 51	08			 mov	 [ecx.prev], edx
1  4833	00001415  8B 50	0C			 mov	 edx, [eax.next]
1  4834	00001418  89 51	0C			 mov	 [ecx.next], edx
1  4835	0000141B  8B 0B				 mov	 ecx, [ebx.blen]	 ; restore size
1  4836	0000141D  0B D2				 or	 edx, edx
1  4837	0000141F  74 4A				 jz	 r_end
1  4838	00001421  89 42	08			 mov	 [edx.prev], eax
1  4839	00001424  EB 45				 jmp	 short r_end
1  4840
1  4841	00001426  8B 10			 r_kill: mov	 edx, [eax.blen]	 ; use all the block
1  4842	00001428  83 C2	10			 add	 edx, 16
1  4843	0000142B  01 13				 add	 [ebx.blen], edx
1  4844	0000142D  8B 50	0C			 mov	 edx, [eax.next]	 ; relink blocks
1  4845	00001430  89 53	0C			 mov	 [ebx.next], edx
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 86
DarkX.ASM



1  4846	00001433  0B D2				 or	 edx, edx
1  4847	00001435  74 03				 jz	 r_nonext
1  4848	00001437  89 5A	08			 mov	 [edx.prev], ebx
1  4849	0000143A			 r_nonext:
1  4850	0000143A  8A 50	05			 mov	 dl, [eax.more]
1  4851	0000143D  88 53	05			 mov	 [ebx.more], dl
1  4852
1  4853	00001440  EB 29				 jmp	 short r_end
1  4854
1  4855						 ; we haven't a	free block after the resized block, or it's not	big
1  4856						 ;  enought, so	we call	malloc to get memory if	we can,	copy old
1  4857						 ;  block to new block and free	old block
1  4858
1  4859	00001442			 r_malloc:
1  4860	00001442  58				 pop	 eax			 ; restore ptr to heap info
1  4861	00001443  53				 push	 ebx			 ; we have to allocate another block
1  4862	00001444  E8 FFFFFE35			 call	 malloc			 ;  and	copy data to it
1  4863	00001449  0B DB				 or	 ebx, ebx		 ; not enought memory, return zero ptr
1  4864	0000144B  74 1B				 jz	 r_notenought
1  4865	0000144D  8B FB				 mov	 edi, ebx		 ; copy	block
1  4866	0000144F  5A				 pop	 edx			 ; don't destroy ebx ->	ptr to new block
1  4867	00001450  83 C2	10			 add	 edx, 16		 ; edx must point to data area
1  4868	00001453  8B F2				 mov	 esi, edx
1  4869	00001455  FC				 cld
1  4870	00001456  51				 push	 ecx
1  4871	00001457  C1 E9	02			 shr	 ecx, 2			 ; ecx is allways a multiple of	four
1  4872	0000145A  F3> A5			 rep	 movsd
1  4873	0000145C  87 D3				 xchg	 edx, ebx		 ; free	old block
1  4874	0000145E  E8 FFFFFE74			 call	 free
1  4875	00001463  8B DA				 mov	 ebx, edx
1  4876	00001465  59				 pop	 ecx			 ; end with ebx	-> ptr,	ecx -> length
1  4877	00001466  EB 03				 jmp	 short r_end
1  4878
1  4879	00001468			 r_notenought:
1  4880	00001468  83 C4	04			 add	 esp, 4			 ; just	exit with ebx =	0
1  4881
1  4882	0000146B			 r_end:
1  4883	0000146B  C3				 ret
1  4884
1  4885	0000146C			 realloc endp
1  4886
1  4887					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4888					 ; Gets	memory info.
1  4889					 ;
1  4890					 ;  parameters:
1  4891					 ;    eax - ptr	to heap	info
1  4892					 ;
1  4893					 ;  returns:
1  4894					 ;    eax - maximum available block
1  4895					 ;    ecx - total available memory
1  4896					 ;
1  4897					 ;  modifies:
1  4898					 ;    ebx
1  4899					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4900
1  4901	0000146C			 getmeminfo	 proc
1  4902
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 87
DarkX.ASM



1  4903	0000146C  8B 18				 mov	 ebx, [eax.start]	 ; walk	thought	the heap
1  4904	0000146E  33 C0				 xor	 eax, eax
1  4905	00001470  33 C9				 xor	 ecx, ecx
1  4906	00001472  80 7B	04 46		 gmi_lp: cmp	 [ebx.status], 'F'	 ; is free?
1  4907	00001476  75 08				 jne	 gmi_nxt
1  4908	00001478  39 03				 cmp	 [ebx.blen], eax	 ; get maximum available block
1  4909	0000147A  72 02				 jb	 gmi_c
1  4910	0000147C  8B 03				 mov	 eax, [ebx.blen]
1  4911	0000147E  03 0B			 gmi_c:	 add	 ecx, [ebx.blen]
1  4912	00001480			 gmi_nxt:
1  4913	00001480  80 7B	05 45			 cmp	 [ebx.more], 'E'
1  4914	00001484  74 05				 je	 gmi_end
1  4915	00001486  8B 5B	0C			 mov	 ebx, [ebx.next]
1  4916	00001489  EB E7				 jmp	 short gmi_lp
1  4917
1  4918	0000148B			 gmi_end:
1  4919
1  4920	0000148B  C3				 ret
1  4921
1  4922	0000148C			 getmeminfo	 endp
1  4923					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4924
   4925
   4926					 INCLUDE		 initmem.inc
1  4927					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4928	0000148C			 init_dos_heap	 proc
1  4929					 ; DS =	D32_SEL
1  4930	0000148C  B8 00000000s			 mov	 eax,txcode32
1  4931	00001491  C1 E0	04			 shl	 eax,4
1  4932	00001494  BE 00002EFFr			 mov	 esi,offset dos_pointers
1  4933	00001499  03 F0				 add	 esi,eax
1  4934	0000149B  80 3E	00			 cmp	 byte ptr [esi],0
1  4935	0000149E  74 38				 jz	 no_more_heaps	 ; con 0 bloques, salimos
1  4936	000014A0  05 00002EF7r			 add	 eax,offset dos_heap_info
1  4937	000014A5  8B 5E	01			 mov	 ebx,[esi+1]
1  4938	000014A8  8B 4E	05			 mov	 ecx,[esi+5]
1  4939	000014AB  E8 FFFFFD5A			 call	 initheap
1  4940	000014B0  33 C9				 xor	 ecx,ecx
1  4941	000014B2  8A 0E				 mov	 cl,[esi]
1  4942	000014B4  49				 dec	 ecx
1  4943	000014B5  74 21				 jz	 no_more_heaps
1  4944	000014B7  83 C6	09			 add	 esi,9
1  4945	000014BA				 add_heaps:
1  4946	000014BA  51					 push	 ecx
1  4947	000014BB  B8 00000000s				 mov	 eax,txcode32
1  4948	000014C0  C1 E0	04				 shl	 eax,4
1  4949	000014C3  05 00002EF7r				 add	 eax,offset dos_heap_info
1  4950	000014C8  8B 1E					 mov	 ebx,[esi]
1  4951	000014CA  8B 4E	04				 mov	 ecx,[esi+4]
1  4952	000014CD  E8 FFFFFD64				 call	 addheap
1  4953	000014D2  59					 pop	 ecx
1  4954	000014D3  83 C6	08				 add	 esi,8
1  4955	000014D6  E2 E2				 loop	 add_heaps
1  4956	000014D8				 no_more_heaps:
1  4957	000014D8  C3				 ret
1  4958	000014D9			 init_dos_heap	 endp
1  4959					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 88
DarkX.ASM



1  4960	000014D9			 init_extended_heap	   proc
1  4961					 ; DS =	D32_SEL
1  4962						 ASSUME	 DS:txcode32
1  4963	000014D9  BE 00000000s			 mov	 esi,txcode32
1  4964	000014DE  C1 E6	04			 shl	 esi,4
1  4965	000014E1  0F B6	8E 00003228r		 movzx	 ecx,byte ptr [esi+extended_pointers]
1  4966	000014E8  0B C9				 or	 ecx,ecx
1  4967	000014EA  74 42				 jz	 extended_init_done	 ; si hay 0 bloques, salimos
1  4968	000014EC  51				 push	 ecx
1  4969	000014ED  B8 00003220r			 mov	 eax,offset extended_heap_info
1  4970	000014F2  03 C6				 add	 eax,esi
1  4971	000014F4  8B 9E	00003229r		 mov	 ebx,dword ptr [esi+extended_pointers+1]
1  4972	000014FA  8B 8E	0000322Dr		 mov	 ecx,dword ptr [esi+extended_pointers+5]
1  4973	00001500  E8 FFFFFD05			 call	 initheap
1  4974	00001505  59				 pop	 ecx
1  4975	00001506  49				 dec	 ecx
1  4976	00001507  74 25				 jz	 extended_init_done
1  4977	00001509					 make_xms_heap:
1  4978	00001509  51						 push	 ecx
1  4979	0000150A  B8 00000000s					 mov	 eax,txcode32
1  4980	0000150F  C1 E0	04					 shl	 eax,4
1  4981	00001512  05 00003220r					 add	 eax,offset extended_heap_info
1  4982	00001517  8B 9E	00003231r				 mov	 ebx,dword ptr [esi+9+extended_pointers]
1  4983	0000151D  8B 8E	00003235r				 mov	 ecx,dword ptr [esi+13+extended_pointers]
1  4984	00001523  E8 FFFFFD0E					 call	 addheap
1  4985	00001528  83 C6	08					 add	 esi,8
1  4986	0000152B  59						 pop	 ecx
1  4987	0000152C  E2 DB					 loop	 make_xms_heap
1  4988							 ASSUME	 DS:txdata
1  4989	0000152E				 extended_init_done:
1  4990	0000152E  C3				 ret
1  4991	0000152F			 init_extended_heap	   endp
1  4992					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4993
   4994
   4995					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   4996					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   4997					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   4998
   4999						 include filesys.inc		 ; Rutines per carregar	LEs
1  5000					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5001					 ; file: filesys.inc
1  5002					 ;
1  5003					 ;  TX32's file	system.
1  5004					 ;
1  5005					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1  5006					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5007
1  5008		  =0000			 READ_ONLY	 equ	 0		 ; access rights
1  5009		  =0001			 WRITE_ONLY	 equ	 1
1  5010		  =0002			 READ_WRITE	 equ	 2
1  5011
1  5012		  =0000			 SEEK_SET	 equ	 0		 ; start of file
1  5013		  =0001			 SEEK_CUR	 equ	 1		 ; current file	position
1  5014		  =0002			 SEEK_END	 equ	 2		 ; end of file
1  5015
1  5016					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 89
DarkX.ASM



1  5017					 ; Opens a file	with the desired access.
1  5018					 ;
1  5019					 ;  parameters:
1  5020					 ;    edx - pointer to file name to open
1  5021					 ;    al - access rights
1  5022					 ;
1  5023					 ;  returns:
1  5024					 ;    cf - set if error
1  5025					 ;    eax - handle of file
1  5026					 ;
1  5027					 ;  modifies:
1  5028					 ;    eax
1  5029					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5030
1  5031	0000152F			 openfile	 proc
1  5032
1  5033	0000152F  B4 3D				 mov	 ah, 3dh
1  5034	00001531  CD 21				 int	 21h
1  5035	00001533  C3				 ret
1  5036
1  5037	00001534			 openfile	 endp
1  5038
1  5039					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5040					 ; Reads from a	file.
1  5041					 ;
1  5042					 ;  parameters:
1  5043					 ;    edx - pointer to buffer
1  5044					 ;    ebx - file handle
1  5045					 ;    ecx - number of bytes to read
1  5046					 ;
1  5047					 ;  returns:
1  5048					 ;    cf - set if error
1  5049					 ;    eax - number of bytes readed
1  5050					 ;
1  5051					 ;  modifies:
1  5052					 ;    eax
1  5053					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5054
1  5055	00001534			 read		 proc
1  5056
1  5057	00001534  B4 3F				 mov	 ah, 3fh
1  5058	00001536  CD 21				 int	 21h
1  5059	00001538  72 06				 jc	 r_exit
1  5060	0000153A  3B C1				 cmp	 eax, ecx		 ; Check if ecx	bytes have been	readed
1  5061	0000153C  F8				 clc				 ; Don't touch zero flag!
1  5062	0000153D  74 01				 je	 r_exit
1  5063	0000153F  F9				 stc
1  5064	00001540			 r_exit:
1  5065	00001540  C3				 ret
1  5066
1  5067	00001541			 read		 endp
1  5068
1  5069					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5070					 ; Sets	current	file position
1  5071					 ;
1  5072					 ;  parameters:
1  5073					 ;    al - origin of move
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 90
DarkX.ASM



1  5074					 ;    ebx - file handle
1  5075					 ;    edx - file position
1  5076					 ;
1  5077					 ;  returns:
1  5078					 ;    cf - set if error
1  5079					 ;    eax - new	file position
1  5080					 ;
1  5081					 ;  modifies:
1  5082					 ;    eax
1  5083					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5084
1  5085	00001541			 seek		 proc
1  5086
1  5087	00001541  B4 42				 mov	 ah, 42h
1  5088	00001543  51				 push	 ecx
1  5089	00001544  52				 push	 edx
1  5090	00001545  0F A4	D1 10			 shld	 ecx, edx, 16		 ; cx:dx <- file position
1  5091	00001549  CD 21				 int	 21h
1  5092	0000154B  0F A4	C2 10			 shld	 edx, eax, 16
1  5093	0000154F  8B C2				 mov	 eax, edx
1  5094	00001551  5A				 pop	 edx
1  5095	00001552  59				 pop	 ecx
1  5096	00001553  C3				 ret
1  5097
1  5098	00001554			 seek		 endp
1  5099
1  5100
   5101						 include loadle.inc
1  5102					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5103					 ; file: loadle.inc
1  5104					 ;
1  5105					 ;  Loads LE executable	files. Used by TX32 extender.
1  5106					 ;
1  5107					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1  5108					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5109
1  5110		  =0001			 DOS_MEMORY	     equ     1		 ; Memory types
1  5111		  =0002			 XMS_MEMORY	     equ     2
1  5112
1  5113		  =0000			 E_FILE_ERROR	     equ     0		 ; Error codes
1  5114		  =0001			 E_NOT_LE	     equ     1
1  5115		  =0002			 E_NOT_ENOUGH_MEM    equ     2
1  5116		  =0003			 E_UNSUPORTED_FEATURE equ    3
1  5117
1  5118					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5119					 ; Loads an LE file. First of all it skips the stub, and then loads it.
1  5120					 ;
1  5121					 ;  parameters:
1  5122					 ;    edx - pointer to file name to load
1  5123					 ;    ds - selector with zero base
1  5124					 ;    es - selector of 16-bit data segment
1  5125					 ;
1  5126					 ;  returns:
1  5127					 ;    cf - set on error
1  5128					 ;    eax - offset of entry point
1  5129					 ;
1  5130					 ;  modifies:
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 91
DarkX.ASM



1  5131					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5132
1  5133	00001554			 LoadLE		 proc
1  5134
1  5135	00001554  FC				 cld
1  5136
1  5137	00001555  B0 00				 mov	 al, READ_ONLY
1  5138	00001557  E8 FFFFFFD3			 call	 openfile		 ; Opens the file and seeks LE header
1  5139	0000155C  0F 82	00000435		 jc	 of_error_loading
1  5140
1  5141						 ; ds, es -> 16-bit data segment
1  5142
1  5143	00001562  2E: 8E 1D 0000000Cr		 mov	 ds, [cs:D16_SEL]
1  5144	00001569  67| A3 0ABFr			 mov	 [handle], eax
1  5145	0000156D  8B D8				 mov	 ebx, eax
1  5146	0000156F  B9 00000002			 mov	 ecx, 2
1  5147	00001574  BA 00000AC7r			 mov	 edx, offset le_hdr
1  5148	00001579  E8 FFFFFFB6			 call	 read
1  5149	0000157E  0F 82	00000419		 jc	 error_loading
1  5150
1  5151	00001584  67| C7 06 0AC3r     +		 mov	 [le_offset], 0		 ; Default offset
   5152		  00000000
1  5153
1  5154	0000158D  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "ZM"; Let's see if	it has an stub
   5155		  5A4D
1  5156	00001595  74 0A				 je	 it_has_stub
1  5157	00001597  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "MZ"
   5158		  4D5A
1  5159	0000159F  75 4E				 jne	 check_le
1  5160
1  5161	000015A1			     it_has_stub:
1  5162	000015A1  B0 00				 mov	 al, SEEK_SET		 ; Get LE's possible offset
1  5163	000015A3  BA 0000003C			 mov	 edx, 3ch
1  5164	000015A8  E8 FFFFFF94			 call	 seek
1  5165	000015AD  0F 82	000003EA		 jc	 error_loading
1  5166
1  5167	000015B3  BA 00000AC3r			 mov	 edx, offset le_offset
1  5168	000015B8  B9 00000002			 mov	 ecx, 2
1  5169	000015BD  E8 FFFFFF72			 call	 read
1  5170	000015C2  0F 82	000003D5		 jc	 error_loading
1  5171
1  5172	000015C8  B0 00				 mov	 al, SEEK_SET		 ; Skip	stub
1  5173	000015CA  67| 8B 16 0AC3r		 mov	 edx, [le_offset]
1  5174	000015CF  E8 FFFFFF6D			 call	 seek
1  5175	000015D4  0F 82	000003C3		 jc	 error_loading
1  5176
1  5177	000015DA  B9 00000002			 mov	 ecx, 2			 ; Get new header's signature
1  5178	000015DF  BA 00000AC7r			 mov	 edx, offset le_hdr
1  5179	000015E4  E8 FFFFFF4B			 call	 read
1  5180	000015E9  0F 82	000003AE		 jc	 error_loading
1  5181
1  5182	000015EF			     check_le:
1  5183	000015EF  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "EL"; Check if it's an LE header
   5184		  454C
1  5185	000015F7  0F 85	000003A7		 jne	 not_LE
1  5186
1  5187	000015FD  B9 000000C2			 mov	 ecx, size le_hdr - 2	 ; Ok. It's an LE header
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 92
DarkX.ASM



1  5188	00001602  BA 00000AC9r			 mov	 edx, offset le_hdr + 2
1  5189	00001607  E8 FFFFFF28			 call	 read
1  5190	0000160C  0F 82	0000038B		 jc	 error_loading
1  5191
1  5192					     ; Up to here we have LE's header and starting offset. We continue
1  5193					     ; loading it.
1  5194
1  5195	00001612  B0 00				 mov	 al, SEEK_SET		 ; Load	object table
1  5196	00001614  67| 8B 16 0B07r		 mov	 edx, [le_hdr.off_object_tbl]
1  5197	00001619  67| 03 16 0AC3r		 add	 edx, [le_offset]
1  5198	0000161E  E8 FFFFFF1E			 call	 seek
1  5199	00001623  0F 82	00000374		 jc	 error_loading
1  5200
1  5201	00001629  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5202	0000162D  6B C0	18			 imul	 eax, size OBJECT
1  5203	00001630  8B C8				 mov	 ecx, eax
1  5204	00001632  BA 00000B8Br			 mov	 edx, offset object_tbl
1  5205	00001637  E8 FFFFFEF8			 call	 read
1  5206	0000163C  0F 82	0000035B		 jc	 error_loading
1  5207
1  5208					     ; Get memory for all the objects. This must be done BEFORE	the fixup.
1  5209
1  5210	00001642  BE 00000B8Br			 mov	 esi, offset object_tbl	 ; Start walking object	table
1  5211	00001647  67| C7 06 0CD5r     +		 mov	 [obj_handles_ptr], 0
   5212		  00000000
1  5213	00001650  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5214	00001654  67| A3 0CDDr			 mov	 [obj_count], eax
1  5215	00001658  67| C7 06 0CD9r     +		 mov	 [num_obj_handles], 0
   5216		  00000000
1  5217
1  5218						 ; ds -> 16-bit	data segment
1  5219						 ; es -> flat data segment (to do mem zeroing)
1  5220
1  5221	00001661  2E: 8E 05 00000014r		 mov	 es, [cs:DATA_SEL]
1  5222
1  5223	00001668			     get_memory:
1  5224
1  5225	00001668  8B 1E				     mov     ebx, [esi.virtual_size]	 ; Get memory (first try ext mem)
1  5226
1  5227					 ;  Allocates a	block of extended memory.
1  5228					 ;
1  5229					 ;In:
1  5230					 ;  AX	   = 0501h
1  5231					 ;  BX:CX  = size of block in bytes (must be non-zero)
1  5232					 ;
1  5233					 ;Out:
1  5234					 ;  if successful:
1  5235					 ;    carry flag clear
1  5236					 ;    BX:CX  = linear address of allocated memory block
1  5237					 ;    SI:DI  = memory block handle (used to resize and free block)
1  5238					 ;
1  5239					 ;  if failed:
1  5240					 ;    carry flag set
1  5241
1  5242	0000166A  56				     push    esi
1  5243	0000166B  66| 8B CB			     mov     cx, bx			 ; bx:cx = size	in bytes
1  5244	0000166E  C1 EB	10			     shr     ebx, 16
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 93
DarkX.ASM



1  5245	00001671  66| B8 0501			     mov     ax, 501h
1  5246	00001675  CD 31				     int     31h
1  5247	00001677  58				     pop     eax
1  5248	00001678  72 32				     jc	     not_enough_ext_mem
1  5249
1  5250	0000167A  67| 8B 16 0CD5r		     mov     edx, [obj_handles_ptr]	 ; Save	the handle
1  5251	0000167F  C1 E6	10			     shl     esi, 16
1  5252	00001682  66| 8B F7			     mov     si, di
1  5253	00001685  89 B4	D2 00000C7Br		     mov     [object_nfo.obj_handles + edx * 8 + edx], esi
1  5254	0000168C  C6 84	D2 00000C7Fr  +		     mov     [object_nfo.mem_type + edx	* 8 + edx], XMS_MEMORY
   5255		  02
1  5256	00001694  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5257
1  5258	00001699  8B F0				     mov     esi, eax			 ; Restore ptr to object table!
1  5259
1  5260	0000169B  8B FB				     mov     edi, ebx			 ; Get the real	address	@@
1  5261	0000169D  C1 E7	10			     shl     edi, 16
1  5262	000016A0  66| 8B F9			     mov     di, cx			 ; edi = ptr to	memory block
1  5263	000016A3  89 BC	D2 00000C80r		     mov     [object_nfo.obj_offset + edx * 8 +	edx], edi
1  5264
1  5265	000016AA  EB 3B				     jmp     we_have_it
1  5266
1  5267	000016AC				 not_enough_ext_mem:
1  5268
1  5269					 ;  Allocates low memory through DOS function 48h and allocates	it a descriptor.
1  5270					 ;
1  5271					 ;In:
1  5272					 ;  AX	   = 0100h
1  5273					 ;  BX	   = paragraphs	to allocate
1  5274					 ;
1  5275					 ;Out:
1  5276					 ;  if successful:
1  5277					 ;    carry flag clear
1  5278					 ;    AX     = real mode segment address
1  5279					 ;    DX     = protected mode selector for memory block
1  5280					 ;
1  5281					 ;  if failed:
1  5282					 ;    carry flag set
1  5283					 ;    AX     = DOS error code
1  5284					 ;    BX     = size of largest available block
1  5285
1  5286	000016AC  53				     push    ebx			 ; bx =	# paragraphs
1  5287	000016AD  83 C3	0F			     add     ebx, 15
1  5288	000016B0  C1 EB	04			     shr     ebx, 4
1  5289	000016B3  66| B8 0100			     mov     ax, 100h
1  5290	000016B7  CD 31				     int     31h
1  5291	000016B9  5B				     pop     ebx
1  5292	000016BA  0F 82	000002EB		     jc	     not_enough_memory
1  5293
1  5294	000016C0  67| 8B 1E 0CD5r		     mov     ebx, [obj_handles_ptr]	 ; Save	the "handle"
1  5295	000016C5  66| 89 94 DB	      +		     mov     word ptr [object_nfo.obj_handles +	ebx * 8	+ ebx],	dx
   5296		  00000C7Br
1  5297	000016CD  C6 84	DB 00000C7Fr  +		     mov     [object_nfo.mem_type + ebx	* 8 + ebx], DOS_MEMORY
   5298		  01
1  5299	000016D5  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5300
1  5301	000016DA  0F B7	F8			     movzx   edi, ax			 ; Get the real	address	@@
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 94
DarkX.ASM



1  5302	000016DD  C1 E7	04			     shl     edi, 4			 ; edi = ptr to	memory block
1  5303	000016E0  89 BC	DB 00000C80r		     mov     [object_nfo.obj_offset + ebx * 8 +	ebx], edi
1  5304
1  5305	000016E7				 we_have_it:
1  5306
1  5307	000016E7  8B 0E				     mov     ecx, [esi.virtual_size]	 ; Zero-fill the memory
1  5308	000016E9  51				     push    ecx
1  5309	000016EA  C1 E9	02			     shr     ecx, 2
1  5310	000016ED  33 C0				     xor     eax, eax
1  5311	000016EF  F3> AB			     rep     stosd
1  5312	000016F1  59				     pop     ecx
1  5313	000016F2  83 E1	03			     and     ecx, 3
1  5314	000016F5  74 02				     jz	     end_of_fill
1  5315	000016F7  F3> AA			     rep     stosb
1  5316
1  5317	000016F9				 end_of_fill:
1  5318
1  5319	000016F9  67| FF 06 0CD9r		     inc     [num_obj_handles]
1  5320	000016FE  83 C6	18			     add     esi, size OBJECT
1  5321
1  5322	00001701  67| FF 0E 0CDDr		 dec	 [obj_count]
1  5323	00001706  0F 85	FFFFFF5C		 jnz	 get_memory
1  5324
1  5325					     ; We have memory to load the pages. Load them!
1  5326
1  5327	0000170C  BE 00000B8Br			 mov	 esi, offset object_tbl	 ; Start walking object	table
1  5328	00001711  67| C7 06 0CD5r     +		 mov	 [obj_handles_ptr], 0
   5329		  00000000
1  5330	0000171A  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5331	0000171E  67| A3 0CDDr			 mov	 [obj_count], eax
1  5332
1  5333	00001722			     walk_object_table:
1  5334
1  5335						     ; ds -> 16-bit data segment
1  5336						     ; es -> who cares?
1  5337
1  5338	00001722  8B 46	0C			     mov     eax, [esi.page_map_index]
1  5339	00001725  48				     dec     eax			 ; It's	1-based
1  5340	00001726  67| A3 0CE1r			     mov     [curr_page], eax
1  5341	0000172A  67| F7 26 0AEFr		     mul     [le_hdr.page_size]
1  5342	0000172F  8B D0				     mov     edx, eax
1  5343	00001731  67| 03 16 0B47r		     add     edx, [le_hdr.off_data_pages]; Offset from begin of	file
1  5344	00001736  B0 00				     mov     al, SEEK_SET
1  5345	00001738  67| 8B 1E 0ABFr		     mov     ebx, [handle]
1  5346	0000173D  E8 FFFFFDFF			     call    seek
1  5347	00001742  0F 82	00000255		     jc	     error_loading
1  5348
1  5349	00001748  67| A1 0CD5r			     mov     eax, [obj_handles_ptr]
1  5350	0000174C  8B 94	C0 00000C80r		     mov     edx, [object_nfo.obj_offset + eax * 8 + eax]
1  5351	00001753  8B 7E	10			     mov     edi, [esi.num_pages]
1  5352	00001756  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5353
1  5354						     ; ds -> flat data segment
1  5355						     ; es -> 16-bit data segment
1  5356
1  5357	0000175B  2E: 8E 1D 00000014r		     mov     ds, [cs:DATA_SEL]
1  5358	00001762  2E: 8E 05 0000000Cr		     mov     es, [cs:D16_SEL]
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 95
DarkX.ASM



1  5359
1  5360	00001769  0B FF				     or	     edi, edi
1  5361	0000176B  74 44				     jz	     no_pages
1  5362
1  5363	0000176D				 next_page:
1  5364
1  5365	0000176D  26: 67| 8B 0E	0AEFr			 mov	 ecx, [es:le_hdr.page_size]
1  5366	00001773  26: 67| FF 06	0CE1r			 inc	 [es:curr_page]			 ; Increment beforehand!
1  5367
1  5368	00001779  26: 67| A1 0CE1r			 mov	 eax, [es:curr_page]
1  5369	0000177E  26: 67| 3B 06	0ADBr			 cmp	 eax, [es:le_hdr.memory_pages]	 ; File's last page?
1  5370	00001784  75 08					 jne	 last_object_page?
1  5371
1  5372	00001786  26: 67| 8B 0E	0AF3r			 mov	 ecx, [es:le_hdr.bytes_last_page]
1  5373
1  5374	0000178C  EB 0F					 jmp	 continue_loading
1  5375
1  5376	0000178E				     last_object_page?:
1  5377
1  5378	0000178E  83 FF	01				 cmp	 edi, 1				 ; Object's last page?
1  5379	00001791  75 0A					 jne	 continue_loading
1  5380
1  5381	00001793  26: 67| 8B 0E	0AEFr			 mov	 ecx, [es:le_hdr.page_size]
1  5382	00001799  49					 dec	 ecx
1  5383	0000179A  26: 23 0E				 and	 ecx, [es:esi.virtual_size]
1  5384
1  5385	0000179D				     continue_loading:
1  5386
1  5387	0000179D  E8 FFFFFD92				 call	 read
1  5388	000017A2  0F 82	000001F5			 jc	 error_loading
1  5389
1  5390	000017A8  26: 67| 03 16	0AEFr			 add	 edx, [es:le_hdr.page_size]
1  5391
1  5392	000017AE  4F				     dec     edi
1  5393	000017AF  75 BC				     jnz     next_page
1  5394
1  5395	000017B1				 no_pages:
1  5396
1  5397					     ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5398					     ; TODO: create descriptors	for each object	(???)
1  5399					     ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5400
1  5401						 ; Now we will fixup each page
1  5402
1  5403						     ; ds -> 16-bit data segment   (ds,	es inverted!)
1  5404						     ; es -> flat data segment
1  5405
1  5406	000017B1  2E: 8E 1D 0000000Cr		     mov     ds, [cs:D16_SEL]
1  5407	000017B8  2E: 8E 05 00000014r		     mov     es, [cs:DATA_SEL]
1  5408
1  5409	000017BF  67| 8B 16 0CD5r		     mov     edx, [obj_handles_ptr]	 ; Get current object ptr
1  5410	000017C4  4A				     dec     edx
1  5411
1  5412	000017C5  8B 84	D2 00000C80r		     mov     eax, [object_nfo.obj_offset + edx * 8 + edx]
1  5413	000017CC  67| A3 0CF1r			     mov     [curr_page_off], eax	 ; Offset of current page
1  5414
1  5415	000017D0  8B 56	0C			     mov     edx, [esi.page_map_index]
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 96
DarkX.ASM



1  5416	000017D3  4A				     dec     edx			 ; It's	1-based
1  5417
1  5418	000017D4  C1 E2	02			     shl     edx, 2			 ; File	ptr to current fixup
1  5419	000017D7  67| 03 16 0AC3r		     add     edx, [le_offset]		 ;  page table entry
1  5420	000017DC  67| 03 16 0B2Fr		     add     edx, [le_hdr.off_fixup_pag]
1  5421	000017E1  67| 89 16 0CE5r		     mov     [curr_fixup_pag], edx
1  5422
1  5423	000017E6  8B 7E	10			     mov     edi, [esi.num_pages]
1  5424	000017E9  67| 8B 1E 0ABFr		     mov     ebx, [handle]
1  5425
1  5426	000017EE  0B FF				     or	     edi, edi
1  5427	000017F0  0F 84	00000176		     jz	     no_pages_to_fixup
1  5428
1  5429	000017F6				 fixup_next_page:
1  5430
1  5431	000017F6  67| 8B 16 0CE5r			 mov	 edx, [curr_fixup_pag]		 ; Fixup a page
1  5432	000017FB  B0 00					 mov	 al, SEEK_SET
1  5433	000017FD  E8 FFFFFD3F				 call	 seek
1  5434	00001802  0F 82	00000195			 jc	 error_loading
1  5435
1  5436	00001808  BA 00000CE9r				 mov	 edx, offset off_1st_fixup_rec
1  5437	0000180D  B9 00000004				 mov	 ecx, 4
1  5438	00001812  E8 FFFFFD1D				 call	 read
1  5439	00001817  0F 82	00000180			 jc	 error_loading
1  5440
1  5441	0000181D  BA 00000CEDr				 mov	 edx, offset off_1st_fixup_rec_next_page
1  5442	00001822  B9 00000004				 mov	 ecx, 4
1  5443	00001827  E8 FFFFFD08				 call	 read
1  5444	0000182C  0F 82	0000016B			 jc	 error_loading
1  5445
1  5446	00001832  67| 8B 16 0CE9r			 mov	 edx, [off_1st_fixup_rec]
1  5447	00001837  67| 03 16 0B33r			 add	 edx, [le_hdr.off_fixup_rec]
1  5448	0000183C  67| 03 16 0AC3r			 add	 edx, [le_offset]
1  5449	00001841  B0 00					 mov	 al, SEEK_SET
1  5450	00001843  E8 FFFFFCF9				 call	 seek
1  5451	00001848  0F 82	0000014F			 jc	 error_loading
1  5452
1  5453	0000184E				     next_fixup_entry:
1  5454
1  5455	0000184E  67| A1 0CEDr				     mov     eax, [off_1st_fixup_rec_next_page]
1  5456	00001852  67| 39 06 0CE9r			     cmp     [off_1st_fixup_rec], eax
1  5457	00001857  0F 83	000000F9			     jae     end_fixup
1  5458
1  5459	0000185D  BA 00000CF5r				     mov     edx, offset source_type
1  5460	00001862  B9 00000004				     mov     ecx, 4
1  5461	00001867  E8 FFFFFCC8				     call    read
1  5462	0000186C  0F 82	0000012B			     jc	     error_loading
1  5463
1  5464	00001872  67| 83 06 0CE9r 04			     add     [off_1st_fixup_rec], 4	 ; "Loop counter" :(
1  5465
1  5466	00001878  67| F6 06 0CF6r 03			     test    [target_flags], 3		 ; Only	internal reference
1  5467	0000187E  0F 85	0000012E			     jnz     unsuported_feature
1  5468
1  5469	00001884  66| 67| C7 06	0CF9r +			     mov     [object_num], 0
   5470		  0000
1  5471	0000188C  B9 00000001				     mov     ecx, 1
1  5472	00001891  67| F6 06 0CF6r 40			     test    [target_flags], 40h	 ; Object number size
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 97
DarkX.ASM



1  5473	00001897  74 01					     jz	     load_obj_num
1  5474	00001899  41					     inc     ecx
1  5475
1  5476	0000189A					 load_obj_num:
1  5477	0000189A  BA 00000CF9r				     mov     edx, offset object_num
1  5478	0000189F  E8 FFFFFC90				     call    read
1  5479	000018A4  0F 82	000000F3			     jc	     error_loading
1  5480
1  5481	000018AA  67| 01 06 0CE9r			     add     [off_1st_fixup_rec], eax	 ; "Loop counter" :(
1  5482
1  5483	000018AF  67| 80 3E 0CF5r 07			     cmp     [source_type], 7		 ; Only	32-bit offset &
1  5484	000018B5  75 58					     jne     maybe_16bit_sel		 ;  16-bit selectors
1  5485
1  5486							 ; ÄÄÄÄÄ 32-bit	offset ÄÄÄÄÄ
1  5487
1  5488	000018B7  B9 00000002				     mov     ecx, 2
1  5489	000018BC  67| F6 06 0CF6r 10			     test    [target_flags], 10h	 ; Target offset size
1  5490	000018C2  74 05					     jz	     load_target_off
1  5491	000018C4  B9 00000004				     mov     ecx, 4
1  5492
1  5493	000018C9					 load_target_off:
1  5494	000018C9  BA 00000CFBr				     mov     edx, offset target_off
1  5495	000018CE  E8 FFFFFC61				     call    read
1  5496	000018D3  0F 82	000000C4			     jc	     error_loading
1  5497
1  5498	000018D9  67| 01 06 0CE9r			     add     [off_1st_fixup_rec], eax	 ; "Loop counter" :(
1  5499
1  5500	000018DE  67| 8B 0E 0CFBr			     mov     ecx, [target_off]
1  5501	000018E3  67| F6 06 0CF6r 10			     test    [target_flags], 10h	 ; Target offset size
1  5502	000018E9  75 06					     jnz     dont_do_zero_extent
1  5503	000018EB  67| 0F B7 0E 0CFBr			     movzx   ecx, word ptr [target_off]	 ; Zero	extent,	not sign
1  5504												 ;  extent !!!!
1  5505	000018F1					 dont_do_zero_extent:
1  5506
1  5507	000018F1  67| 0F B7 06 0CF9r			     movzx   eax, [object_num]		 ; Do the fixup
1  5508	000018F7  48					     dec     eax			 ; It's	1-based
1  5509	000018F8  03 8C	C0 00000C80r			     add     ecx, [object_nfo.obj_offset + eax * 8 + eax]
1  5510	000018FF  67| 0F BF 06 0CF7r			     movsx   eax, [source_off]
1  5511	00001905  67| 03 06 0CF1r			     add     eax, [curr_page_off]
1  5512
1  5513	0000190A  26: 89 08				     mov     [es:eax], ecx
1  5514
1  5515	0000190D  EB 42					     jmp     fixed_up
1  5516
1  5517							 ; ÄÄÄÄÄ 16-bit	selector ÄÄÄÄÄ
1  5518
1  5519	0000190F					 maybe_16bit_sel:
1  5520
1  5521	0000190F  67| 80 3E 0CF5r 02			     cmp     [source_type], 2		 ; 16-bit selector?
1  5522	00001915  0F 85	00000097			     jne     unsuported_feature
1  5523
1  5524	0000191B  67| 0F B7 06 0CF9r			     movzx   eax, [object_num]		 ; Code	or data?
1  5525	00001921  48					     dec     eax			 ; It's	1-based
1  5526	00001922  8B 84	C0 00000C83r			     mov     eax, [object_nfo.object_flags + eax * 8 + eax]
1  5527	00001929  A9 00000004				     test    eax, 4			 ; Executable segment
1  5528	0000192E  74 0A					     jz	     it_is_data
1  5529	00001930  66| 2E: 8B 0D	      +			     mov     cx, [cs:CODE_SEL]		 ; a little hack :) @@
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 98
DarkX.ASM



   5530		  00000010r
1  5531	00001938  EB 08					     jmp     we_have_sel_type
1  5532	0000193A					 it_is_data:
1  5533	0000193A  66| 2E: 8B 0D	      +			     mov     cx, [cs:DATA_SEL]
   5534		  00000014r
1  5535	00001942					 we_have_sel_type:
1  5536
1  5537	00001942  67| 0F BF 06 0CF7r			     movsx   eax, [source_off]
1  5538	00001948  67| 03 06 0CF1r			     add     eax, [curr_page_off]
1  5539
1  5540	0000194D  66| 26: 89 08				     mov     word ptr [es:eax],	cx
1  5541
1  5542	00001951					 fixed_up:
1  5543
1  5544	00001951  E9 FFFFFEF8				 jmp	 next_fixup_entry
1  5545
1  5546	00001956				     end_fixup:
1  5547
1  5548	00001956  67| A1 0AEFr				 mov	 eax, [le_hdr.page_size]
1  5549	0000195A  67| 01 06 0CF1r			 add	 [curr_page_off], eax
1  5550	0000195F  67| 83 06 0CE5r 04			 add	 [curr_fixup_pag], 4
1  5551
1  5552	00001965  4F				     dec     edi
1  5553	00001966  0F 85	FFFFFE8A		     jnz     fixup_next_page
1  5554
1  5555	0000196C				 no_pages_to_fixup:
1  5556
1  5557	0000196C  83 C6	18			     add     esi, size OBJECT
1  5558
1  5559	0000196F  67| FF 0E 0CDDr		 dec	 [obj_count]		 ; Iterate for all entries
1  5560	00001974  0F 85	FFFFFDA8		 jnz	 walk_object_table
1  5561
1  5562	0000197A  67| 8B 1E 0ABFr		 mov	 ebx, [handle]		 ; Close file
1  5563	0000197F  B4 3E				 mov	 ah, 3eh
1  5564	00001981  CD 21				 int	 21h
1  5565
1  5566	00001983  67| 8B 1E 0ADFr		 mov	 ebx, [le_hdr.object_cs] ; Calculate entry point
1  5567	00001988  4B				 dec	 ebx			 ; It's	1-based!
1  5568	00001989  8B 84	DB 00000C80r		 mov	 eax, [object_nfo.obj_offset + ebx * 8 + ebx]
1  5569	00001990  67| 03 06 0AE3r		 add	 eax, [le_hdr.offset_eip]
1  5570
1  5571	00001995  F8				 clc
1  5572	00001996  C3				 ret
1  5573
1  5574					     ; Return error codes
1  5575
1  5576	00001997			     of_error_loading:			 ; Special case: error opening file
1  5577	00001997  B8 00000000			 mov	 eax, E_FILE_ERROR
1  5578	0000199C  C3				 ret
1  5579
1  5580	0000199D			     error_loading:
1  5581	0000199D  B8 00000000			 mov	 eax, E_FILE_ERROR
1  5582	000019A2  EB 15				 jmp	 do_cleanup
1  5583
1  5584	000019A4			     not_LE:
1  5585	000019A4  B8 00000001			 mov	 eax, E_NOT_LE
1  5586	000019A9  EB 0E				 jmp	 do_cleanup
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 99
DarkX.ASM



1  5587
1  5588	000019AB			     not_enough_memory:
1  5589	000019AB  B8 00000002			 mov	 eax, E_NOT_ENOUGH_MEM
1  5590	000019B0  EB 07				 jmp	 do_cleanup
1  5591
1  5592	000019B2			     unsuported_feature:
1  5593	000019B2  B8 00000003			 mov	 eax, E_UNSUPORTED_FEATURE
1  5594	000019B7  EB 00				 jmp	 do_cleanup
1  5595
1  5596					     ; Close files & free memory
1  5597
1  5598	000019B9			     do_cleanup:
1  5599
1  5600	000019B9  50				 push	 eax
1  5601
1  5602	000019BA  2E: 8E 1D 0000000Cr		 mov	 ds, [cs:D16_SEL]
1  5603
1  5604	000019C1  67| 8B 1E 0ABFr		 mov	 ebx, [handle]		 ; Close file
1  5605	000019C6  B4 3E				 mov	 ah, 3eh
1  5606	000019C8  CD 21				 int	 21h
1  5607
1  5608	000019CA  67| 8B 0E 0CD9r		 mov	 ecx, [num_obj_handles]
1  5609	000019CF  33 DB				 xor	 ebx, ebx
1  5610
1  5611	000019D1			     lle_free_memory:			 ; Free	all memory blocs
1  5612
1  5613	000019D1  0B C9				     or	     ecx, ecx
1  5614	000019D3  74 30				     jz	     lle_end_freeing
1  5615
1  5616	000019D5  80 BB	00000C7Fr 01		     cmp     [object_nfo.mem_type + ebx], DOS_MEMORY
1  5617	000019DC  75 0F				     jne     lle_free_xms_mem
1  5618
1  5619	000019DE  66| 8B 93 00000C7Br		     mov     dx, word ptr [object_nfo.obj_handles + ebx]
1  5620	000019E5  66| B8 0101			     mov     ax, 101h
1  5621	000019E9  CD 31				     int     31h
1  5622
1  5623	000019EB  EB 12				     jmp     lle_continue_freeing
1  5624
1  5625	000019ED				 lle_free_xms_mem:
1  5626
1  5627	000019ED  8B B3	00000C7Br		     mov     esi, [object_nfo.obj_handles + ebx]
1  5628
1  5629	000019F3  66| 8B FE			     mov     di, si
1  5630	000019F6  C1 EE	10			     shr     esi, 16
1  5631	000019F9  66| B8 0502			     mov     ax, 502h
1  5632	000019FD  CD 31				     int     31h
1  5633
1  5634	000019FF				 lle_continue_freeing:
1  5635
1  5636	000019FF  83 C3	09			     add     ebx, size OBJNFO
1  5637
1  5638	00001A02  49				 dec	 ecx
1  5639	00001A03  EB CC				 jmp	 lle_free_memory
1  5640
1  5641	00001A05			     lle_end_freeing:
1  5642
1  5643	00001A05  58				 pop	 eax
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 100
DarkX.ASM



1  5644	00001A06  F9				 stc
1  5645	00001A07  C3				 ret
1  5646
1  5647	00001A08			 LoadLE		 endp
1  5648
1  5649
   5650
   5651					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5652					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5653					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5654
   5655					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5656	00001A08			 bin_to_dec	 proc
   5657					 ; INPUT  -> EAX = number to convert ; DS:EDI -> buffer	where to copy string
   5658					 ; OUTPUT -> DS:EDI -> number string in	decimal	(skipping initial zeros)
   5659	00001A08  BB 0000000A			 mov	 ebx,10
   5660	00001A0D  BD 0000000A			 mov	 ebp,10
   5661	00001A12  32 C9				 xor	 cl,cl
   5662	00001A14				 pass_to_decimal:
   5663	00001A14  33 D2					 xor	 edx,edx
   5664	00001A16  F7 F3					 div	 ebx
   5665	00001A18  0B D2					 or	 edx,edx
   5666	00001A1A  75 04					 jnz	 make_ascii
   5667	00001A1C  0B C0					 or	 eax,eax
   5668	00001A1E  74 0B					 jz	 decide_space_from_now
   5669	00001A20					 make_ascii:
   5670	00001A20  80 C2	30				 add	 dl,30h
   5671	00001A23					 put_the_char:
   5672	00001A23  88 54	3D FF				 mov	 [ebp+edi-1],dl
   5673	00001A27  4D					 dec	 ebp
   5674	00001A28  75 EA				 jnz	 pass_to_decimal
   5675	00001A2A  C3				 ret
   5676
   5677	00001A2B				 decide_space_from_now:
   5678	00001A2B  83 FD	0A			 cmp	 ebp,10
   5679	00001A2E  75 05				 jnz	 no_first_zero
   5680	00001A30  C6 47	09 30				 mov	 byte ptr [edi+9],'0'
   5681	00001A34  4D					 dec	 ebp
   5682	00001A35				 no_first_zero:
   5683	00001A35  55				 push	 ebp
   5684	00001A36				 put_spaces:
   5685	00001A36  C6 44	3D FF 20			 mov	 byte ptr [ebp+edi-1],'	'
   5686	00001A3B  4D				 dec	 ebp
   5687	00001A3C  75 F8				 jnz	 put_spaces
   5688	00001A3E  5D				 pop	 ebp
   5689	00001A3F  03 FD				 add	 edi,ebp
   5690	00001A41  C3				 ret
   5691
   5692	00001A42			 bin_to_dec	 endp
   5693					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5694
   5695	00001A42			 c32_init:
   5696
   5697	00001A42  FA				 cli
   5698
   5699	00001A43  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
   5700						 ASSUME	 DS:txdata
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 101
DarkX.ASM



   5701						 ; ajustamos pila para modo protegido
   5702	00001A4A  BC 00000000s			 mov	 esp,txpila
   5703	00001A4F  C1 E4	04			 shl	 esp,4
   5704	00001A52  81 C4	00004000		 add	 esp,size tx_pila
   5705
   5706						 ; ponemos el punto de retorno a PM para interrupciones	reales
   5707						 ASSUME	 DS:txcode32
   5708	00001A58  B8 000009EAr			 mov	 eax,offset pm_ret_point
   5709						 ASSUME	 DS:txdata
   5710	00001A5D  67| A3 0532r			 mov	 prot_code_address,eax
   5711
   5712	00001A61  66| 2E: A1 00000004r		 mov	 ax,cs:D32_SEL
   5713	00001A68  8E D8				 mov	 ds,ax		; selector del segmento	de datos
   5714	00001A6A  8E E0				 mov	 fs,ax
   5715	00001A6C  8E C0				 mov	 es,ax
   5716	00001A6E  8E E8				 mov	 gs,ax
   5717	00001A70  8E D0				 mov	 ss,ax
   5718
   5719	00001A72  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5720	00001A79  BA 000000E7r			 mov	 edx,offset sys_type_msg
   5721	00001A7E  B4 09				 mov	 ah,9
   5722	00001A80  CD 21				 int	 21h
   5723
   5724	00001A82  33 D2				 xor	 edx,edx
   5725	00001A84  67| 8A 16 0341r		 mov	 dl,system_type
   5726	00001A89  D1 E2				 shl	 edx,1
   5727	00001A8B  0A D2				 or	 dl,dl
   5728	00001A8D  75 0D				 jnz	 no_mires_si_xms
   5729	00001A8F  67| 83 3E 0347r 00		 cmp	 dword ptr xms_entry_point,0
   5730	00001A95  74 05				 jz	 no_mires_si_xms
   5731	00001A97  BA 00000006			 mov	 edx,3*2
   5732	00001A9C				 no_mires_si_xms:
   5733	00001A9C  66| 8B 92 000000FAr		 mov	 dx,word ptr [edx+sys_types]
   5734	00001AA3  CD 21				 int	 21h
   5735
   5736	00001AA5  BA 00000114r			 mov	 edx,offset dos_mem_msg
   5737	00001AAA  CD 21				 int	 21h
   5738
   5739	00001AAC  67| F6 06 0341r 02		 test	 system_type,2
   5740	00001AB2  74 0E				 jz	 normal_init_mem
   5741	00001AB4  67| 8B 0E 031Dr			 mov	 ecx,dos_mem_size
   5742	00001AB9  2E: 8E 1D 00000004r			 mov	 ds,cs:D32_SEL
   5743	00001AC0  EB 23					 jmp	 print_dos_mem
   5744
   5745	00001AC2				 normal_init_mem:
   5746	00001AC2  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL	 ; selector del	segmento de datos
   5747						 ; alojamos memoria DOS
   5748	00001AC9  E8 FFFFF9BE			 call	 init_dos_heap
   5749
   5750						 ; alojamos extendida
   5751	00001ACE  E8 FFFFFA06			 call	 init_extended_heap
   5752
   5753	00001AD3  B8 00000000s			 mov	 eax,txcode32
   5754	00001AD8  C1 E0	04			 shl	 eax,4
   5755	00001ADB  05 00002EF7r			 add	 eax,offset dos_heap_info
   5756	00001AE0  E8 FFFFF987			 call	 getmeminfo
   5757
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 102
DarkX.ASM



   5758	00001AE5				 print_dos_mem:
   5759	00001AE5  BF 00000000s			 mov	 edi,txcode32
   5760	00001AEA  C1 E7	04			 shl	 edi,4
   5761	00001AED  8B C1				 mov	 eax,ecx
   5762						 ASSUME	 DS:txcode32
   5763	00001AEF  C6 87	00004044r 24		 mov	 byte ptr [edi+number_string+10],"$"
   5764						 ASSUME	 DS:txdata
   5765	00001AF6  C1 E8	0A			 shr	 eax,10
   5766	00001AF9  81 C7	0000403Ar		 add	 edi,offset number_string
   5767	00001AFF  E8 FFFFFF04			 call	 bin_to_dec
   5768	00001B04  8B D7				 mov	 edx,edi
   5769	00001B06  B4 09				 mov	 ah,9
   5770	00001B08  CD 21				 int	 21h
   5771	00001B0A  1E				 push	 ds
   5772	00001B0B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5773	00001B12  BA 00000127r			 mov	 edx,offset extended_mem_msg
   5774	00001B17  CD 21				 int	 21h
   5775	00001B19  67| A0 0341r			 mov	 al,system_type
   5776	00001B1D  1F				 pop	 ds
   5777	00001B1E  A8 02				 test	 al,2
   5778	00001B20  74 1C				 jz	 no_dpmi_mem_info
   5779	00001B22  B8 00000500				 mov	 eax,500h
   5780	00001B27  1E					 push	 ds
   5781	00001B28  07					 pop	 es
   5782	00001B29  BF 00000000s				 mov	 edi,txcode32
   5783	00001B2E  C1 E7	04				 shl	 edi,4
   5784	00001B31  57					 push	 edi
   5785	00001B32  81 C7	00003869r			 add	 edi,offset print_buffer
   5786	00001B38  CD 31					 int	 31h
   5787	00001B3A  8B 07					 mov	 eax,[edi]
   5788	00001B3C  EB 15					 jmp	 have_dpmi_mem
   5789	00001B3E				 no_dpmi_mem_info:
   5790	00001B3E  B8 00000000s			 mov	 eax,txcode32
   5791	00001B43  C1 E0	04			 shl	 eax,4
   5792	00001B46  50				 push	 eax
   5793	00001B47  05 00003220r			 add	 eax,offset extended_heap_info
   5794	00001B4C  E8 FFFFF91B			 call	 getmeminfo
   5795	00001B51  8B C1				 mov	 eax,ecx
   5796	00001B53				 have_dpmi_mem:
   5797	00001B53  5F				 pop	 edi
   5798	00001B54  C1 E8	0A			 shr	 eax,10
   5799	00001B57  81 C7	0000403Ar		 add	 edi,offset number_string
   5800	00001B5D  E8 FFFFFEA6			 call	 bin_to_dec
   5801	00001B62  8B D7				 mov	 edx,edi
   5802	00001B64  B4 09				 mov	 ah,9
   5803	00001B66  CD 21				 int	 21h
   5804	00001B68  1E				 push	 ds
   5805	00001B69  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5806	00001B70  BA 0000013Dr			 mov	 edx,offset kb_msg
   5807	00001B75  CD 21				 int	 21h
   5808	00001B77  1F				 pop	 ds
   5809
   5810	00001B78  FB				 sti
   5811
   5812						 ; ///////////////////////////////
   5813						 ; CARGAMOS EL PROGRAMA	EN MEMORIA
   5814						 ; ///////////////////////////////
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 103
DarkX.ASM



   5815
   5816					 ; primero, intentamos cargarlo	como LE	y, si no lo es,	como DLINK executable
   5817
   5818					 ; loader de LE's
   5819					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5820					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5821					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5822
   5823	00001B79  2E: 8E 1D 00000014r		 mov	 ds, cs:DATA_SEL
   5824	00001B80  2E: 8E 05 0000000Cr		 mov	 es, cs:D16_SEL
   5825						 ASSUME	 ES:txdata
   5826	00001B87  26: 67| 8B 16	032Dr		 mov	 edx, es:program_name_ptr
   5827
   5828	00001B8D  E8 FFFFF9C2			 call	 LoadLE
   5829	00001B92  72 2C				 jc	 LEError
   5830
   5831	00001B94  2E: 8E 1D 00000014r		 mov	 ds, cs:DATA_SEL
   5832	00001B9B  2E: 8E 05 0000000Cr		 mov	 es, cs:D16_SEL
   5833						 ASSUME	 ES:txdata
   5834	00001BA2  26: 67| 8E 06	0335r		 mov	 es, es:psp_selector
   5835
   5836						 ; Ponemos en el PSP el	selector del segmento de vars. de entorno
   5837	00001BA8  66| 2E: 8B 1D	      +		 mov	 bx,cs:ENVRN_SEL
   5838		  00000018r
   5839	00001BB0  66| 26: 67| 89 1E   +		 mov	 es:[2Ch],bx
   5840		  002C
   5841
   5842	00001BB7  2E: FF 35 00000010r		 push	 dword ptr cs:CODE_SEL
   5843	00001BBE  50				 push	 eax
   5844	00001BBF  CB				 retf
   5845
   5846	00001BC0			 LEError:
   5847					 ; E_FILE_ERROR
   5848					 ; E_NOT_LE
   5849					 ; E_NOT_ENOUGH_MEM
   5850					 ; E_UNSUPORTED_FEATURE
   5851
   5852	00001BC0  83 F8	01			 cmp	 eax, E_NOT_LE			 ; Si no ‚s un LE carrega el DLINK
   5853	00001BC3  74 26				 je	 load_dlink_file
   5854
   5855	00001BC5  BA 00000213r			 mov	 edx, offset load_error_msg	 ; error_loading_LE
   5856	00001BCA  83 F8	00			 cmp	 eax, E_FILE_ERROR
   5857	00001BCD  0F 84	00000240		 je	 pm_error
   5858
   5859	00001BD3  BA 00000257r			 mov	 edx,offset unsuported_feature_msg
   5860	00001BD8  83 F8	03			 cmp	 eax, E_UNSUPORTED_FEATURE
   5861	00001BDB  0F 84	00000232		 je	 pm_error
   5862
   5863	00001BE1  BA 000001EAr			 mov	 edx, offset exe_size_error_msg
   5864	00001BE6  E9 00000228			 jmp	 pm_error
   5865
   5866	00001BEB			 load_dlink_file:
   5867
   5868					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5869					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5870					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5871
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 104
DarkX.ASM



   5872
   5873					 ; loader de DLINK executables
   5874						 INCLUDE dlnkload.inc
1  5875					 ASSUME	 DS:txdata
1  5876					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5877					 ; DLINK Executable Loader
1  5878					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5879					 ASSUME	 ES:txdata
1  5880	00001BEB  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  5881	00001BF2  26: 67| 8B 16	032Dr		 mov	 edx,es:program_name_ptr
1  5882	00001BF8  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  5883	00001BFF  66| B8 3D00			 mov	 ax,3D00h	 ; open	for reading
1  5884	00001C03  CD 21				 int	 21h
1  5885	00001C05  0F 82	00000201		 jc	 load_error
1  5886
1  5887	00001C0B  8B D8				 mov	 ebx,eax
1  5888	00001C0D  B9 00000000s			 mov	 ecx,txcode32
1  5889	00001C12  81 E9	00000000s		 sub	 ecx,txdata
1  5890	00001C18  C1 E1	04			 shl	 ecx,4
1  5891	00001C1B  81 C1	000020F7r		 add	 ecx,offset code_end+512  ; ECX	= stub size (+512 for EXE header)
1  5892	00001C21  8B D1				 mov	 edx,ecx
1  5893	00001C23  C1 E9	10			 shr	 ecx,16
1  5894	00001C26  B4 42				 mov	 ah,42h		 ; like	this it's smaller than AX,4200h	;)
1  5895	00001C28  32 C0				 xor	 al,al		 ; <---
1  5896	00001C2A  CD 21				 int	 21h
1  5897	00001C2C  0F 82	000001DA		 jc	 load_error
1  5898
1  5899	00001C32  B4 3F				 mov	 ah,3Fh
1  5900	00001C34  BA 00000000s			 mov	 edx,txcode32
1  5901	00001C39  C1 E2	04			 shl	 edx,4
1  5902	00001C3C  81 C2	00003869r		 add	 edx,offset print_buffer
1  5903	00001C42  B9 00000028			 mov	 ecx,28h	 ; DLINK exe header size
1  5904	00001C47  CD 21				 int	 21h
1  5905	00001C49  0F 82	000001BD		 jc	 load_error
1  5906
1  5907	00001C4F  2E: 81 3D 00003869r +		 cmp	 dword ptr cs:print_buffer,'madA'
   5908		  6D616441
1  5909	00001C5A  BA 000002C4r			 mov	 edx,offset bad_exec_error_msg
1  5910	00001C5F  0F 85	000001AE		 jnz	 pm_error
1  5911	00001C65  2E: F6 05 0000388Dr +		 test	 byte ptr cs:print_buffer+24h,1
   5912		  01
1  5913	00001C6D  BA 000002F7r			 mov	 edx,offset comp_exe_error_msg
1  5914	00001C72  0F 85	0000019B		 jnz	 pm_error
1  5915	00001C78  53				 push	 ebx
1  5916	00001C79  2E: 8B 1D 0000387Dr		 mov	 ebx,dword ptr cs:print_buffer+14h
1  5917	00001C80  2E: A1 00003889r		 mov	 eax,dword ptr cs:print_buffer+20h
1  5918	00001C86  C1 E0	02			 shl	 eax,2
1  5919	00001C89  03 D8				 add	 ebx,eax	 ; size	of mem.	needed + size of reloc.	table
1  5920	00001C8B  66| 8B CB			 mov	 cx,bx
1  5921	00001C8E  C1 EB	10			 shr	 ebx,16
1  5922
1  5923						 ; alojamos memoria para el programa
1  5924	00001C91  66| B8 0501			 mov	 ax,501h
1  5925	00001C95  CD 31				 int	 31h
1  5926	00001C97  BA 000001EAr			 mov	 edx,offset exe_size_error_msg
1  5927	00001C9C  73 30				 jnc	 have_mem_for_exe
1  5928						 ; si no hay extendida,	usamos memoria DOS
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 105
DarkX.ASM



1  5929	00001C9E  66| B8 0100			 mov	 ax,100h
1  5930	00001CA2  C1 E3	10			 shl	 ebx,16
1  5931	00001CA5  66| 8B D9			 mov	 bx,cx
1  5932	00001CA8  81 FB	000A0000		 cmp	 ebx,655360	 ; 640 Kb
1  5933	00001CAE  0F 83	0000014A		 jae	 exe_size_error
1  5934	00001CB4  C1 EB	04			 shr	 ebx,4
1  5935	00001CB7  CD 31				 int	 31h
1  5936	00001CB9  0F 82	0000013F		 jc	 exe_size_error
1  5937	00001CBF  0F B7	C0			 movzx	 eax,ax
1  5938	00001CC2  C1 E0	04			 shl	 eax,4
1  5939	00001CC5  66| 8B C8			 mov	 cx,ax
1  5940	00001CC8  C1 E8	10			 shr	 eax,16
1  5941	00001CCB  66| 8B D8			 mov	 bx,ax
1  5942	00001CCE				 have_mem_for_exe:
1  5943	00001CCE  C1 E3	10			 shl	 ebx,16
1  5944	00001CD1  66| 8B D9			 mov	 bx,cx
1  5945	00001CD4  8B D3				 mov	 edx,ebx	 ; EDX = linear	address	of buffer
1  5946
1  5947	00001CD6  5B				 pop	 ebx
1  5948	00001CD7  52				 push	 edx
1  5949	00001CD8  66| B8 4201			 mov	 ax,4201h
1  5950	00001CDC  2E: 8B 0D 00003875r		 mov	 ecx,dword ptr cs:print_buffer+0Ch
1  5951	00001CE3  83 E9	28			 sub	 ecx,28h
1  5952	00001CE6  66| 8B D1			 mov	 dx,cx
1  5953	00001CE9  C1 E9	10			 shr	 ecx,16
1  5954	00001CEC  CD 21				 int	 21h
1  5955	00001CEE  0F 82	00000118		 jc	 load_error
1  5956
1  5957	00001CF4  5A				 pop	 edx
1  5958	00001CF5  2E: 8B 0D 00003879r		 mov	 ecx,dword ptr cs:print_buffer+10h
1  5959	00001CFC  2E: A1 00003889r		 mov	 eax,dword ptr cs:print_buffer+20h
1  5960	00001D02  C1 E0	02			 shl	 eax,2
1  5961	00001D05  03 C8				 add	 ecx,eax	 ; exec. size +	relocation table
1  5962	00001D07  B4 3F				 mov	 ah,3Fh
1  5963	00001D09  CD 21				 int	 21h
1  5964	00001D0B  0F 82	000000FB		 jc	 load_error
1  5965
1  5966						 ; closing archive...
1  5967	00001D11  B4 3E				 mov	 ah,3Eh
1  5968	00001D13  32 C0				 xor	 al,al
1  5969	00001D15  CD 21				 int	 21h
1  5970
1  5971						 ; arreglamos selectores de c¢digo y datos del programa
1  5972	00001D17  26: 67| 89 16	0321r		 mov	 dword ptr es:program_offset,edx
1  5973	00001D1D  66| 26: 67| 89 16   +		 mov	 word ptr es:code_desc+2,dx
   5974		  058Er
1  5975	00001D24  66| 26: 67| 89 16   +		 mov	 word ptr es:data_desc+2,dx
   5976		  0596r
1  5977	00001D2B  C1 EA	10			 shr	 edx,16
1  5978	00001D2E  26: 67| 88 16	0590r		 mov	 byte ptr es:code_desc+4,dl
1  5979	00001D34  26: 67| 88 36	0593r		 mov	 byte ptr es:code_desc+7,dh
1  5980	00001D3A  26: 67| 88 16	0598r		 mov	 byte ptr es:data_desc+4,dl
1  5981	00001D40  26: 67| 88 36	059Br		 mov	 byte ptr es:data_desc+7,dh
1  5982
1  5983	00001D46  26: 67| F6 06	0341r +		 test	 es:system_type,2
   5984		  02
1  5985	00001D4D  74 2E				 jz	 no_dpmi_sel_fixup
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 106
DarkX.ASM



1  5986	00001D4F  66| B8 000C				 mov	 ax,0Ch
1  5987	00001D53  66| 2E: 8B 1D	      +			 mov	 bx,cs:CODE_SEL
   5988		  00000010r
1  5989	00001D5B  BF 0000058Cr				 mov	 edi,offset code_desc
1  5990	00001D60  CD 31					 int	 31h
1  5991	00001D62  0F 82	0000009D			 jc	 desc_alloc_error
1  5992	00001D68  66| 2E: 8B 1D	      +			 mov	 bx,cs:DATA_SEL
   5993		  00000014r
1  5994	00001D70  BF 00000594r				 mov	 edi,offset data_desc
1  5995	00001D75  CD 31					 int	 31h
1  5996	00001D77  0F 82	00000088			 jc	 desc_alloc_error
1  5997
1  5998	00001D7D				 no_dpmi_sel_fixup:
1  5999						 ; rellenamos info sobre el EXE
1  6000						 ; tama¤o
1  6001	00001D7D  B8 00000000s			 mov	 eax,txcode32
1  6002	00001D82  2D 00000000s			 sub	 eax,txdata
1  6003	00001D87  C1 E0	04			 shl	 eax,4
1  6004	00001D8A  05 000020F7r			 add	 eax,offset code_end+512  ; EAX	= stub size
1  6005	00001D8F  2E: 03 05 00003871r		 add	 eax,dword ptr cs:print_buffer+8
1  6006	00001D96  26: 67| A3 033Br		 mov	 es:exe_size,eax
1  6007						 ; offset PSP
1  6008	00001D9B  26: 67| 8B 1E	0321r		 mov	 ebx,es:program_offset
1  6009	00001DA1  26: 67| 29 1E	0325r		 sub	 es:psp_offset,ebx
1  6010						 ; offset ENV
1  6011	00001DA7  26: 67| 29 1E	0329r		 sub	 es:env_offset,ebx
1  6012						 ; offset nombre
1  6013	00001DAD  26: 67| 29 1E	032Dr		 sub	 es:program_name_ptr,ebx
1  6014
1  6015	00001DB3  66| 2E: A1 00000014r		 mov	 ax,cs:DATA_SEL
1  6016	00001DBA  8E D8				 mov	 ds,ax
1  6017	00001DBC  8E C0				 mov	 es,ax
1  6018	00001DBE  8E E0				 mov	 fs,ax
1  6019	00001DC0  8E E8				 mov	 gs,ax
1  6020	00001DC2  FA				 cli
1  6021	00001DC3  8E D0				 mov	 ss,ax
1  6022	00001DC5  2E: 8B 25 00003885r		 mov	 esp,dword ptr cs:print_buffer+1Ch	 ; INITIAL ESP
1  6023	00001DCC  FB				 sti
1  6024
1  6025	00001DCD  2E: 8B 0D 00003889r		 mov	 ecx,dword ptr cs:print_buffer+20h
1  6026	00001DD4  0B C9				 or	 ecx,ecx
1  6027	00001DD6  74 17				 jz	 no_fixup_needed
1  6028	00001DD8  2E: 8B 35 00003879r		 mov	 esi,dword ptr cs:print_buffer+10h
1  6029	00001DDF  2E: A1 00000014r		 mov	 eax,dword ptr cs:DATA_SEL
1  6030	00001DE5				 selector_fixup:
1  6031	00001DE5  8B 3E					 mov	 edi,[esi]
1  6032	00001DE7  66| 89 07				 mov	 [edi],ax
1  6033	00001DEA  83 C6	04				 add	 esi,4
1  6034	00001DED  E2 F6				 loop	 selector_fixup
1  6035
1  6036	00001DEF				 no_fixup_needed:
1  6037	00001DEF  2E: FF 35 00000010r		 push	 dword ptr cs:CODE_SEL
1  6038	00001DF6  2E: FF 35 00003881r		 push	 dword ptr cs:print_buffer+18h		 ; INITIAL EIP
1  6039	00001DFD  CB				 retf
1  6040
1  6041	00001DFE			 exe_size_error:
1  6042	00001DFE  BA 000001EAr			 mov	 edx,offset exe_size_error_msg
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 107
DarkX.ASM



1  6043	00001E03  EB 0E				 jmp	 pm_error
1  6044	00001E05			 desc_alloc_error:
1  6045	00001E05  BA 0000029Er			 mov	 edx,offset desc_alloc_error_msg
1  6046	00001E0A  EB 07				 jmp	 pm_error
1  6047	00001E0C			 load_error:
1  6048	00001E0C  BA 00000213r			 mov	 edx,offset load_error_msg
1  6049	00001E11  EB 00				 jmp	 pm_error
1  6050
1  6051
1  6052
1  6053
   6054
   6055					 ; salida de error en la carga de ejecutable com£n a LE	y DLINK	loaders
   6056	00001E13			 pm_error:
   6057	00001E13  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   6058	00001E1A  B4 09				 mov	 ah,9
   6059	00001E1C  CD 21				 int	 21h
   6060	00001E1E  66| B8 4C01			 mov	 ax,4C01h
   6061	00001E22  CD 21				 int	 21h
   6062
   6063	00001E24				 salida:
   6064						 ASSUME	DS:txdata
   6065	00001E24  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   6066	00001E2B  67| F6 06 0341r 02		 test	 system_type,2
   6067	00001E31  75 35				 jnz	 salida_dpmi
   6068
   6069						 ; iniciamos la	reentrada
   6070	00001E33  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_sel
   6071	00001E3A  BB 00000000s			 mov	 ebx,txcode
   6072	00001E3F  C1 E3	04			 shl	 ebx,4
   6073						 ASSUME	 DS:txcode
   6074	00001E42  81 C3	00000019r		 add	 ebx,offset saltito+1
   6075	00001E48  66| C7 03 09F5r		 mov	 word ptr [ebx],offset s16
   6076	00001E4D  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL	 ; hay que cargarlos antes de llamar a RET_REAL
   6077	00001E54  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
   6078	00001E5B  2E: FF 35 00000008r		 push	 dword ptr cs:C16_sel
   6079						 pushd	 ret_real
1  6080	00001E62  68				 db 68h
1  6081	00001E63  09BEr	0000			 dw offset ret_real,0
   6082	00001E67  CB				 retf
   6083
   6084					 ; Punto de salida bajo	DPMI
   6085	00001E68				 salida_dpmi:
   6086						 ASSUME	 DS:txdata
   6087						 ; recuperamos excepciones
   6088	00001E68  32 DB				 xor	 bl,bl
   6089	00001E6A  BF 00000443r			 mov	 edi,offset dpmi_exc_handlers
   6090	00001E6F				 restore_ints:
   6091	00001E6F  8B 17					 mov	 edx,[edi]
   6092	00001E71  66| 8B 4F 04				 mov	 cx,[edi+4]
   6093	00001E75  66| B8 0203				 mov	 ax,203h
   6094	00001E79  CD 31					 int	 31h
   6095	00001E7B  83 C7	06				 add	 edi,6
   6096	00001E7E  FE C3					 inc	 bl
   6097	00001E80  80 FB	0F			 cmp	 bl,15
   6098	00001E83  75 EA				 jnz restore_ints
   6099
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 108
DarkX.ASM



   6100						 ; recuperamos las interrupciones
   6101						 ASSUME	 ES:txcode32
   6102	00001E85  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
   6103	00001E8C  32 DB				 xor	 bl,bl
   6104	00001E8E  BF 00000000s			 mov	 edi,txcode32
   6105	00001E93  C1 E7	04			 shl	 edi,4
   6106	00001E96				 recupera_ints:
   6107							 ASSUME	 ES:txcode32
   6108	00001E96  26: 8B 97 00001EF7r			 mov	 edx,dword ptr es:[edi+idt]
   6109	00001E9D  66| 26: 8B 8F	      +			 mov	 cx,word ptr es:[edi+idt+4]
   6110		  00001EFBr
   6111							 ASSUME	 ES:txdata
   6112	00001EA5  66| B8 0205				 mov	 ax,205h
   6113	00001EA9  CD 31					 int	 31h
   6114	00001EAB  83 C7	06				 add	 edi,6
   6115	00001EAE  FE C3				 inc bl
   6116	00001EB0  75 E4				 jnz recupera_ints
   6117
   6118						 ; si se produjo una excepci¢n,	salimos	con info de debugging
   6119	00001EB2  67| 80 3E 04A9r 00		 cmp	 dpmi_exception_flag,0
   6120	00001EB8  74 30				 jz	 any_exception
   6121	00001EBA  66| B8 0003			 mov	 ax,3
   6122	00001EBE  CD 10				 int	 10h
   6123	00001EC0  33 C0				 xor	 eax,eax
   6124	00001EC2  50				 push	 eax
   6125	00001EC3  83 EC	08			 sub	 esp,4*2
   6126	00001EC6  66| B8 0000s			 mov	 ax,txdata
   6127	00001ECA  66| 50			 push	 ax
   6128	00001ECC  83 EC	02			 sub	 esp,2
   6129	00001ECF  FC				 cld
   6130	00001ED0  66				 db	 66h		 ; push	de un WORD en segmento de 32 bits
   6131	00001ED1  66| 9C			 pushf
   6132	00001ED3  66| BA 06CEr			 mov	 dx,offset debug_info_msg
   6133	00001ED7  B4 09				 mov	 ah,9
   6134	00001ED9  60				 pushad
   6135	00001EDA  8B FC				 mov	 edi,esp
   6136	00001EDC  16				 push	 ss
   6137	00001EDD  07				 pop	 es
   6138	00001EDE  66| BB 0021			 mov	 bx,21h
   6139	00001EE2  33 C9				 xor	 ecx,ecx
   6140	00001EE4  66| B8 0300			 mov	 ax,300h
   6141	00001EE8  CD 31				 int	 31h
   6142
   6143	00001EEA				 any_exception:
   6144						 ; restauramos la base de las irq's y salimos al OS
   6145	00001EEA  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
   6146						 pushd	 exit_redirless
1  6147	00001EF1  68				 db 68h
1  6148	00001EF2  0A2Cr	0000			 dw offset exit_redirless,0
   6149	00001EF6  CB				 retf
   6150
   6151					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   6152	00001EF7			 code_end:
   6153					 ; Interrupt Descriptor	Table
   6154	00001EF7  0200*(????????)	 idt		 dd 256*2 dup(?)
   6155
   6156					 ; tabla de redireccionamientos	de interrupciones
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 109
DarkX.ASM



   6157	000026F7  0200*(????????)	 interrup_redir	 dd 256*2 dup(?)
   6158
   6159	00002EF7  ???????? ????????	 dos_heap_info		 dd ?,?
   6160	00002EFF  0321*(??)		 dos_pointers		 db 8*100+1 dup(?)
   6161
   6162	00003220  ???????? ????????	 extended_heap_info	 dd ?,?
   6163	00003228  0321*(??)		 extended_pointers	 db 8*100+1 dup(?)
   6164
   6165	00003549  0320*(??)		 xms_handles		 db 8*100 dup(?)
   6166
   6167	00003869  07D1*(??)		 print_buffer		 db 80*25+1 dup(?)
   6168
   6169	0000403A  0B*(??)		 number_string		 db 11 dup(?)
   6170	00004045			 TXCODE32  ENDS
   6171
   6172					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   6173
   6174	    0000			 TXPILA		 SEGMENT PARA STACK USE16 'STACK'
   6175	    0000  1000*(????????)	 tx_pila	 dd	 PM_STACKSIZE dup(?)
   6176	    4000			 TXPILA		 ENDS
   6177
   6178					 ; pila	auxiliar para procedimientos reales
   6179	    0000			 TXPILA_REAL	 SEGMENT PARA USE16 'STACK'
   6180	    0000  1000*(????????)	 txpr		 dd	 RM_STACKSIZE dup(?)	  ; 30 words es	el m¡nimo
   6181	    4000			 TXPILA_REAL	 ENDS
   6182
   6183	00000000			 DISK		 SEGMENT PARA
   6184	00000000  8000*(??)		 disk_buffer	 db	 8000h dup(?)	 ; 32Kb	would be ok ;)
   6185	00008000			 DISK		 ENDS
   6186
   6187					 END init_pm
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 110
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/06/99"
??FILENAME			  Text	 "DarkX	  "
??TIME				  Text	 "07:39:48"
??VERSION			  Number 030A
@CPU				  Text	 0F8FH
@CURSEG				  Text	 DISK
@FILENAME			  Text	 DARKX
@WORDSIZE			  Text	 4
A20_BUCLE1			  Near	 TXCODE:0C8D
A20_BUCLE2			  Near	 TXCODE:0C98
A20_CHECK_STATE			  Near	 TXCODE:0C4C
A20_ENABLED			  Near	 TXCODE:0C4B
A20_ERROR_MSG			  Byte	 TXDATA:0165
A20_OK				  Near	 TXCODE:07F7
ADDHEAP				  Near	 TXCODE32:1236
ADDRESS_FOUND			  Near	 TXCODE32:086E
ADD_HEAPS			  Near	 TXCODE32:14BA
AH_ADD				  Near	 TXCODE32:1258
AH_LP				  Near	 TXCODE32:124D
ALLOCATED_CB			  Number 0001
ALLOC_DESC			  Near	 TXCODE32:04F3
ALLOC_DOS_MEM			  Near	 TXCODE:0A89
ALLOC_EM			  Near	 TXCODE32:0536
ALLOC_ERROR			  Near	 TXCODE32:044D
ANY_EXCEPTION			  Near	 TXCODE32:1EEA
AVOID_V86_TEST			  Near	 TXCODE:07CB
BACK_FROM_DPMI_INT		  Near	 TXCODE32:0212
BACK_FROM_IRQ16			  Near	 TXCODE32:0AB3
BAD_EXEC_ERROR_MSG		  Byte	 TXDATA:02C4
BIN_TO_DEC			  Near	 TXCODE32:1A08
BIN_TO_HEX			  Near	 TXCODE32:0E45
BYTES_IN_STACK			  Word	 TXCODE:04B8
C16_DESC			  Word	 TXDATA:057C
C16_SEL				  Word	 TXCODE32:0008
C32_INIT			  Near	 TXCODE32:1A42
C32_SEL				  Word	 TXCODE32:0000
CALLBACKS			  Number 0020
CALLBACK_ADDRESS_TABLE		  Near	 TXCODE:04D7
CALLBACK_ALLOC			  Near	 TXCODE32:07D2
CALLBACK_CODE			  Word	 TXCODE:0690
CALLBACK_DATA			  Word	 TXDATA:0CFF
CALLBACK_FREE			  Near	 TXCODE32:0847
CALLBACK_MANAGER		  Near	 TXCODE:05F5
CALLBACK_PM			  Near	 TXCODE32:0E61
CBACK16_RETURN			  Near	 TXCODE:0645
CBSLOT				  Number 01E0
CB_FOUND			  Near	 TXCODE32:07FF
CHECK_LE			  Near	 TXCODE32:15EF
CIFRA0				  Near	 TXCODE32:0E52
CIFRA1				  Near	 TXCODE32:0E5E
CODE_DESC			  Word	 TXDATA:058C
CODE_DESCRIPTOR			  Word	 TXDATA:056C
CODE_END			  Near	 TXCODE32:1EF7
CODE_SEL			  Word	 TXCODE32:0010
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 111
Symbol Table



COMP_EXE_ERROR_MSG		  Byte	 TXDATA:02F7
CONTINUA_VOLCADO		  Near	 TXCODE32:0BA8
CONTINUE_LOADING		  Near	 TXCODE32:179D
CONT_ADDING			  Near	 TXCODE:0A99
CONT_ADDING_XMS			  Near	 TXCODE:0807
CONT_SEARCHING			  Near	 TXCODE:06B6
CONVERT				  Near	 TXCODE32:0E29
COPIA_SELS			  Near	 TXCODE:02BC
COPYRIGHT_MSG			  Byte	 TXDATA:0000
COPY_FILE_NAME			  Near	 TXCODE32:1009
COPY_NAME			  Near	 TXCODE32:1028
COPY_STRING			  Near	 TXCODE32:1059
COULDNT_FIND_EM			  Near	 TXCODE32:052B
CPU386				  Byte	 TXDATA:00B2
CPU486				  Byte	 TXDATA:00B6
CPUID				  Near	 TXCODE:0CA8
CPU_INFO			  Word	 TXDATA:033F
CPU_STRINGS			  Word	 TXDATA:00AC
CPU_TYPE_MSG			  Byte	 TXDATA:009B
CRASH_CODE			  Byte	 TXDATA:079A
CURRENT_STACKFRAME		  Dword	 TXCODE:0682
CURR_FIXUP_PAG			  Dword	 TXDATA:0CE5
CURR_PAGE			  Dword	 TXDATA:0CE1
CURR_PAGE_OFF			  Dword	 TXDATA:0CF1
D16_DESC			  Word	 TXDATA:0584
D16_SEL				  Word	 TXCODE32:000C
D32_SEL				  Word	 TXCODE32:0004
DATA_DESC			  Word	 TXDATA:0594
DATA_DESCRIPTOR			  Word	 TXDATA:0574
DATA_SEL			  Word	 TXCODE32:0014
DEBUG_CS			  Byte	 TXDATA:0786
DEBUG_CS1			  Byte	 TXDATA:0965
DEBUG_DS			  Byte	 TXDATA:0992
DEBUG_EAX			  Byte	 TXDATA:0852
DEBUG_EBP			  Byte	 TXDATA:08BD
DEBUG_EBX			  Byte	 TXDATA:0864
DEBUG_ECX			  Byte	 TXDATA:0876
DEBUG_EDI			  Byte	 TXDATA:08AB
DEBUG_EDX			  Byte	 TXDATA:0888
DEBUG_EIP			  Byte	 TXDATA:078B
DEBUG_ES			  Byte	 TXDATA:09BF
DEBUG_ESI			  Byte	 TXDATA:0899
DEBUG_ESP			  Byte	 TXDATA:08CF
DEBUG_ESP0			  Byte	 TXDATA:07D1
DEBUG_FLAGS			  Byte	 TXDATA:08E3
DEBUG_FS			  Byte	 TXDATA:09EC
DEBUG_GS			  Byte	 TXDATA:0A19
DEBUG_INFO			  Near	 TXCODE:0A69
DEBUG_INFO_MSG			  Byte	 TXDATA:06CE
DEBUG_SS			  Byte	 TXDATA:0A46
DEBUG_SS0			  Byte	 TXDATA:07CC
DECIDE_SPACE_FROM_NOW		  Near	 TXCODE32:1A2B
DESC_ALLOC_ERROR		  Near	 TXCODE32:1E05
DESC_ALLOC_ERROR_MSG		  Byte	 TXDATA:029E
DESC_CS				  Byte	 TXDATA:0974
DESC_DS				  Byte	 TXDATA:09A1
DESC_ES				  Byte	 TXDATA:09CE
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 112
Symbol Table



DESC_FS				  Byte	 TXDATA:09FB
DESC_GS				  Byte	 TXDATA:0A28
DESC_SS				  Byte	 TXDATA:0A55
DETERMINE_SYS			  Near	 TXCODE32:08EA
DIR_BASE			  Dword	 TXDATA:0351
DISK_BUFFER			  Byte	 DISK:0000
DISK_SEG			  Word	 TXDATA:0339
DONT_DO_ZERO_EXTENT		  Near	 TXCODE32:18F1
DONT_READ_BLOCKS		  Near	 TXCODE32:10F7
DONT_SPLIT			  Near	 TXCODE32:12BF
DONT_WRITE_BLOCKS		  Near	 TXCODE32:1199
DOS32_INFO			  Near	 TXCODE32:096A
DOS32_SYS_INFO			  Near	 TXCODE32:0943
DOS_ALLOC_ERROR			  Near	 TXCODE32:0301
DOS_HEAP_DONE			  Near	 TXCODE:0AD7
DOS_HEAP_INFO			  Dword	 TXCODE32:2EF7
DOS_INT				  Near	 TXCODE32:0FE4
DOS_MEMORY			  Number 0001
DOS_MEM_ALLOC			  Near	 TXCODE32:02BB
DOS_MEM_FREE			  Near	 TXCODE32:031F
DOS_MEM_MSG			  Byte	 TXDATA:0114
DOS_MEM_RESIZE			  Near	 TXCODE32:035E
DOS_MEM_SIZE			  Dword	 TXDATA:031D
DOS_POINTERS			  Byte	 TXCODE32:2EFF
DOS_VERSION_ERROR_MSG		  Byte	 TXDATA:0144
DO_CLEANUP			  Near	 TXCODE32:19B9
DPMI_32B_ERROR			  Byte	 TXDATA:0380
DPMI_ERROR			  Near	 TXCODE:01DF
DPMI_EXCEPTION_EXIT		  Near	 TXCODE32:0D78
DPMI_EXCEPTION_FLAG		  Byte	 TXDATA:04A9
DPMI_EXC_HANDLERS		  Byte	 TXDATA:0443
DPMI_HANDLES_STANDARD_FUNCS	  Near	 TXCODE32:0136
DPMI_INIT			  Near	 TXCODE:0227
DPMI_INIT_ERROR			  Byte	 TXDATA:03A6
DPMI_INT21_PASS			  Near	 TXCODE32:0FCA
DPMI_MODE_SWITCH		  Dword	 TXCODE:0234
DPMI_MSG			  Byte	 TXDATA:010B
DPMI_OLD_INT21H			  Word	 TXDATA:049D
DPMI_OLD_INT31H			  Word	 TXDATA:04A3
DPMI_PM_TO_REAL			  Word	 TXDATA:0401
DPMI_PRIVATE_BUFFER		  Word	 TXDATA:03F1
DPMI_REAL_TO_PM			  Dword	 TXDATA:03FD
DPMI_RM_CALL			  Byte	 TXDATA:0407
DPMI_RM_CALL_STRUC		  Word	 TXDATA:03BF
DPMI_RM_INT			  Near	 TXCODE:039A
DPMI_SAVE_RESTORE_PM		  Word	 TXDATA:03F7
DPMI_SAVE_RESTORE_REAL		  Dword	 TXDATA:03F3
DPMI_SELS			  Dword	 TXDATA:0427
DPMI_SET_EXCS			  Near	 TXCODE:0300
ENABLE_A20			  Near	 TXCODE:0C17
END_FIXUP			  Near	 TXCODE32:1956
END_OF_CB_ADDRESS		  Near	 TXCODE:04DE
END_OF_FILL			  Near	 TXCODE32:16F9
END_OF_NAME			  Near	 TXCODE32:1035
END_PUT				  Near	 TXCODE32:0D16
ENVRN_SEL			  Word	 TXCODE32:0018
ENV_DESC			  Word	 TXDATA:059C
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 113
Symbol Table



ENV_OFFSET			  Dword	 TXDATA:0329
ENV_SEL				  Number 0038
ENV_SELECTOR			  Word	 TXDATA:0337
ERROR_HANDLE			  Near	 TXCODE:0D93
ERROR_HANDLE1			  Near	 TXCODE:0D99
ERROR_LOADING			  Near	 TXCODE32:199D
ERROR_STRING			  Byte	 TXDATA:06D5
ERROR_STRING_TABLE		  Word	 TXDATA:0626
ES_AL				  Near	 TXCODE32:0E13
ES_AX				  Near	 TXCODE32:0E19
ES_EAX				  Near	 TXCODE32:0E22
EXCEPTIONS			  Near	 TXCODE32:0AEC
EXCEPTION_NUMBER		  Byte	 TXDATA:0719
EXC_0				  Byte	 TXDATA:0646
EXC_1				  Byte	 TXDATA:0656
EXC_13				  Byte	 TXDATA:0687
EXC_14				  Byte	 TXDATA:06A2
EXC_6				  Byte	 TXDATA:0666
EXC_7				  Byte	 TXDATA:0675
EXC_DEFAULT			  Byte	 TXDATA:06AD
EXE_INFO_STRUC			  Word	 TXDATA:0321
EXE_SIZE			  Dword	 TXDATA:033B
EXE_SIZE_ERROR			  Near	 TXCODE32:1DFE
EXE_SIZE_ERROR_MSG		  Byte	 TXDATA:01EA
EXIT_REDIRLESS			  Near	 TXCODE:0A2C
EXTENDED_HEAP_INFO		  Dword	 TXCODE32:3220
EXTENDED_HEAP_SIZE		  Dword	 TXDATA:0343
EXTENDED_INIT_DONE		  Near	 TXCODE32:152E
EXTENDED_INIT_FOUND		  Near	 TXCODE:090E
EXTENDED_MEM_MSG		  Byte	 TXDATA:0127
EXTENDED_POINTERS		  Byte	 TXCODE32:3228
EXT_FREE_ERROR			  Near	 TXCODE32:048A
EXT_MEM_ALLOC			  Near	 TXCODE32:0404
EXT_MEM_FREE			  Near	 TXCODE32:0457
EXT_MEM_INFO			  Near	 TXCODE32:03BB
EXT_MEM_RESIZE			  Near	 TXCODE32:048F
E_FILE_ERROR			  Number 0000
E_NOT_ENOUGH_MEM		  Number 0002
E_NOT_LE			  Number 0001
E_UNSUPORTED_FEATURE		  Number 0003
FIN				  Near	 TXCODE:0A05
FIND_THE_REST			  Near	 TXCODE32:051C
FIN_PROGRAMA			  Near	 TXCODE32:0FD3
FIXED_UP			  Near	 TXCODE32:1951
FIXUP_NEXT_PAGE			  Near	 TXCODE32:17F6
FIX_IRQS			  Near	 TXCODE:0B70
FOUND_DESCS			  Near	 TXCODE32:0531
FOUND_ONE_SLOT			  Near	 TXCODE32:051A
FOUND_SPACE_FOR_PAGING		  Near	 TXCODE32:0775
FPU287				  Byte	 TXDATA:00D5
FPU387				  Byte	 TXDATA:00DB
FPU487				  Byte	 TXDATA:00E1
FPUID				  Near	 TXCODE:0D37
FPU_FOUND			  Near	 TXCODE:0D90
FPU_INFO			  Byte	 TXDATA:0342
FPU_STATUS			  Word	 TXCODE:0D91
FPU_STRINGS			  Word	 TXDATA:00C3
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 114
Symbol Table



FREE				  Near	 TXCODE32:12D7
FREE_CB				  Number 0000
FREE_DESC			  Near	 TXCODE32:0570
FREE_DESCS			  Number 000A
FREE_DESCS_HANDLES		  Byte	 TXDATA:061C
FREE_DESCS_START		  Byte	 TXDATA:05CC
FREE_DESC_ERROR			  Near	 TXCODE32:059B
FREE_XMS_BLOCKS			  Near	 TXCODE:0A4D
F_END				  Near	 TXCODE32:133D
F_NEXT				  Near	 TXCODE32:130E
GDT				  Word	 TXDATA:0564
GDT_BASE			  Dword	 TXDATA:053E
GDT_LIMIT			  Word	 TXDATA:053C
GDT_REG				  Pword	 TXDATA:053C
GENERIC_FILE_SERVICE		  Near	 TXCODE32:1092
GEN_IDT				  Near	 TXCODE:0B04
GEN_INTS			  Near	 TXCODE:0B51
GETMEMINFO			  Near	 TXCODE32:146C
GET_ALL_MEM			  Near	 TXCODE:096D
GET_DOS_MEM			  Near	 TXCODE:0DD2
GET_INT_VECTOR			  Near	 TXCODE32:0635
GET_MEMORY			  Near	 TXCODE32:1668
GET_PROGRAM_INFO		  Near	 TXCODE32:0913
GET_PSP_SEL			  Near	 TXCODE32:11FA
GET_RM_INT_VEC			  Near	 TXCODE32:0888
GET_SEG_BASE			  Near	 TXCODE32:05ED
GET_SEG_BASE_ERROR		  Near	 TXCODE32:0632
GET_SYS_INFO			  Near	 TXCODE32:08CE
GET_THIS_BASE			  Near	 TXCODE32:0617
GMI_C				  Near	 TXCODE32:147E
GMI_END				  Near	 TXCODE32:148B
GMI_LP				  Near	 TXCODE32:1472
GMI_NXT				  Near	 TXCODE32:1480
GUARDA_EXCS			  Near	 TXCODE:02DE
GUARDA_INTS			  Near	 TXCODE:0334
HANDLE				  Dword	 TXDATA:0ABF
HAVE_CPU_NAME			  Near	 TXCODE:072F
HAVE_DPMI_MEM			  Near	 TXCODE32:1B53
HAVE_MEM_FOR_EXE		  Near	 TXCODE32:1CCE
HEAP_ERROR			  Near	 TXCODE:0AD9
IDT				  Dword	 TXCODE32:1EF7
IDT_BASE			  Dword	 TXDATA:0544
IDT_LIMIT			  Word	 TXDATA:0542
IDT_REAL			  Pword	 TXDATA:0548
IDT_REG				  Pword	 TXDATA:0542
ID_DONE				  Near	 TXCODE:0D2F
INITHEAP			  Near	 TXCODE32:120A
INIT_DATA			  Near	 TXCODE:0ADB
INIT_DOS_HEAP			  Near	 TXCODE32:148C
INIT_EXTENDED_HEAP		  Near	 TXCODE32:14D9
INIT_MEM			  Near	 TXCODE:0DA9
INIT_PM				  Near	 TXCODE:0696
INTERRUP_REDIR			  Dword	 TXCODE32:26F7
INT_NUM				  Byte	 TXCODE:04B1
INT_OR_CALL			  Word	 TXCODE:0452
INVALID_CODE_SELECTOR		  Near	 TXCODE32:0BE5
INVALID_SEL_MSG			  Byte	 TXDATA:06B7
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 115
Symbol Table



IRQ16				  Near	 TXCODE:04BE
IRQ_BASE			  Byte	 TXCODE:0A68
IRQ_REDIR			  Near	 TXCODE:0DDC
IT_HAS_STUB			  Near	 TXCODE32:15A1
IT_IS_DATA			  Near	 TXCODE32:193A
KB_MSG				  Byte	 TXDATA:013D
LAST_OBJECT_PAGE?		  Near	 TXCODE32:178E
LEERROR				  Near	 TXCODE32:1BC0
LENGTH_OK			  Near	 TXCODE32:0926
LE_HDR				  Struct TXDATA:0AC7 LEHEADER
LE_OFFSET			  Dword	 TXDATA:0AC3
LLE_CONTINUE_FREEING		  Near	 TXCODE32:19FF
LLE_END_FREEING			  Near	 TXCODE32:1A05
LLE_FREE_MEMORY			  Near	 TXCODE32:19D1
LLE_FREE_XMS_MEM		  Near	 TXCODE32:19ED
LOADLE				  Near	 TXCODE32:1554
LOAD_DLINK_FILE			  Near	 TXCODE32:1BEB
LOAD_ERROR			  Near	 TXCODE32:1E0C
LOAD_ERROR_MSG			  Byte	 TXDATA:0213
LOAD_OBJ_NUM			  Near	 TXCODE32:189A
LOAD_TARGET_OFF			  Near	 TXCODE32:18C9
LOOK_FOR_ENOUGH_SPACE		  Near	 TXCODE32:075E
MAKE_ASCII			  Near	 TXCODE32:1A20
MAKE_RM_INT			  Near	 TXCODE32:0144
MAKE_XMS_HEAP			  Near	 TXCODE32:1509
MALLOC				  Near	 TXCODE32:127E
MAP_MEMORY			  Near	 TXCODE32:06C3
MAP_THE_REGION			  Near	 TXCODE32:07A0
MAYBE_16BIT_SEL			  Near	 TXCODE32:190F
MEM_ALLOC_DONE			  Near	 TXCODE:0940
METHOD_2			  Near	 TXCODE:08E1
M_END				  Near	 TXCODE32:12D4
M_LP				  Near	 TXCODE32:1286
M_NEXT				  Near	 TXCODE32:12C9
NEED_A_STACK			  Near	 TXCODE:03CE
NEED_REAL_SEGS			  Near	 TXCODE32:09CE
NEW_CODE			  Dword	 TXCODE:0686
NEW_FLAGS			  Word	 TXCODE:068E
NEW_STACK			  Dword	 TXCODE:068A
NEXT_DESC			  Near	 TXCODE32:059E
NEXT_FIXUP_ENTRY		  Near	 TXCODE32:184E
NEXT_LABEL			  Near	 TXCODE:0033
NEXT_PAGE			  Near	 TXCODE32:176D
NO386_ERROR_MSG			  Byte	 TXDATA:01C2
NOFPU				  Byte	 TXDATA:00CD
NORMAL_ESP			  Near	 TXCODE32:0C9B
NORMAL_GDT			  Near	 TXCODE32:0BA2
NORMAL_INIT_MEM			  Near	 TXCODE32:1AC2
NORMAL_SEL			  Near	 TXCODE32:0DCC
NOT_ENOUGH_DESCS		  Near	 TXCODE32:0567
NOT_ENOUGH_EXT_MEM		  Near	 TXCODE32:16AC
NOT_ENOUGH_MEM			  Byte	 TXDATA:04AA
NOT_ENOUGH_MEMORY		  Near	 TXCODE32:19AB
NOT_LE				  Near	 TXCODE32:19A4
NO_386				  Near	 TXCODE:0D33
NO_487				  Near	 TXCODE:0D73
NO_DEFAULT_STACK		  Near	 TXCODE32:018B
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 116
Symbol Table



NO_DOS_HEAP_ERROR		  Near	 TXCODE32:0315
NO_DOS_HEAP_ERROR1		  Near	 TXCODE32:0350
NO_DOS_HEAP_ERROR2		  Near	 TXCODE32:03AD
NO_DPMI				  Near	 TXCODE:0775
NO_DPMI_INIT			  Near	 TXCODE:0966
NO_DPMI_MEM_INFO		  Near	 TXCODE32:1B3E
NO_DPMI_SEL_FIXUP		  Near	 TXCODE32:1D7D
NO_ERROR_CODE			  Near	 TXCODE32:0B7C
NO_EXT_HEAP_ERROR		  Near	 TXCODE32:03FF
NO_FIRST_ZERO			  Near	 TXCODE32:1A35
NO_FIXUP_NEEDED			  Near	 TXCODE32:1DEF
NO_FLAG_SAVE			  Near	 TXCODE:0427
NO_FPU_DET_NEEDED		  Near	 TXCODE:075E
NO_GEN_IDT			  Near	 TXCODE:0B40
NO_IRQ_FIXUP1			  Near	 TXCODE32:0657
NO_IRQ_FIXUP2			  Near	 TXCODE32:069E
NO_MAPPING_NEEDED		  Near	 TXCODE32:07C7
NO_MIRES_SI_XMS			  Near	 TXCODE32:1A9C
NO_MORE_HEAPS			  Near	 TXCODE32:14D8
NO_PAGEABLE			  Near	 TXCODE32:07C9
NO_PAGES			  Near	 TXCODE32:17B1
NO_PAGES_TO_FIXUP		  Near	 TXCODE32:196C
NO_RESTO			  Near	 TXCODE32:115F
NO_RESTO2			  Near	 TXCODE32:110E
NO_RESTO3			  Near	 TXCODE32:1117
NO_RESTO4			  Near	 TXCODE32:11B0
NO_RESTO5			  Near	 TXCODE32:11B9
NO_RETURN_VALS			  Near	 TXCODE32:027B
NO_SS_DE_PILA			  Near	 TXCODE32:0C59
NO_STACK_PARAMETERS		  Near	 TXCODE32:01BC
NO_TENEMOS_EL_GUSTO		  Near	 TXCODE32:0B71
NO_VCPI_END			  Near	 TXCODE:0A24
NO_VOLCADO_DESC			  Near	 TXCODE32:0E02
NO_XMS				  Near	 TXCODE:086B
NO_XMS_ALLOCATED		  Near	 TXCODE:0A62
NUMBER_STRING			  Byte	 TXCODE32:403A
NUM_DESCS			  Number 000C
NUM_OBJ_HANDLES			  Dword	 TXDATA:0CD9
OBJECT_NFO			  Struct TXDATA:0C7B OBJNFO
OBJECT_NUM			  Word	 TXDATA:0CF9
OBJECT_TBL			  Struct TXDATA:0B8B OBJECT
OBJ_COUNT			  Dword	 TXDATA:0CDD
OBJ_HANDLES_PTR			  Dword	 TXDATA:0CD5
OFF_1ST_FIXUP_REC		  Dword	 TXDATA:0CE9
OFF_1ST_FIXUP_REC_NEXT_PAGE	  Dword	 TXDATA:0CED
OF_ERROR_LOADING		  Near	 TXCODE32:1997
OPENFILE			  Near	 TXCODE32:152F
PAGE_DIR_BASE			  Dword	 TXDATA:0355
PAGE_DIR_ENTRIES		  Dword	 TXDATA:0359
PAGE_IS_LOCKED			  Near	 TXCODE:0843
PASS_TO_DECIMAL			  Near	 TXCODE32:1A14
PENTIUM_CPU			  Byte	 TXDATA:00BA
PILA_REAL			  Dword	 TXCODE:0692
PM_DS				  Word	 TXDATA:0376
PM_EAX				  Dword	 TXDATA:0504
PM_EBP				  Dword	 TXDATA:051C
PM_EBX				  Dword	 TXDATA:0508
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 117
Symbol Table



PM_ECX				  Dword	 TXDATA:050C
PM_EDI				  Dword	 TXDATA:0518
PM_EDX				  Dword	 TXDATA:0510
PM_EFLAGS			  Dword	 TXDATA:0524
PM_ERROR			  Near	 TXCODE32:1E13
PM_ES				  Word	 TXDATA:0378
PM_ESI				  Dword	 TXDATA:0514
PM_ESP				  Dword	 TXDATA:0520
PM_FS				  Word	 TXDATA:037A
PM_GS				  Word	 TXDATA:037C
PM_RET_POINT			  Near	 TXCODE32:09EA
PM_SS				  Word	 TXDATA:037E
PM_STACKSIZE			  Number 1000
PON_DPL				  Near	 TXCODE:0285
PON_REGISTROS			  Near	 TXCODE32:0B0D
PRESENT_ENTRY			  Near	 TXCODE32:076C
PRE_RM_CALL			  Near	 TXCODE:0403
PRINTF				  Near	 TXCODE:0D9F
PRINT_ANOTHER_PIECE		  Near	 TXCODE32:103F
PRINT_BUFFER			  Byte	 TXCODE32:3869
PRINT_DESC			  Near	 TXCODE32:0D93
PRINT_DOS_MEM			  Near	 TXCODE32:1AE5
PRINT_STRING			  Near	 TXCODE32:103B
PROGRAM_INFO_DONE		  Near	 TXCODE32:0939
PROGRAM_NAME_PTR		  Dword	 TXDATA:032D
PROGRAM_OFFSET			  Dword	 TXDATA:0321
PROG_SEL			  Word	 TXDATA:0333
PROT_CODE_ADDRESS		  Dword	 TXDATA:0532
PSP_DESC			  Word	 TXDATA:05A4
PSP_OFFSET			  Dword	 TXDATA:0325
PSP_SEG				  Word	 TXDATA:04D0
PSP_SEL				  Number 0040
PSP_SELECTOR			  Word	 TXDATA:0335
PUT_ERR_STRN			  Near	 TXCODE32:0D09
PUT_SPACES			  Near	 TXCODE32:1A36
PUT_THE_CHAR			  Near	 TXCODE32:1A23
RAW_MSG				  Byte	 TXDATA:0102
READ				  Near	 TXCODE32:1534
READ_32K_BLOCKS			  Near	 TXCODE32:10DA
READ_BLOCK			  Near	 TXCODE32:1124
READ_ERROR			  Near	 TXCODE32:111C
READ_FILE			  Near	 TXCODE32:10BD
READ_ONLY			  Number 0000
READ_WRITE			  Number 0002
REALLOC				  Near	 TXCODE32:133E
REALLOC_ERROR			  Near	 TXCODE32:04E6
REAL_DS				  Word	 TXDATA:04F6
REAL_EAX			  Dword	 TXDATA:04EE
REAL_EBP			  Dword	 TXDATA:04DA
REAL_EBX			  Dword	 TXDATA:04E2
REAL_ECX			  Dword	 TXDATA:04EA
REAL_EDI			  Dword	 TXDATA:04D2
REAL_EDX			  Dword	 TXDATA:04E6
REAL_ES				  Word	 TXDATA:04F4
REAL_ESI			  Dword	 TXDATA:04D6
REAL_FLAGS			  Word	 TXDATA:04F2
REAL_FS				  Word	 TXDATA:04F8
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 118
Symbol Table



REAL_GS				  Word	 TXDATA:04FA
REAL_INT			  Near	 TXCODE32:097A
REAL_IRQ			  Near	 TXCODE32:0A3D
RECUPERA_INTS			  Near	 TXCODE32:1E96
REG_OFFSETS			  Dword	 TXCODE32:0D60
REG_TO_HEX			  Near	 TXCODE32:0E03
REPARA_EXCS			  Near	 TXCODE:0B90
RESTORE_INTS			  Near	 TXCODE32:1E6F
RET_INFO			  Dword	 TXDATA:0528
RET_REAL			  Near	 TXCODE:09BE
RET_REAL_ADDRESS		  Word	 TXDATA:0538
RET_REAL_RAW			  Near	 TXCODE:0000
RET_REAL_VCPI			  Near	 TXCODE:0038
RM_ENTRY			  Number OFFSET	0007
RM_INT				  Near	 TXCODE:0454
RM_PROC_ADDRESS			  Dword	 TXCODE:04BA
RM_REGS_STRUC			  Word	 TXDATA:04D2
RM_STACKSIZE			  Number 1000
R_BIG				  Near	 TXCODE32:13DA
R_END				  Near	 TXCODE32:146B
R_EXIT				  Near	 TXCODE32:1540
R_KILL				  Near	 TXCODE32:1426
R_MALLOC			  Near	 TXCODE32:1442
R_NEWF				  Near	 TXCODE32:138F
R_NONEXT			  Near	 TXCODE32:143A
R_NOTENOUGHT			  Near	 TXCODE32:1468
R_S_END				  Near	 TXCODE32:13D1
S16				  Near	 TXCODE:09F5
SALIDA				  Near	 TXCODE32:1E24
SALIDA_DPMI			  Near	 TXCODE32:1E68
SALTITO				  Byte	 TXCODE:0018
SAVE_DPMI_DATA			  Near	 TXCODE:0205
SEARCH_ADDRESS			  Near	 TXCODE32:0856
SEARCH_A_FREE_CALLBACK		  Near	 TXCODE32:07E7
SEARCH_FREE_DESCS		  Near	 TXCODE32:0507
SEARCH_NOPRESENT_ENTRIES	  Near	 TXCODE32:0757
SEEK				  Near	 TXCODE32:1541
SEEK_CUR			  Number 0001
SEEK_END			  Number 0002
SEEK_SET			  Number 0000
SELECTORS			  Number 0007
SELECTOR_FIXUP			  Near	 TXCODE32:1DE5
SEL_OK				  Near	 TXCODE32:0DCA
SET_DESC			  Near	 TXCODE32:05A8
SET_DESC_ERROR			  Near	 TXCODE32:05EA
SET_DIR_ENTRIES			  Near	 TXCODE32:078F
SET_INT_VECTOR			  Near	 TXCODE32:067B
SET_PAGE_DIR_ENTRIES		  Near	 TXCODE:0115
SET_PAGE_TABLE_ENTRIES		  Near	 TXCODE:011C
SET_PM				  Near	 TXCODE:098E
SET_PM_ADDRESS			  Word	 TXDATA:0530
SET_PM_RAW			  Near	 TXCODE:001D
SET_PM_VCPI			  Near	 TXCODE:0090
SET_RM_INT_VEC			  Near	 TXCODE32:08AC
SOURCE_OFF			  Word	 TXDATA:0CF7
SOURCE_TYPE			  Byte	 TXDATA:0CF5
SS_DE_PILA			  Near	 TXCODE32:0C5C
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 119
Symbol Table



STACK_CONT1			  Byte	 TXDATA:07E0
STACK_CONT2			  Byte	 TXDATA:07E9
STACK_CONT3			  Byte	 TXDATA:07F2
STACK_FRAME			  Word	 TXCODE:04B4
STRING_COPIED			  Near	 TXCODE32:107A
SUMA_SELS			  Near	 TXCODE:0264
SYSTEM_TYPE			  Byte	 TXDATA:0341
SYS_DETERMINED			  Near	 TXCODE32:090E
SYS_TYPES			  Word	 TXDATA:00FA
SYS_TYPE_MSG			  Byte	 TXDATA:00E7
SYS_TYPE_VALS			  Byte	 TXCODE32:0910
TARGET_FLAGS			  Byte	 TXDATA:0CF6
TARGET_OFF			  Dword	 TXDATA:0CFB
TEST_A20			  Near	 TXCODE:0C5F
TRASH				  Word	 TXCODE:04B2
TSS_DESC			  Word	 TXDATA:05AC
TSS_SEL				  Number 0048
TX32_VERSION			  Number 0062
TXPR				  Dword	 TXPILA_REAL:0000
TX_INT21H			  Near	 TXCODE32:0F2C
TX_INT31H			  Near	 TXCODE32:001C
TX_PILA				  Dword	 TXPILA:0000
UNSUPORTED_FEATURE		  Near	 TXCODE32:19B2
UNSUPORTED_FEATURE_MSG		  Byte	 TXDATA:0257
V86_ERROR_MSG			  Byte	 TXDATA:0186
VCPI_CODE_SEL			  Number 0050
VCPI_CR3			  Dword	 TXDATA:054E
VCPI_CS_EIP			  Dword	 TXDATA:055E
VCPI_DESCS			  Byte	 TXDATA:05B4
VCPI_ENTRY_POINT		  Dword	 TXDATA:034B
VCPI_GDTR			  Dword	 TXDATA:0552
VCPI_IDTR			  Dword	 TXDATA:0556
VCPI_INIT			  Near	 TXCODE:00AE
VCPI_INIT_ERROR			  Near	 TXCODE:01D6
VCPI_INIT_ERR_MSG		  Byte	 TXDATA:035D
VCPI_LDTR			  Word	 TXDATA:055A
VCPI_MSG			  Byte	 TXDATA:0106
VCPI_NOT_PRESENT		  Near	 TXCODE:07B8
VCPI_SYS_REGS			  Word	 TXDATA:054E
VCPI_TR				  Word	 TXDATA:055C
VOLCADO_DESC			  Near	 TXCODE32:0DE7
VUELCA_CODE			  Near	 TXCODE32:0BD4
VUELCA_DESC			  Near	 TXCODE32:0DEC
VUELCA_PILA			  Near	 TXCODE32:0CE0
WAIT_FOR_A20			  Near	 TXCODE:0C80
WAIT_THAT_STATE			  Near	 TXCODE:0C52
WALK_OBJECT_TABLE		  Near	 TXCODE32:1722
WE_HAVE_IT			  Near	 TXCODE32:16E7
WE_HAVE_SEL_TYPE		  Near	 TXCODE32:1942
WRITE_32K_BLOCKS		  Near	 TXCODE32:117B
WRITE_BLOCK			  Near	 TXCODE32:11C6
WRITE_ERROR			  Near	 TXCODE32:11BE
WRITE_FILE			  Near	 TXCODE32:1160
WRITE_ONLY			  Number 0001
XMS_ALLOC_DONE			  Near	 TXCODE:0868
XMS_ENTRY_POINT			  Dword	 TXDATA:0347
XMS_HANDLES			  Byte	 TXCODE32:3549
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 120
Symbol Table



XMS_MEMORY			  Number 0002
XMS_MEM_FREED			  Near	 TXCODE:0A62
XMS_MSG				  Byte	 TXDATA:0110
ZERO_DESCRIPTOR			  Byte	 TXDATA:0564
ZERO_SEL			  Word	 TXDATA:0331

Macro Name

ALLOC_XMS_MEM
COALESCE
FREE_XMS_MEM
LOOK_FOR_EXTENDED_BEGINNING
PUSHD
SAVE_VCPI_DATA

Structure Name			  Type	Offset

LEHEADER
 SIGNATURE			  Word	 0000
 BYTE_ORDER			  Byte	 0002
 WORD_ORDER			  Byte	 0003
 EXE_LEVEL			  Dword	 0004
 CPU_TYPE			  Word	 0008
 TARGET_OS			  Word	 000A
 MODULE_VERSION			  Dword	 000C
 MODULE_TYPE			  Dword	 0010
 MEMORY_PAGES			  Dword	 0014
 OBJECT_CS			  Dword	 0018
 OFFSET_EIP			  Dword	 001C
 OBJECT_SS			  Dword	 0020
 OFFSET_ESP			  Dword	 0024
 PAGE_SIZE			  Dword	 0028
 BYTES_LAST_PAGE		  Dword	 002C
 FIXUP_SECT_SIZE		  Dword	 0030
 FIXUP_CHECKSUM			  Dword	 0034
 LOAD_SECT_SIZE			  Dword	 0038
 LOAD_CHECKSUM			  Dword	 003C
 OFF_OBJECT_TBL			  Dword	 0040
 OBJ_TBL_ENTRIES		  Dword	 0044
 OFF_PAGE_MAP			  Dword	 0048
 OFF_OBJ_IT_DATA		  Dword	 004C
 OFF_RES_TABLE			  Dword	 0050
 RES_TBL_ENTRIES		  Dword	 0054
 OFF_RES_NAMES			  Dword	 0058
 OFF_ENTRY_TABLE		  Dword	 005C
 OFF_MOD_DIRS			  Dword	 0060
 NUM_MOD_DIRS			  Dword	 0064
 OFF_FIXUP_PAG			  Dword	 0068
 OFF_FIXUP_REC			  Dword	 006C
 OFF_IMPORT_MODS		  Dword	 0070
 NUM_IMPORT_MODS		  Dword	 0074
 OFF_IMPORT_PROC		  Dword	 0078
 OFF_PAGES_CHKSM		  Dword	 007C
 OFF_DATA_PAGES			  Dword	 0080
 NUM_PRELOAD			  Dword	 0084
 OFF_NRES_NAMES			  Dword	 0088
 LEN_NRES_NAMES			  Dword	 008C
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 121
Symbol Table



 NRES_NAMES_CHK			  Dword	 0090
 AUTO_DATA_OBJ			  Dword	 0094
 OFF_DBG_NFO			  Dword	 0098
 LEN_DBG_NFO			  Dword	 009C
 PRELOAD_INST_PG		  Dword	 00A0
 DEMAND_INST_PG			  Dword	 00A4
 EXTRA_HEAP			  Dword	 00A8
 LEH_RESERVED			  Dword	 00AC
OBJECT
 VIRTUAL_SIZE			  Dword	 0000
 RELOCATION_BASE		  Dword	 0004
 OBJECT_FLAGS			  Dword	 0008
 PAGE_MAP_INDEX			  Dword	 000C
 NUM_PAGES			  Dword	 0010
 OT_RESERVED			  Dword	 0014
OBJNFO
 OBJ_HANDLES			  Dword	 0000
 MEM_TYPE			  Byte	 0004
 OBJ_OFFSET			  Dword	 0005
TBLOCK
 BLEN				  Dword	 0000
 STATUS				  Byte	 0004
 MORE				  Byte	 0005
 SIGN				  Word	 0006
 PREV				  Dword	 0008
 NEXT				  Dword	 000C
TCALLBACK
 CALLBACK_STATE			  Byte	 0000
 RM_ENTRY_POINT			  Word	 0001
 PM_PROC_TO_CALL		  Struct 0003 TFWORD
 RM_CALL_STRUC			  Struct 0009 TFWORD
TFWORD
 LOFFSET			  Dword	 0000
 SELECTOR			  Word	 0004
THEAP
 START				  Dword	 0000
 HLEN				  Dword	 0004
TRM_REG
 RM_EDI				  Dword	 0000
 RM_ESI				  Dword	 0004
 RM_EBP				  Dword	 0008
 RM_EBX				  Dword	 0010
 RM_EDX				  Dword	 0014
 RM_ECX				  Dword	 0018
 RM_EAX				  Dword	 001C
 RM_FLAGS			  Word	 0020
 RM_ES				  Word	 0022
 RM_DS				  Word	 0024
 RM_FS				  Word	 0026
 RM_GS				  Word	 0028
 RM_IP				  Word	 002A
 RM_CS				  Word	 002C
 RM_SP				  Word	 002E
 RM_SS				  Word	 0030
Turbo Assembler	 Version 3.1	    03/06/99 07:39:50	    Page 122
Symbol Table




Groups & Segments		  Bit Size Align  Combine Class

DISK				  32  8000 Para	  none
TXCODE				  16  0E01 Para	  none	  CODE
TXCODE32			  32  4045 Para	  none	  CODE32
TXDATA				  16  0EDF Para	  none	  DATA
TXPILA				  16  4000 Para	  Stack	  STACK
TXPILA_REAL			  16  4000 Para	  none	  STACK
