Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 1
DarkX.ASM



      1					 .386p
      2					 NOWARN	PRO
      3					 JUMPS
      4
      5					 ; number of needed call-back slots
      6		  =0020			 NUM_RM_CALLBACKS	 EQU 32
      7
      8					 ; stack sizes in DWORDs
      9		  =1000			 PM_STACKSIZE	 EQU 1000h	 ; 4Kb
     10		  =1000			 RM_STACKSIZE	 EQU 1000h	 ; 4Kb
     11
     12					 ; TASM	3.1 no ensambla	bien los PUSH's	de offsets de 32 bits
     13					 pushd MACRO address_32
     14						 db 68h
     15						 dw offset address_32,0
     16					 ENDM
     17
     18					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     19					 ; SEGMENTO DE DATOS DE	PROGRAMA
     20					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     21
     22	    0000			 TXDATA	 SEGMENT USE16 'DATA'
     23
     24	    0000  44 61	72 6B 58 20 2D+		 copyright_msg		 db "DarkX - the DarkRising DOS	Extender [ v0.98.1 ] (c)    +
     25		  20 74	68 65 20 44 61+	 1998",13,10
     26		  72 6B	52 69 73 69 6E+
     27		  67 20	44 4F 53 20 45+
     28		  78 74	65 6E 64 65 72+
     29		  20 5B	20 76 30 2E 39+
     30		  38 2E	31 20 5D 20 28+
     31		  63 29	20 31 39 39 38+
     32		  0D 0A
     33	    003A  45 78	74 65 6E 64 65+					 db "Extender by B52 , Memory Manager and LE loader by	    +
     34		  72 20	62 79 20 42 35+	 Teknik",13,10
     35		  32 20	2C 20 4D 65 6D+
     36		  6F 72	79 20 4D 61 6E+
     37		  61 67	65 72 20 61 6E+
     38		  64 20	4C 45 20 6C 6F+
     39		  61 64	65 72 20 62 79+
     40		  20 54	65 6B 6E 69 6B+
     41		  0D 0A
     42	    0074  3C 20	68 74 74 70 3A+					 db "< http://thedarkrising.home.ml.org	>",13,10,"$"
     43		  2F 2F	74 68 65 64 61+
     44		  72 6B	72 69 73 69 6E+
     45		  67 2E	68 6F 6D 65 2E+
     46		  6D 6C	2E 6F 72 67 20+
     47		  3E 0D	0A 24
     48
     49	    009B  20 FE	20 43 50 55 20+		 cpu_type_msg		 db " ş	CPU Family:  $"
     50		  46 61	6D 69 6C 79 3A+
     51		  20 20	24
     52	    00AC  00B2r	00B6r 00BAr		 cpu_strings		 dw offset cpu386,offset cpu486,offset pentium_cpu
     53	    00B2  33 38	36 24			 cpu386			 db "386$"
     54	    00B6  34 38	36 24			 cpu486			 db "486$"
     55	    00BA  50 65	6E 74 69 75 6D+		 pentium_cpu		 db "Pentium+$"
     56		  2B 24
     57	    00C3  00CDr	0000 00D5r    +		 fpu_strings		 dw offset nofpu,0,offset fpu287,offset	fpu387,offset fpu487
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 2
DarkX.ASM



     58		  00DBr	00E1r
     59	    00CD  20 6E	6F 20 46 50 55+		 nofpu			 db " no FPU$"
     60		  24
     61	    00D5  20 2B	32 38 37 24		 fpu287			 db " +287$"
     62	    00DB  20 2B	33 38 37 24		 fpu387			 db " +387$"
     63	    00E1  20 2B	34 38 37 24		 fpu487			 db " +487$"
     64	    00E7  0D 0A	20 FE 20 53 79+		 sys_type_msg		 db 13,10," ş System Type: $"
     65		  73 74	65 6D 20 54 79+
     66		  70 65	3A 20 24
     67	    00FA  0102r	0106r 010Br   +		 sys_types		 dw offset raw_msg,offset vcpi_msg,offset dpmi_msg,offset   +
     68		  0110r			 xms_msg
     69	    0102  52 41	57 24			 raw_msg		 db "RAW$"
     70	    0106  56 43	50 49 24		 vcpi_msg		 db "VCPI$"
     71	    010B  44 50	4D 49 24		 dpmi_msg		 db "DPMI$"
     72	    0110  58 4D	53 24			 xms_msg		 db "XMS$"
     73	    0114  0D 0A	20 FE 20 44 4F+		 dos_mem_msg		 db 13,10," ş DOS memory:  $"
     74		  53 20	6D 65 6D 6F 72+
     75		  79 3A	20 20 24
     76	    0127  20 4B	62 0D 0A 20 FE+		 extended_mem_msg	 db " Kb",13,10," ş DPMI memory: $"
     77		  20 44	50 4D 49 20 6D+
     78		  65 6D	6F 72 79 3A 20+
     79		  24
     80	    013D  20 4B	62 0D 0A 0A 24		 kb_msg			 db " Kb",13,10,10,"$"
     81
     82	    0144  45 72	72 6F 72 3A 20+		 dos_version_error_msg	 db "Error: DOS	v3.0 or	better needed$"
     83		  44 4F	53 20 76 33 2E+
     84		  30 20	6F 72 20 62 65+
     85		  74 74	65 72 20 6E 65+
     86		  65 64	65 64 24
     87	    0165  45 72	72 6F 72 3A 20+		 A20_error_msg		 db "Error: Could not enable A20 line$"
     88		  43 6F	75 6C 64 20 6E+
     89		  6F 74	20 65 6E 61 62+
     90		  6C 65	20 41 32 30 20+
     91		  6C 69	6E 65 24
     92	    0186  45 72	72 6F 72 3A 20+		 v86_error_msg		 db "Error: System is in V86 mode and no VCPI/DPMI manager  +
     93		  53 79	73 74 65 6D 20+	 found$"
     94		  69 73	20 69 6E 20 56+
     95		  38 36	20 6D 6F 64 65+
     96		  20 61	6E 64 20 6E 6F+
     97		  20 56	43 50 49 2F 44+
     98		  50 4D	49 20 6D 61 6E+
     99		  61 67	65 72 20 66 6F+
    100		  75 6E	64 24
    101	    01C2  45 72	72 6F 72 3A 20+		 no386_error_msg	 db "Error: No 386 or better processor found$"
    102		  4E 6F	20 33 38 36 20+
    103		  6F 72	20 62 65 74 74+
    104		  65 72	20 70 72 6F 63+
    105		  65 73	73 6F 72 20 66+
    106		  6F 75	6E 64 24
    107
    108						 ; loader error	messages
    109	    01EA  45 72	72 6F 72 3A 20+		 exe_size_error_msg	 db "Error: Not	enough memory to load program$"
    110		  4E 6F	74 20 65 6E 6F+
    111		  75 67	68 20 6D 65 6D+
    112		  6F 72	79 20 74 6F 20+
    113		  6C 6F	61 64 20 70 72+
    114		  6F 67	72 61 6D 24
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 3
DarkX.ASM



    115	    0213  45 72	72 6F 72 3A 20+		 load_error_msg		 db "Error: Unable to load EXE file from disk (error in	disk+
    116		  55 6E	61 62 6C 65 20+	 operations)$"
    117		  74 6F	20 6C 6F 61 64+
    118		  20 45	58 45 20 66 69+
    119		  6C 65	20 66 72 6F 6D+
    120		  20 64	69 73 6B 20 28+
    121		  65 72	72 6F 72 20 69+
    122		  6E 20	64 69 73 6B 20+
    123		  6F 70	65 72 61 74 69+
    124		  6F 6E	73 29 24
    125	    0257  45 72	72 6F 72 3A 20+		 unsuported_feature_msg	 db "Error: Linear executable contains a feature not	    +
    126		  4C 69	6E 65 61 72 20+	 suported by the loader$"
    127		  65 78	65 63 75 74 61+
    128		  62 6C	65 20 63 6F 6E+
    129		  74 61	69 6E 73 20 61+
    130		  20 66	65 61 74 75 72+
    131		  65 20	6E 6F 74 20 73+
    132		  75 70	6F 72 74 65 64+
    133		  20 62	79 20 74 68 65+
    134		  20 6C	6F 61 64 65 72+
    135		  24
    136	    029E  45 72	72 6F 72 3A 20+		 desc_alloc_error_msg	 db "Error: Could not allocate descriptors$"
    137		  43 6F	75 6C 64 20 6E+
    138		  6F 74	20 61 6C 6C 6F+
    139		  63 61	74 65 20 64 65+
    140		  73 63	72 69 70 74 6F+
    141		  72 73	24
    142	    02C4  45 72	72 6F 72 3A 20+		 bad_exec_error_msg	 db "Error: Program is NOT a Linear or DOS32 Executable$"
    143		  50 72	6F 67 72 61 6D+
    144		  20 69	73 20 4E 4F 54+
    145		  20 61	20 4C 69 6E 65+
    146		  61 72	20 6F 72 20 44+
    147		  4F 53	33 32 20 45 78+
    148		  65 63	75 74 61 62 6C+
    149		  65 24
    150	    02F7  45 72	72 6F 72 3A 20+		 comp_exe_error_msg	 db "Error: DLINK executable is	compressed$"
    151		  44 4C	49 4E 4B 20 65+
    152		  78 65	63 75 74 61 62+
    153		  6C 65	20 69 73 20 63+
    154		  6F 6D	70 72 65 73 73+
    155		  65 64	24
    156
    157	    031D  ????????			 dos_mem_size		 dd ?
    158
    159						 ; EXE info (OEM function 3201h)
    160	    0321				 exe_info_struc		 LABEL
    161						 ;**********************************
    162	    0321  00000000			 program_offset		 dd 0	 ; 0 if	Linear Executable
    163	    0325  ????????			 psp_offset		 dd ?
    164	    0329  ????????			 env_offset		 dd ?
    165	    032D  ????????			 program_name_ptr	 dd ?
    166	    0331  0010				 zero_sel		 dw 2 SHL 3	 ; =D32_SEL without DPMI
    167	    0333  0030				 prog_sel		 dw 6 SHL 3	 ; =DATA_SEL without DPMI
    168	    0335  0040				 psp_selector		 dw PSP_SEL	 ; sin DPMI ser  ‚ste
    169	    0337  0038				 env_selector		 dw ENV_SEL	 ; para	vars. de entorno
    170	    0339  ????				 disk_seg		 dw ?
    171						 ;**********************************
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 4
DarkX.ASM



    172	    033B  00000000			 exe_size		 dd 0	 ; 0 with LE's (not implemented)
    173
    174						 ; system info
    175	    033F  ????				 cpu_info		 dw ?
    176	    0341  00				 system_type		 db 0	 ; 0=RAW
    177	    0342  04				 fpu_info		 db 4	 ; 487 if fpuid	is not executed	(Pentium)
    178
    179	    0343  ????????			 extended_heap_size	 dd ?
    180
    181	    0347  00000000			 xms_entry_point	 dd 0	 ; si es 0, es que no hay XMS
    182
    183	    034B  ????????			 vcpi_entry_point	 dd ?
    184	    034F  0050							 dw VCPI_CODE_SEL
    185
    186	    0351  00000000			 dir_base		 dd 0
    187	    0355  00000000			 page_dir_base		 dd 0
    188	    0359  00000000			 page_dir_entries	 dd 0
    189
    190	    035D  45 72	72 6F 72 20 69+		 vcpi_init_err_msg	 db "Error initializing	VCPI!$"
    191		  6E 69	74 69 61 6C 69+
    192		  7A 69	6E 67 20 56 43+
    193		  50 49	21 24
    194
    195	    0376  ????				 pm_ds			 dw ?
    196	    0378  ????				 pm_es			 dw ?
    197	    037A  ????				 pm_fs			 dw ?
    198	    037C  ????				 pm_gs			 dw ?
    199	    037E  ????				 pm_ss			 dw ?
    200
    201	    0380  44 50	4D 49 20 64 6F+		 dpmi_32b_error		 db "DPMI does not support 32bit programs!$"
    202		  65 73	20 6E 6F 74 20+
    203		  73 75	70 70 6F 72 74+
    204		  20 33	32 62 69 74 20+
    205		  70 72	6F 67 72 61 6D+
    206		  73 21	24
    207	    03A6  45 72	72 6F 72 20 69+		 dpmi_init_error	 db "Error initializing	DPMI!$"
    208		  6E 69	74 69 61 6C 69+
    209		  7A 69	6E 67 20 44 50+
    210		  4D 49	21 24
    211
    212	    03BF				 dpmi_rm_call_struc	 LABEL
    213	    03BF  08*(????????)						 dd 8 dup(?)
    214	    03DF  09*(????)						 dw 9 dup(?)
    215
    216	    03F1  ????				 dpmi_private_buffer	 dw ?
    217
    218	    03F3  ????????			 dpmi_save_restore_real	 dd ?
    219	    03F7  ???? ???? ????		 dpmi_save_restore_pm	 dw ?,?,?
    220
    221	    03FD  ????????			 dpmi_real_to_pm	 dd ?
    222	    0401  ???? ???? ????		 dpmi_pm_to_real	 dw ?,?,?
    223
    224	    0407  20*(00)			 dpmi_rm_call		 db 32 dup(0)
    225
    226	    0427  07*(00000000)			 dpmi_sels		 dd SELECTORS dup(0)
    227
    228	    0443  5A*(00)			 dpmi_exc_handlers	 db 6*15 dup(0)
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 5
DarkX.ASM



    229	    049D  0000 0000 0000		 dpmi_old_int21h	 dw 0,0,0
    230	    04A3  0000 0000 0000		 dpmi_old_int31h	 dw 0,0,0
    231
    232	    04A9  00				 dpmi_exception_flag	 db 0
    233
    234	    04AA  45 72	72 6F 72 3A 20+		 not_enough_mem		 db "Error: Not	enough conventional memory$"
    235		  4E 6F	74 20 65 6E 6F+
    236		  75 67	68 20 63 6F 6E+
    237		  76 65	6E 74 69 6F 6E+
    238		  61 6C	20 6D 65 6D 6F+
    239		  72 79	24
    240
    241	    04D0  ????				 psp_seg		 dw ?
    242
    243						 ; registros en	modo real antes	del salto a protegido
    244	    04D2				 rm_regs_struc		 LABEL
    245	    04D2  00000000			 real_edi		 dd 0
    246	    04D6  00000000			 real_esi		 dd 0
    247	    04DA  00000000			 real_ebp		 dd 0
    248	    04DE  00000000						 dd 0	 ; reserverd
    249	    04E2  00000000			 real_ebx		 dd 0
    250	    04E6  00000000			 real_edx		 dd 0
    251	    04EA  00000000			 real_ecx		 dd 0
    252	    04EE  00000000			 real_eax		 dd 0
    253	    04F2  0000				 real_flags		 dw 0
    254	    04F4  0000				 real_es		 dw 0
    255	    04F6  0000				 real_ds		 dw 0
    256	    04F8  0000				 real_fs		 dw 0
    257	    04FA  0000				 real_gs		 dw 0
    258	    04FC  0000 0000						 dw 0,0	 ; CS:IP
    259	    0500  0000 0000						 dw 0,0	 ; SS:SP
    260
    261						 ; registros en	modo protegido antes del salto a real
    262	    0504  00000000			 pm_eax			 dd 0
    263	    0508  00000000			 pm_ebx			 dd 0
    264	    050C  00000000			 pm_ecx			 dd 0
    265	    0510  00000000			 pm_edx			 dd 0
    266	    0514  00000000			 pm_esi			 dd 0
    267	    0518  00000000			 pm_edi			 dd 0
    268	    051C  00000000			 pm_ebp			 dd 0
    269	    0520  00000000			 pm_esp			 dd 0
    270	    0524  00000000			 pm_eflags		 dd 0
    271
    272	    0528  ???????? ????????		 ret_info		 dd ?,?		 ; EIP,CS
    273
    274	    0530  001Dr				 set_pm_address		 dw offset set_pm_raw
    275
    276	    0532  ????????			 prot_code_address	 dd ?
    277	    0536  ????							 dw ?		 ; selector de c¢digo de 32 bits
    278
    279	    0538  0000r	0000			 ret_real_address	 dw offset ret_real_raw,0
    280
    281	    053C				 gdt_reg		 label fword
    282	    053C  00AF				 gdt_limit		 dw (NUM_DESCS + FREE_DESCS) * 8 - 1
    283	    053E  ????????			 gdt_base		 dd ?
    284
    285	    0542				 idt_reg		 label fword
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 6
DarkX.ASM



    286	    0542  07FF				 idt_limit		 dw 256	* 8 -1	 ; 256 descriptores (1 por gate)
    287	    0544  ????????			 idt_base		 dd ?
    288
    289	    0548				 idt_real		 label fword
    290	    0548  FFFF							 dw 0FFFFh
    291	    054A  00000000						 dd 0
    292
    293						 ; "system registers" para pasarle al VCPI
    294	    054E				 vcpi_sys_regs		 LABEL
    295	    054E  00000000			 vcpi_cr3		 dd 0			 ; valor del cr3
    296	    0552  0000053Cr			 vcpi_gdtr		 dd offset gdt_reg	 ; linear address de la	GDT (1er Mb)
    297	    0556  00000542r			 vcpi_idtr		 dd offset idt_reg	 ;   "	     "	  de la	IDT (1er Mb)
    298	    055A  0000				 vcpi_ldtr		 dw 0			 ; valor del LDTR
    299	    055C  0048				 vcpi_tr		 dw TSS_SEL		 ;   "	  "  TR
    300	    055E  00000000			 vcpi_cs_eip		 dd 0			 ; entry point (CS:EIP)	para el
    301	    0562  ????							 dw ?			 ; modo	protegido
    302
    303						 INCLUDE gdt.inc
1   304		  =000C			 NUM_DESCS	 EQU 12		 ; 12 descriptores de DarkX (3 de VCPI)
1   305		  =000A			 FREE_DESCS	 EQU 10		 ; allocatable descriptors for application
1   306
1   307		  =0040			 PSP_SEL	 EQU 8 SHL 3
1   308		  =0038			 ENV_SEL	 EQU 7 SHL 3
1   309		  =0048			 TSS_SEL	 EQU 9 SHL 3
1   310		  =0050			 VCPI_CODE_SEL	 EQU 10	SHL 3
1   311
1   312					 ; NOTA	: ponemos los bits de acceso a 1 para que el procesador	no tenga que
1   313					 ;	  ponerlos a 1 cuando se accedan y tener c¢digo	m s efectivo
1   314					 ;	  ( v lido para	486 y Pentium )
1   315
1   316	    0564			 gdt		 label
1   317
1   318	    0564  08*(00)		 zero_descriptor	 db	 8 dup(0)
1   319
1   320	    056C  FFFF			 code_descriptor	 dw	 0FFFFh		 ; 4 Gb
1   321	    056E  ????						 dw	 ?		 ; b15-0 de base de segmento
1   322	    0570  ??						 db	 ?		 ; b23-16 de base de segmento
1   323	    0571  9B						 db	 10011011b	 ; b7 present bit = 1
1   324											 ; b6-5	priv. level = 0
1   325											 ; b4 sistema =	1 (code/data)
1   326											 ; b3 ejecutable = 1 (s¡)
1   327											 ; b2 conforming (???) = 0
1   328											 ; b1 bit de lectura = 1 (s¡)
1   329											 ; b0 bit de acceso = 1
1   330	    0572  CF						 db	 11001111b	 ; b7 granularidad = 1 (p gs.)
1   331											 ; b6 op. size = 1 (32 bits)
1   332											 ; b5 ???
1   333											 ; b4 not used
1   334											 ; b3-0	= b19-16 de l¡mite
1   335	    0573  00						 db	 0		 ; b31-24 de la	base
1   336
1   337	    0574  FFFF			 data_descriptor	 dw 0FFFFh		 ; 4 Gb
1   338	    0576  0000						 dw	 0		 ; b15-0 de base de segmento
1   339	    0578  00						 db	 0		 ; b23-16 de base de segmento
1   340	    0579  93						 db	 10010011b	 ; b7 present bit = 1
1   341											 ; b6-5	priv. level = 0
1   342											 ; b4 sistema =	1 (code/data)
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 7
DarkX.ASM



1   343											 ; b3 ejecutable = 0 (no)
1   344											 ; b2 expandible hacia arriba
1   345											 ; b1 W	= 1 (read/write)
1   346											 ; b0 bit de acceso = 1
1   347	    057A  CF						 db	 11001111b	 ; b7 granularidad = 1 (p gs.)
1   348											 ; b6 op. size = 1 (32 bits)
1   349											 ; b5 ???
1   350											 ; b4 not used
1   351											 ; b3-0	= b19-16 de l¡mite
1   352	    057B  00						 db	 0		 ; b31-24 de la	base
1   353
1   354	    057C  FFFF			 c16_desc		 dw	 0FFFFh
1   355	    057E  ????						 dw	 ?
1   356	    0580  ??						 db	 ?
1   357	    0581  9B						 db	 9Ah OR	1
1   358	    0582  00						 db	 0	 ; segmento de 16 bits de 64Kb
1   359	    0583  00						 db	 0
1   360
1   361	    0584  FFFF			 d16_desc		 dw	 0FFFFh
1   362	    0586  ????						 dw	 ?
1   363	    0588  ??						 db	 ?
1   364	    0589  93						 db	 92h OR	1
1   365	    058A  00 00						 db	 0,0
1   366
1   367					 ; descriptores	para el	c¢digo y los datos del programa
1   368	    058C  FFFF			 code_desc		 dw	 0FFFFh
1   369	    058E  0000						 dw	 0
1   370	    0590  00						 db	 0
1   371	    0591  9B CF						 db	 9Bh,0CFh
1   372	    0593  00						 db	 0
1   373
1   374	    0594  FFFF			 data_desc		 dw	 0FFFFh
1   375	    0596  0000						 dw	 0
1   376	    0598  00						 db	 0
1   377	    0599  93 CF						 db	 93h,0CFh
1   378	    059B  00						 db	 0
1   379
1   380					 ; descriptor para el segmento de variables de entorno
1   381	    059C  FFFF			 env_desc		 dw	 0FFFFh	 ; l¡mite 64Kb
1   382	    059E  0000						 dw	 0
1   383	    05A0  00						 db	 0
1   384	    05A1  93						 db	 92h OR	1
1   385	    05A2  00 00						 db	 0,0
1   386
1   387					 ; a partir de aqu¡ no se pueden mover de sitio	los descriptores
1   388
1   389					 ; descriptor para el segmento del PSP
1   390	    05A4  00FF			 psp_desc		 dw	 0FFh	 ; l¡mite 100h bytes
1   391	    05A6  0000						 dw	 0
1   392	    05A8  00						 db	 0
1   393	    05A9  93						 db	 93h
1   394	    05AA  40 00						 db	 40h,0
1   395
1   396					 ; descriptor del Task State Segment (TSS)
1   397	    05AC  FFFF			 tss_desc		 dw	 0FFFFh
1   398	    05AE  0000						 dw	 0
1   399	    05B0  00						 db	 0
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 8
DarkX.ASM



1   400	    05B1  89						 db	 89h	 ; Present, not	Busy
1   401	    05B2  00						 db	 0
1   402	    05B3  00						 db	 0
1   403
1   404					 ; reservamos 3	descriptores para el VCPI, en caso de que lo haya
1   405	    05B4  18*(00)		 vcpi_descs		 db	 3*8 dup(0)
1   406
1   407					 ; espacio para	descriptores libres
1   408	    05CC  50*(00)		 free_descs_start	 db	 FREE_DESCS*8 dup(0)
1   409
    410	    061C  0A*(00)			 free_descs_handles	 db FREE_DESCS dup(0)
    411
    412	    0626  0646r				 error_string_table	 dw exc_0
    413	    0628  0656r							 dw exc_1
    414									 REPT	 4
    415									 dw exc_default
    416									 ENDM
1   417	    062A  06ADr							 dw exc_default
1   418	    062C  06ADr							 dw exc_default
1   419	    062E  06ADr							 dw exc_default
1   420	    0630  06ADr							 dw exc_default
    421	    0632  0666r							 dw exc_6
    422	    0634  0675r							 dw exc_7
    423									 REPT	 5
    424									 dw exc_default
    425									 ENDM
1   426	    0636  06ADr							 dw exc_default
1   427	    0638  06ADr							 dw exc_default
1   428	    063A  06ADr							 dw exc_default
1   429	    063C  06ADr							 dw exc_default
1   430	    063E  06ADr							 dw exc_default
    431	    0640  0687r							 dw exc_13
    432	    0642  06A2r							 dw exc_14
    433	    0644  06ADr							 dw exc_default
    434
    435	    0646  44 49	56 49 44 45 20+		 exc_0			 db "DIVIDE OVERFLOW",0
    436		  4F 56	45 52 46 4C 4F+
    437		  57 00
    438	    0656  44 45	42 55 47 20 45+		 exc_1			 db "DEBUG EXCEPTION",0
    439		  58 43	45 50 54 49 4F+
    440		  4E 00
    441	    0666  49 4E	56 41 4C 49 44+		 exc_6			 db "INVALID OPCODE",0
    442		  20 4F	50 43 4F 44 45+
    443		  00
    444	    0675  46 50	55 20 4E 4F 54+		 exc_7			 db "FPU NOT AVAILABLE",0
    445		  20 41	56 41 49 4C 41+
    446		  42 4C	45 00
    447	    0687  47 45	4E 45 52 41 4C+		 exc_13			 db "GENERAL PROTECTION	FAILURE",0
    448		  20 50	52 4F 54 45 43+
    449		  54 49	4F 4E 20 46 41+
    450		  49 4C	55 52 45 00
    451	    06A2  50 41	47 45 20 46 41+		 exc_14			 db "PAGE FAULT",0
    452		  55 4C	54 00
    453	    06AD  45 58	43 45 50 54 49+		 exc_default		 db "EXCEPTION",0
    454		  4F 4E	00
    455
    456	    06B7  49 4E	56 41 4C 49 44+		 invalid_sel_msg	 db "INVALID SELECTOR VALUE "
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 9
DarkX.ASM



    457		  20 53	45 4C 45 43 54+
    458		  4F 52	20 56 41 4C 55+
    459		  45 20
    460
    461	    06CE  45 52	52 4F 52 3A 20		 debug_info_msg		 db "ERROR: "
    462	    06D5  20 20	20 20 20 20 20+		 error_string		 db "			       ",13,10
    463		  20 20	20 20 20 20 20+
    464		  20 20	20 20 20 20 20+
    465		  20 20	20 20 20 0D 0A
    466	    06F1  33 32	2D 62 69 74 20+					 db "32-bit protected mode exception number: "
    467		  70 72	6F 74 65 63 74+
    468		  65 64	20 6D 6F 64 65+
    469		  20 65	78 63 65 70 74+
    470		  69 6F	6E 20 6E 75 6D+
    471		  62 65	72 3A 20
    472	    0719  30 30	68 0D 0A		 exception_number	 db "00h",13,10
    473	    071E  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    474		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    475		  C4 C4	C4 C4 C4 C4 C4+
    476		  C4 C4	C4 C4 C4 C4 C4+
    477		  C4 C4	C4 C4 C4 C4 C4+
    478		  C4 C4	C4 C4 C4 C4 C4+
    479		  C4 C4	C4 C4 C4 C4 C4+
    480		  C4 C4	C4 C4 C4 C4 C4+
    481		  C4 C4	C4 C4 C4 C4 C4+
    482		  C4 C4	C4 C4 C4 C4 C4+
    483		  C4 C4	C4 C4 C4 C4 C4+
    484		  C4 C4	C4
    485	    076E  43 72	61 73 68 20 61+					 db "Crash address  CS:EIP = "
    486		  64 64	72 65 73 73 20+
    487		  20 43	53 3A 45 49 50+
    488		  20 3D	20
    489	    0786  30 30	30 30 3A		 debug_cs		 db "0000:"
    490	    078B  30 30	30 30 30 30 30+		 debug_eip		 db "00000000h	->  "
    491		  30 68	20 20 2D 3E 20+
    492		  20
    493	    079A  30 30	20 30 30 20 30+		 crash_code		 db "00	00 00 00 00 00 00 00",13,10,10
    494		  30 20	30 30 20 30 30+
    495		  20 30	30 20 30 30 20+
    496		  30 30	0D 0A 0A
    497	    07B4  53 74	61 63 6B 20 63+					 db "Stack contents SS:ESP = "
    498		  6F 6E	74 65 6E 74 73+
    499		  20 53	53 3A 45 53 50+
    500		  20 3D	20
    501	    07CC  30 30	30 30 3A		 debug_ss0		 db "0000:"
    502	    07D1  30 30	30 30 30 30 30+		 debug_esp0		 db "00000000h	->  "
    503		  30 68	20 20 2D 3E 20+
    504		  20
    505	    07E0  30 30	30 30 30 30 30+		 stack_cont1		 db "00000000 "
    506		  30 20
    507	    07E9  30 30	30 30 30 30 30+		 stack_cont2		 db "00000000 "
    508		  30 20
    509	    07F2  30 30	30 30 30 30 30+		 stack_cont3		 db "00000000",13,10
    510		  30 0D	0A
    511	    07FC  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    512		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    513		  C4 C4	C4 C4 C4 C4 C4+
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 10
DarkX.ASM



    514		  C4 C4	C4 C4 C4 C4 C4+
    515		  C4 C4	C4 C4 C4 C4 C4+
    516		  C4 C4	C4 C4 C4 C4 C4+
    517		  C4 C4	C4 C4 C4 C4 C4+
    518		  C4 C4	C4 C4 C4 C4 C4+
    519		  C4 C4	C4 C4 C4 C4 C4+
    520		  C4 C4	C4 C4 C4 C4 C4+
    521		  C4 C4	C4 C4 C4 C4 C4+
    522		  C4 C4	C4
    523	    084C  45 41	58 20 3D 20					 db "EAX = "
    524	    0852  30 30	30 30 30 30 30+		 debug_eax		 db "00000000h ; "
    525		  30 68	20 3B 20
    526	    085E  45 42	58 20 3D 20					 db "EBX = "
    527	    0864  30 30	30 30 30 30 30+		 debug_ebx		 db "00000000h ; "
    528		  30 68	20 3B 20
    529	    0870  45 43	58 20 3D 20					 db "ECX = "
    530	    0876  30 30	30 30 30 30 30+		 debug_ecx		 db "00000000h ; "
    531		  30 68	20 3B 20
    532	    0882  45 44	58 20 3D 20					 db "EDX = "
    533	    0888  30 30	30 30 30 30 30+		 debug_edx		 db "00000000h",13,10
    534		  30 68	0D 0A
    535	    0893  45 53	49 20 3D 20					 db "ESI = "
    536	    0899  30 30	30 30 30 30 30+		 debug_esi		 db "00000000h ; "
    537		  30 68	20 3B 20
    538	    08A5  45 44	49 20 3D 20					 db "EDI = "
    539	    08AB  30 30	30 30 30 30 30+		 debug_edi		 db "00000000h ; "
    540		  30 68	20 3B 20
    541	    08B7  45 42	50 20 3D 20					 db "EBP = "
    542	    08BD  30 30	30 30 30 30 30+		 debug_ebp		 db "00000000h ; "
    543		  30 68	20 3B 20
    544	    08C9  45 53	50 20 3D 20					 db "ESP = "
    545	    08CF  30 30	30 30 30 30 30+		 debug_esp		 db "00000000h",13,10
    546		  30 68	0D 0A
    547	    08DA  45 46	4C 41 47 53 20+					 db "EFLAGS = "
    548		  3D 20
    549	    08E3  30 30	30 30 30 30 30+		 debug_flags		 db "00000000h",13,10
    550		  30 68	0D 0A
    551	    08EE  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    552		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    553		  C4 C4	C4 C4 C4 C4 C4+
    554		  C4 C4	C4 C4 C4 C4 C4+
    555		  C4 C4	C4 C4 C4 C4 C4+
    556		  C4 C4	C4 C4 C4 C4 C4+
    557		  C4 C4	C4 C4 C4 C4 C4+
    558		  C4 C4	C4 C4 C4 C4 C4+
    559		  C4 C4	C4 C4 C4 C4 C4+
    560		  C4 C4	C4 C4 C4 C4 C4+
    561		  C4 C4	C4 C4 C4 C4 C4+
    562		  C4 C4	C4
    563	    093E  53 65	6C 65 63 74 6F+					 db "Selectors:		 Descriptors:",13,10
    564		  72 73	3A 20 20 20 20+
    565		  20 20	20 20 20 20 44+
    566		  65 73	63 72 69 70 74+
    567		  6F 72	73 3A 0D 0A
    568	    0960  43 53	20 3D 20					 db "CS	= "
    569	    0965  30 30	30 30 68 20 20+		 debug_cs1		 db "0000h    ->    "
    570		  20 20	2D 3E 20 20 20+
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 11
DarkX.ASM



    571		  20
    572	    0974  30 30	20 30 30 20 30+		 desc_cs		 db "00	00 00 00 00 00 00 00",13,10
    573		  30 20	30 30 20 30 30+
    574		  20 30	30 20 30 30 20+
    575		  30 30	0D 0A
    576	    098D  44 53	20 3D 20					 db "DS	= "
    577	    0992  30 30	30 30 68 20 20+		 debug_ds		 db "0000h    ->    "
    578		  20 20	2D 3E 20 20 20+
    579		  20
    580	    09A1  30 30	20 30 30 20 30+		 desc_ds		 db "00	00 00 00 00 00 00 00",13,10
    581		  30 20	30 30 20 30 30+
    582		  20 30	30 20 30 30 20+
    583		  30 30	0D 0A
    584	    09BA  45 53	20 3D 20					 db "ES	= "
    585	    09BF  30 30	30 30 68 20 20+		 debug_es		 db "0000h    ->    "
    586		  20 20	2D 3E 20 20 20+
    587		  20
    588	    09CE  30 30	20 30 30 20 30+		 desc_es		 db "00	00 00 00 00 00 00 00",13,10
    589		  30 20	30 30 20 30 30+
    590		  20 30	30 20 30 30 20+
    591		  30 30	0D 0A
    592	    09E7  46 53	20 3D 20					 db "FS	= "
    593	    09EC  30 30	30 30 68 20 20+		 debug_fs		 db "0000h    ->    "
    594		  20 20	2D 3E 20 20 20+
    595		  20
    596	    09FB  30 30	20 30 30 20 30+		 desc_fs		 db "00	00 00 00 00 00 00 00",13,10
    597		  30 20	30 30 20 30 30+
    598		  20 30	30 20 30 30 20+
    599		  30 30	0D 0A
    600	    0A14  47 53	20 3D 20					 db "GS	= "
    601	    0A19  30 30	30 30 68 20 20+		 debug_gs		 db "0000h    ->    "
    602		  20 20	2D 3E 20 20 20+
    603		  20
    604	    0A28  30 30	20 30 30 20 30+		 desc_gs		 db "00	00 00 00 00 00 00 00",13,10
    605		  30 20	30 30 20 30 30+
    606		  20 30	30 20 30 30 20+
    607		  30 30	0D 0A
    608	    0A41  53 53	20 3D 20					 db "SS	= "
    609	    0A46  30 30	30 30 68 20 20+		 debug_ss		 db "0000h    ->    "
    610		  20 20	2D 3E 20 20 20+
    611		  20
    612	    0A55  30 30	20 30 30 20 30+		 desc_ss		 db "00	00 00 00 00 00 00 00",13,10
    613		  30 20	30 30 20 30 30+
    614		  20 30	30 20 30 30 20+
    615		  30 30	0D 0A
    616	    0A6E  C4 C4	C4 C4 C4 C4 C4+					 db							    +
    617		  C4 C4	C4 C4 C4 C4 C4+	 "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
    618		  C4 C4	C4 C4 C4 C4 C4+
    619		  C4 C4	C4 C4 C4 C4 C4+
    620		  C4 C4	C4 C4 C4 C4 C4+
    621		  C4 C4	C4 C4 C4 C4 C4+
    622		  C4 C4	C4 C4 C4 C4 C4+
    623		  C4 C4	C4 C4 C4 C4 C4+
    624		  C4 C4	C4 C4 C4 C4 C4+
    625		  C4 C4	C4 C4 C4 C4 C4+
    626		  C4 C4	C4 C4 C4 C4 C4+
    627		  C4 C4	C4
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 12
DarkX.ASM



    628	    0ABE  24							 db "$"
    629
    630					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    631					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
    632					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    633
    634					 ;	  include nicedbg.inc		  ; DEBUGGING macros
    635
    636						 include letypes.inc
1   637					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   638					 ; file: letypes.inc
1   639					 ;
1   640					 ;  Data types for LE loader. Used by TX32 extender.
1   641					 ;
1   642					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1   643					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   644
1   645	00000ABF			 LEHEADER	 struc
1   646
1   647	00000000  01*(????)		 signature	 dw	 ?	 ; LE indicates	Linear Executable
1   648	00000002  01*(??)		 byte_order	 db	 ?	 ; Byte	order
1   649	00000003  01*(??)		 word_order	 db	 ?	 ; Word	order
1   650	00000004  01*(????????)		 exe_level	 dd	 ?	 ; Executable format level
1   651	00000008  01*(????)		 cpu_type	 dw	 ?	 ; CPU type (2 - Intel 386, 3 ...)
1   652	0000000A  01*(????)		 target_os	 dw	 ?	 ; Target OS (1	- OS/2)
1   653	0000000C  01*(????????)		 module_version	 dd	 ?	 ; Module version
1   654	00000010  01*(????????)		 module_type	 dd	 ?	 ; Module type
1   655	00000014  01*(????????)		 memory_pages	 dd	 ?	 ; Number of memory pages
1   656	00000018  01*(????????)		 object_cs	 dd	 ?	 ; CS (object number)
1   657	0000001C  01*(????????)		 offset_eip	 dd	 ?	 ; EIP (offset)
1   658	00000020  01*(????????)		 object_ss	 dd	 ?	 ; SS (object number)
1   659	00000024  01*(????????)		 offset_esp	 dd	 ?	 ; ESP (offset)
1   660	00000028  01*(????????)		 page_size	 dd	 ?	 ; Memory page size (4 kb)
1   661	0000002C  01*(????????)		 bytes_last_page dd	 ?	 ; Bytes on last page
1   662	00000030  01*(????????)		 fixup_sect_size dd	 ?	 ; Fixup section size
1   663	00000034  01*(????????)		 fixup_checksum	 dd	 ?	 ; Fixup section checksum
1   664	00000038  01*(????????)		 load_sect_size	 dd	 ?	 ; Loader section size
1   665	0000003C  01*(????????)		 load_checksum	 dd	 ?	 ; Loader section checksum
1   666	00000040  01*(????????)		 off_object_tbl	 dd	 ?	 ; Offset of object table
1   667	00000044  01*(????????)		 obj_tbl_entries dd	 ?	 ; Object table	entries
1   668	00000048  01*(????????)		 off_page_map	 dd	 ?	 ; Object page map table offset
1   669	0000004C  01*(????????)		 off_obj_it_data dd	 ?	 ; Object iterate data map offset
1   670	00000050  01*(????????)		 off_res_table	 dd	 ?	 ; Resource table offset
1   671	00000054  01*(????????)		 res_tbl_entries dd	 ?	 ; Resource table entries
1   672	00000058  01*(????????)		 off_res_names	 dd	 ?	 ; Resident names table	offset
1   673	0000005C  01*(????????)		 off_entry_table dd	 ?	 ; Entry table offset
1   674	00000060  01*(????????)		 off_mod_dirs	 dd	 ?	 ; Module directives table offset
1   675	00000064  01*(????????)		 num_mod_dirs	 dd	 ?	 ; Module directives entries
1   676	00000068  01*(????????)		 off_fixup_pag	 dd	 ?	 ; Fixup page table offset
1   677	0000006C  01*(????????)		 off_fixup_rec	 dd	 ?	 ; Fixup record	table offset
1   678	00000070  01*(????????)		 off_import_mods dd	 ?	 ; Imported modules name table offset
1   679	00000074  01*(????????)		 num_import_mods dd	 ?	 ; Imported modules count
1   680	00000078  01*(????????)		 off_import_proc dd	 ?	 ; Imported procedures name table offset
1   681	0000007C  01*(????????)		 off_pages_chksm dd	 ?	 ; Per-page checksum table offset
1   682	00000080  01*(????????)		 off_data_pages	 dd	 ?	 ; Data	pages offset
1   683	00000084  01*(????????)		 num_preload	 dd	 ?	 ; Preload page	count
1   684	00000088  01*(????????)		 off_nres_names	 dd	 ?	 ; Non-resident	names table offset
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 13
DarkX.ASM



1   685	0000008C  01*(????????)		 len_nres_names	 dd	 ?	 ; Non-resident	names table length
1   686	00000090  01*(????????)		 nres_names_chk	 dd	 ?	 ; Non-resident	names checksum
1   687	00000094  01*(????????)		 auto_data_obj	 dd	 ?	 ; Automatic data object
1   688	00000098  01*(????????)		 off_dbg_nfo	 dd	 ?	 ; Debug information offset
1   689	0000009C  01*(????????)		 len_dbg_nfo	 dd	 ?	 ; Debug information length
1   690	000000A0  01*(????????)		 preload_inst_pg dd	 ?	 ; Preload instance pages number
1   691	000000A4  01*(????????)		 demand_inst_pg	 dd	 ?	 ; Demand instance pages number
1   692	000000A8  01*(????????)		 extra_heap	 dd	 ?	 ; Extra heap allocation
1   693	000000AC  01*(06*(????????))	 leh_reserved	 dd	 6 dup (?)
1   694
1   695	000000C4					 ends
1   696
1   697	00000ABF			 OBJECT		 struc
1   698
1   699	00000000  01*(????????)		 virtual_size	 dd	 ?	 ; Virtual size	in bytes
1   700	00000004  01*(????????)		 relocation_base dd	 ?	 ; Relocation base address
1   701	00000008  01*(????????)		 object_flags	 dd	 ?	 ; Object flags
1   702	0000000C  01*(????????)		 page_map_index	 dd	 ?	 ; Page	map index
1   703	00000010  01*(????????)		 num_pages	 dd	 ?	 ; Number of page map entries
1   704	00000014  01*(????????)		 ot_reserved	 dd	 ?	 ; Reserved
1   705
1   706	00000018					 ends
1   707
1   708	00000ABF			 OBJNFO		 struc
1   709
1   710	00000000  01*(????????)		 obj_handles	 dd	 ?	 ; Object handle to free memory
1   711	00000004  01*(??)		 mem_type	 db	 ?	 ; Handle's memory type
1   712	00000005  01*(????????)		 obj_offset	 dd	 ?	 ; Object's base address
1   713
1   714	00000009					 ends
1   715
1   716
    717
    718					 ; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    719					 ; loadle "data	segment"
    720					 ; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
    721
    722	    0ABF  ????????		 handle		     dd	     ?		 ; File	handle
    723	    0AC3  ????????		 le_offset	     dd	     ?		 ; Offset to LE	header from the	start
    724										 ;  of the file
    725	    0AC7  C4*(??)		 le_hdr		     LEHEADER <>	 ; LE header
    726	    0B8B  0A*(18*(??))		 object_tbl	     OBJECT 10 dup (?)	 ; Object table
    727	    0C7B  0A*(09*(??))		 object_nfo	     OBJNFO 10 dup (?)	 ; Objects info
    728	    0CD5  ????????		 obj_handles_ptr     dd	     ?		 ; Ptr to current object handle
    729	    0CD9  ????????		 num_obj_handles     dd	     ?		 ; Number of memory blocks allocated
    730
    731	    0CDD  ????????		 obj_count	     dd	     ?		 ; Object counter
    732
    733	    0CE1  ????????		 curr_page	     dd	     ?		 ; Now loading this page
    734	    0CE5  ????????		 curr_fixup_pag	     dd	     ?		 ; File	ptr to current fixup page table
    735										 ;  entry
    736	    0CE9  ????????		 off_1st_fixup_rec   dd	     ?		 ; Offset from fixup record table of
    737										 ;  1st	entry for this page
    738	    0CED  ????????		 off_1st_fixup_rec_next_page dd	 ?	 ; Idem	for next page
    739	    0CF1  ????????		 curr_page_off	     dd	     ?		 ; Offset of currently fixed up	page
    740
    741	    0CF5  ??			 source_type	     db	     ?		 ; Fixup's source type
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 14
DarkX.ASM



    742	    0CF6  ??			 target_flags	     db	     ?		 ; Fixup's target flags
    743	    0CF7  ????			 source_off	     dw	     ?		 ; Fixup's source offset
    744	    0CF9  ????			 object_num	     dw	     ?		 ; Fixup's object number
    745	    0CFB  ????????		 target_off	     dd	     ?		 ; Fixup's target offset
    746
    747					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    748					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
    749					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    750
    751	00000CFF			 TFword	 STRUC
    752	00000000  01*(????????)			 loffset	 dd ?
    753	00000004  01*(????)			 selector	 dw ?
    754	00000006			 ENDS
    755
    756		  =0000			 FREE_CB	 EQU 0
    757		  =0001			 ALLOCATED_CB	 EQU 1
    758					 ; call-back data table
    759	00000CFF			 TCallback	 STRUC
    760	00000000  01*(??)			 callback_state	 db ?
    761	00000001  01*(????)			 rm_entry_point	 dw ?
    762	00000003  01*(06*(??))			 pm_proc_to_call TFword	?
    763	00000009  01*(06*(??))			 rm_call_struc	 TFword	?
    764	0000000F			 ENDS
    765
    766		  =OFFSET TXCODE:04D7	 RM_ENTRY=offset callback_address_table
    767	    0CFF			 LABEL	 callback_data
    768					 REPT	 NUM_RM_CALLBACKS
    769						 TCallback <FREE_CB,RM_ENTRY,?,?>
    770							 RM_ENTRY_SIZE=(offset end_of_cb_address-offset	callback_address_table)
    771					 RM_ENTRY=RM_ENTRY+RM_ENTRY_SIZE
    772					 ENDM
1   773	    0CFF  00 04D7r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   774	    0D0E  00 04DEr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   775	    0D1D  00 04E5r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   776	    0D2C  00 04ECr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   777	    0D3B  00 04F3r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   778	    0D4A  00 04FAr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   779	    0D59  00 0501r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   780	    0D68  00 0508r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   781	    0D77  00 050Fr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   782	    0D86  00 0516r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   783	    0D95  00 051Dr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   784	    0DA4  00 0524r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   785	    0DB3  00 052Br 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   786	    0DC2  00 0532r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   787	    0DD1  00 0539r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   788	    0DE0  00 0540r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   789	    0DEF  00 0547r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   790	    0DFE  00 054Er 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   791	    0E0D  00 0555r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   792	    0E1C  00 055Cr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   793	    0E2B  00 0563r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   794	    0E3A  00 056Ar 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   795	    0E49  00 0571r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   796	    0E58  00 0578r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   797	    0E67  00 057Fr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   798	    0E76  00 0586r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 15
DarkX.ASM



1   799	    0E85  00 058Dr 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   800	    0E94  00 0594r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   801	    0EA3  00 059Br 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   802	    0EB2  00 05A2r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   803	    0EC1  00 05A9r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
1   804	    0ED0  00 05B0r 0C*(??)		 TCallback <FREE_CB,RM_ENTRY,?,?>
    805
    806	    0EDF			 TXDATA	 ENDS
    807
    808					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    809					 ; SEGMENTO DE CODIGO PARA RUTINAS DE 16 BITS (	ENTRADA	EN PM, SALIDA, ... )
    810					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    811
    812	    0000			 TXCODE	 SEGMENT PARA USE16 'CODE'
    813					 ASSUME	 CS:TXCODE,DS:txdata,SS:txpila
    814
    815					 INCLUDE	 raw_xms.inc
1   816					 ASSUME	 DS:txdata
1   817					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   818	    0000			 ret_real_raw:
1   819					 ; INPUT -> DS = D16_SEL
1   820	    0000  FA				 cli
1   821
1   822	    0001  8C D8				 mov	 ax,ds
1   823	    0003  8E C0				 mov	 es,ax
1   824	    0005  8E E0				 mov	 fs,ax
1   825	    0007  8E E8				 mov	 gs,ax
1   826	    0009  8E D0				 mov	 ss,ax
1   827
1   828	    000B  0F 01	1E 0548r		 lidt	 fword ptr idt_real
1   829
1   830	    0010  0F 20	C0			 mov	 eax,cr0
1   831	    0013  24 FE				 and	 al,0FEh
1   832	    0015  0F 22	C0			 mov	 cr0,eax
1   833
1   834	    0018  EA			 saltito db 0eah
1   835	    0019  ????				 dw ?
1   836	    001B  ????				 dw ?
1   837
1   838					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   839
1   840	    001D			 set_pm_raw:
1   841					 ; INPUT -> DS = D16_SEL
1   842						 ; ponemos la GDT y la IDT
1   843	    001D  66				 db	 66h
1   844	    001E  0F 01	16 053Cr		 lgdt	 fword ptr gdt_reg
1   845	    0023  0F 01	1E 0542r		 lidt	 fword ptr idt_reg
1   846						 ; vamos a P.MODE
1   847	    0028  0F 01	E0			 smsw	 ax
1   848	    002B  0D 0001			 or	 ax,1
1   849	    002E  0F 01	F0			 lmsw	 ax
1   850	    0031  EB 00				 jmp	 next_label	 ; carga la prefetch queue
1   851	    0033				 next_label:
1   852	    0033  66| FF 2E 0532r		 jmp	 fword ptr prot_code_address
1   853					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   854					 alloc_xms_mem MACRO
1   855						 mov	 ax,txcode32
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 16
DarkX.ASM



1   856						 mov	 es,ax
1   857						 ASSUME	 ES:txcode32
1   858						 mov	 byte ptr es:extended_pointers,0
1   859						 xor	 di,di
1   860						 cont_adding_xms:
1   861						 mov	 ah,8
1   862						 xor	 bl,bl
1   863						 call	 dword ptr xms_entry_point
1   864						 or	 bl,bl
1   865						 jnz	 xms_alloc_done
1   866						 push	 ax
1   867						 mov	 dx,ax
1   868						 mov	 ah,9
1   869						 call	 dword ptr xms_entry_point
1   870						 pop	 cx
1   871						 or	 ax,ax
1   872						 jz	 xms_alloc_done
1   873						 mov	 word ptr es:[di+xms_handles],dx
1   874						 inc	 byte ptr es:extended_pointers
1   875						 mov	 ah,0Ch
1   876						 call	 dword ptr xms_entry_point
1   877						 or	 ax, ax
1   878						 jnz	 page_is_locked	 ; si no la bloquea, no	la a¤adimos a la heap
1   879							 dec	 byte ptr es:extended_pointers
1   880							 jmp	 cont_adding
1   881						 page_is_locked:
1   882						 shl	 edx,16
1   883						 mov	 dx,bx
1   884						 movzx	 ecx,cx
1   885						 shl	 ecx,10
1   886						 mov	 dword ptr es:[di+extended_pointers+1],edx
1   887						 mov	 dword ptr es:[di+extended_pointers+1+4],ecx
1   888						 add	 di,8
1   889						 cmp	 di,8*100
1   890						 je	 xms_alloc_done
1   891						 jmp	 cont_adding_xms
1   892						 xms_alloc_done:
1   893					 ENDM
1   894					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   895					 free_xms_mem	 MACRO
1   896						 ASSUME	 DS:txcode32,ES:txdata
1   897						 mov	 ax,txcode32
1   898						 mov	 ds,ax
1   899						 mov	 ax,txdata
1   900						 mov	 es,ax
1   901						 mov	 si,offset xms_handles
1   902						 movzx	 cx,byte ptr extended_pointers
1   903						 or	 cx,cx
1   904						 jz	 xms_mem_freed
1   905						 free_xms_blocks:
1   906							 mov	 dx,[si]
1   907							 mov	 ah,0Dh		 ; UNLOCK block
1   908							 call	 dword ptr es:xms_entry_point
1   909							 mov	 ah,0Ah		 ; FREE	block
1   910							 call	 dword ptr es:xms_entry_point
1   911							 add	 si,8
1   912						 loop	 free_xms_blocks
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 17
DarkX.ASM



1   913						 xms_mem_freed:
1   914						 ASSUME	 DS:txdata
1   915					 ENDM
1   916					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   917					 look_for_extended_beginning	 MACRO
1   918					 ; buscamos el principio de la extendida libre con el m‚todo VDISK
1   919					 ; OUTPUT -> EAX = extended memory beginning
1   920						 xor	 ax,ax
1   921						 mov	 fs,ax
1   922						 dec	 ax
1   923						 mov	 gs,ax
1   924						 mov	 fs,fs:[19h*4+2]
1   925						 mov	 eax,100000h
1   926						 cmp	 dword ptr fs:[12h],'SIDV'
1   927						 jnz	 method_2
1   928						 mov	 edx,fs:[12h+4]
1   929						 shl	 edx,8
1   930						 shr	 edx,8
1   931						 cmp	 edx,'V	K'
1   932						 jnz	 method_2
1   933						 mov	 eax,fs:[2Ch]
1   934						 shl	 eax,8
1   935						 shr	 eax,8
1   936						 method_2:
1   937						 cmp	 dword ptr gs:[16+3],'SIDV'
1   938						 jnz	 extended_init_found
1   939						 cmp	 byte ptr gs:[16+3+4],'K'
1   940						 jnz	 extended_init_found
1   941						 movzx	 edx,word ptr gs:[16+1Eh]     ;	+16 para el siguiente segmento
1   942						 shl	 edx,10
1   943						 add	 edx,100000h
1   944						 cmp	 edx,eax
1   945						 jbe	 extended_init_found
1   946						 xchg	 edx,eax
1   947						 extended_init_found:
1   948
1   949					 ENDM
1   950					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   951
    952					 INCLUDE	 vcpi.inc
1   953					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   954	    0038			 ret_real_vcpi:
1   955					 ; INPUT -> DS = D16_SEL ; ES =	D32_SEL
1   956	    0038  FA				 cli
1   957
1   958	    0039  06				 push	 es
1   959	    003A  17				 pop	 ss
1   960	    003B  66| BC 00000000s		 mov	 esp,txpila_real
1   961	    0041  66| C1 E4 04			 shl	 esp,4
1   962	    0045  66| 81 C4 00003FF0		 add	 esp,size txpr-4*4 ; simulamos 'push' de los selectores
1   963	    004C  66| 33 C0			 xor	 eax,eax
1   964	    004F  2E: A1 04B6r			 mov	 ax,cs:stack_frame+2
1   965	    0053  66| 50			 push	 eax		 ; ESP
1   966	    0055  2E: A1 04B4r			 mov	 ax,cs:stack_frame
1   967	    0059  66| 50			 push	 eax
1   968	    005B  66| 9C			 pushfd
1   969						 ASSUME	 ES:TXCODE
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 18
DarkX.ASM



1   970	    005D  66| BB 00000000s		 mov	 ebx,txcode
1   971	    0063  66| C1 E3 04			 shl	 ebx,4
1   972	    0067  66| 26: 67| 0F B7 83+		 movzx	 eax,word ptr es:[ebx+saltito+3]
    973		  0000001Br
1   974	    0071  66| 50			 push	 eax		 ; CS
1   975	    0073  66| 26: 67| 0F B7 83+		 movzx	 eax,word ptr es:[ebx+saltito+1]
    976		  00000019r
1   977	    007D  66| 50			 push	 eax		 ; EIP
1   978						 ASSUME	 ES:TXDATA,DS:txdata
1   979	    007F  8C D8				 mov	 ax,ds
1   980	    0081  8C C3				 mov	 bx,es
1   981	    0083  8E C0				 mov	 es,ax
1   982	    0085  8E DB				 mov	 ds,bx
1   983	    0087  B8 DE0C			 mov	 ax,0DE0Ch
1   984	    008A  66| 26: FF 1E	034Br		 call	 fword ptr es:vcpi_entry_point
1   985
1   986					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   987
1   988	    0090			 set_pm_vcpi:
1   989					 ; DS =	TXDATA
1   990	    0090  66| A1 0532r			 mov	 eax,prot_code_address
1   991	    0094  66| A3 055Er			 mov	 vcpi_cs_eip,eax
1   992	    0098  B8 DE0C			 mov	 ax,0DE0Ch
1   993	    009B  66| BE 00000000s		 mov	 esi,txdata
1   994	    00A1  66| C1 E6 04			 shl	 esi,4
1   995	    00A5  66| 81 C6 0000054Er		 add	 esi,offset vcpi_sys_regs
1   996	    00AC  CD 67				 int	 67h
1   997
1   998					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1   999
1  1000					 save_vcpi_data	 MACRO
1  1001						 mov	 ax,txdata
1  1002						 mov	 ds,ax
1  1003						 mov	 set_pm_address,offset set_pm_vcpi
1  1004						 mov	 ret_real_address,offset ret_real_vcpi
1  1005					 ENDM
1  1006
1  1007					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1008
1  1009	    00AE			 vcpi_init	 proc
1  1010						 ; le decimos que redireccionamos las irq's
1  1011	    00AE  B8 DE0A			 mov	 ax,0DE0Ah
1  1012	    00B1  CD 67				 int	 67h	 ; averiguamos la base de las irq's 8-15
1  1013	    00B3  0A E4				 or	 ah,ah
1  1014	    00B5  0F 85	011D			 jnz	 vcpi_init_error
1  1015	    00B9  2E: 88 1E 0A68r		 mov	 cs:irq_base,bl
1  1016	    00BE  B8 DE0B			 mov	 ax,0DE0Bh
1  1017	    00C1  BB 0050			 mov	 bx,50h	 ; base	de las irq's bajas
1  1018	    00C4  FA				 cli
1  1019	    00C5  CD 67				 int	 67h
1  1020	    00C7  0A E4				 or	 ah,ah
1  1021	    00C9  0F 85	0109			 jnz	 vcpi_init_error
1  1022
1  1023						 ; le pedimos un interface al gestor
1  1024						 ; necesitamos un buffer de 4Kb	por cada 4Mb que haya en el sistema
1  1025	    00CD  B8 DE02			 mov	 ax,0DE02h
1  1026	    00D0  CD 67				 int	 67h	 ; this	function never fails (EDX=physical address of highest 4Kb   +
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 19
DarkX.ASM



   1027					 page)
1  1028	    00D2  66| 81 C2 00400FFF		 add	 edx,4096+3FFFFFh  ; (tama¤o = direcci¢n £ltima	p gina + 4096)+3fffffh para +
   1029					 alinear a 4Mb
1  1030	    00D9  66| 81 E2 FFC00000		 and	 edx,NOT 3FFFFFh
1  1031	    00E0  66| 52			 push	 edx
1  1032
1  1033	    00E2  66| C1 EA 0E			 shr	 edx,14	 ; phys.address*4Kb/4Mb/16   (p rrafos necesarios)
1  1034	    00E6  8B DA				 mov	 bx,dx
1  1035						 ; queremos adem s 4Kb para el directorio de p ginas
1  1036						 ; + 4K	por si est  desalineado
1  1037						 ; + 256 bytes para el TSS (104	m¡nimo)
1  1038	    00E8  81 C3	0210			 add	 bx,(4096+4096+256)/16
1  1039	    00EC  E8 0CE3			 call	 get_dos_mem
1  1040	    00EF  05 00FF			 add	 ax,0FFh	 ; lo alineamos	a 4Kb
1  1041	    00F2  25 FF00			 and	 ax,0FF00h	 ; a la	siguiente p gina
1  1042	    00F5  8E C0				 mov	 es,ax
1  1043
1  1044						 ; inicializamos el directorio de p ginas a 0
1  1045	    00F7  33 FF				 xor	 di,di
1  1046	    00F9  66| 33 C0			 xor	 eax,eax
1  1047	    00FC  B9 0400			 mov	 cx,1000h/4
1  1048	    00FF  FC				 cld
1  1049	    0100  F3> 66| AB			 rep	 stosd
1  1050						 ; mapeamos toda la memoria existente a	s¡ misma
1  1051	    0103  66| 59			 pop	 ecx
1  1052	    0105  66| C1 E9 16			 shr	 ecx,22		 ; ECX = N£mero	de tablas de p ginas necesarias
1  1053	    0109  66| B8 00000067		 mov	 eax,67h	 ; first page dirty,accessed,user,writeable,present
1  1054	    010F  06 1E				 push	 es ds
1  1055	    0111  06				 push	 es
1  1056	    0112  1F				 pop	 ds
1  1057	    0113  33 F6				 xor	 si,si
1  1058	    0115				 set_page_dir_entries:
1  1059	    0115  51					 push	 cx
1  1060	    0116  BF 1000				 mov	 di,1000h
1  1061	    0119  B9 0400				 mov	 cx,1024 ; pages in a page table
1  1062	    011C					 set_page_table_entries:
1  1063	    011C  66| AB					 stosd
1  1064	    011E  66| 05 00001000				 add	 eax,1000h
1  1065	    0124  E2 F6					 loop	 set_page_table_entries
1  1066	    0126  8C C1					 mov	 cx,es
1  1067	    0128  51					 push	 cx
1  1068	    0129  81 C1	0100				 add	 cx,4096/16	 ; ES:1000h -> siguiente tabla
1  1069	    012D  8E C1					 mov	 es,cx
1  1070	    012F  66| 33 C9				 xor	 ecx,ecx
1  1071	    0132  59					 pop	 cx
1  1072							 ; llenamos la entrada del directorio de p ginas
1  1073	    0133  66| C1 E1 04				 shl	 ecx,4
1  1074	    0137  66| 81 C1 00001007			 add	 ecx,1007h	 ; siguiente tabla (USER,WRITEABLE,PRESENT)
1  1075	    013E  66| 89 0C				 mov	 [si],ecx
1  1076	    0141  83 C6	04				 add	 si,4
1  1077	    0144  59					 pop	 cx
1  1078	    0145  E2 CE				 loop	 set_page_dir_entries
1  1079
1  1080						 ; guardamos la	primera	entrada	libre en el directorio de p ginas
1  1081	    0147  66| 33 DB			 xor	 ebx,ebx
1  1082	    014A  8C DB				 mov	 bx,ds
1  1083	    014C  1F				 pop	 ds
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 20
DarkX.ASM



1  1084	    014D  66| C1 E3 04			 shl	 ebx,4
1  1085	    0151  66| 89 1E 0351r		 mov	 dir_base,ebx
1  1086	    0156  66| 0F B7 F6			 movzx	 esi,si
1  1087	    015A  66| 03 DE			 add	 ebx,esi
1  1088	    015D  66| 89 1E 0355r		 mov	 page_dir_base,ebx	 ; linear address of first free	page dir. entry
1  1089	    0162  66| BB 00000400		 mov	 ebx,4096/4		 ; total number	of entries in directory
1  1090	    0168  66| C1 EE 02			 shr	 esi,2
1  1091	    016C  66| 2B DE			 sub	 ebx,esi
1  1092	    016F  66| 89 1E 0359r		 mov	 page_dir_entries,ebx	 ; number of available entries
1  1093
1  1094						 ; el espacio para el TSS est  despu‚s de la £ltima tabla de p ginas
1  1095	    0174  8C C0				 mov	 ax,es
1  1096	    0176  07				 pop	 es
1  1097	    0177  66| 0F B7 C0			 movzx	 eax,ax
1  1098	    017B  66| C1 E0 04			 shl	 eax,4
1  1099	    017F  66| 05 00001000		 add	 eax,1000h	 ;1000h-7
1  1100	    0185  A3 05AEr			 mov	 word ptr tss_desc+2,ax
1  1101	    0188  66| C1 E8 10			 shr	 eax,16
1  1102	    018C  A2 05B0r			 mov	 byte ptr tss_desc+4,al
1  1103						 ; pedimos el interface
1  1104	    018F  BF 1000			 mov	 di,1000h
1  1105	    0192  B8 DE01			 mov	 ax,0DE01h
1  1106	    0195  BE 05B4r			 mov	 si,offset vcpi_descs	 ; DS:SI -> buffer 3 desc.'s
1  1107	    0198  CD 67				 int	 67h
1  1108	    019A  0A E4				 or	 ah,ah
1  1109	    019C  75 38				 jnz	 vcpi_init_error
1  1110	    019E  66| 89 1E 034Br		 mov	 vcpi_entry_point,ebx
1  1111					 ;	  xor	  ebx,ebx
1  1112					 ;	  mov	  bx,es
1  1113					 ;	  shl	  ebx,4
1  1114					 ;	  mov	  page_base,ebx
1  1115					 ;	  add	  page_base,1000h	  ; page table base
1  1116					 ;	  movzx	  edi,di
1  1117					 ;	  mov	  last_free_page,ebx
1  1118					 ;	  add	  last_free_page,2000h	  ; + 4Kb (page	dir.) +	4Kb (page table)
1  1119					 ;	  add	  ebx,edi
1  1120					 ;	  mov	  first_free_page,ebx
1  1121						 ; miramos si el directorio de p ginas est  paginado a alg£n sitio
1  1122	    01A3  8C C3				 mov	 bx,es
1  1123	    01A5  C1 EB	02			 shr	 bx,2
1  1124	    01A8  66| 26: 8B 87	1000		 mov	 eax,es:[bx+1000h]
1  1125	    01AE  66| C1 E8 04			 shr	 eax,4
1  1126	    01B2  32 C0				 xor	 al,al
1  1127						 ; preparamos la tabla de p ginas
1  1128	    01B4  66| A3 054Er			 mov	 vcpi_cr3,eax
1  1129						 ; preparamos la estructura de registros para el salto
1  1130	    01B8  66| B8 00000000s		 mov	 eax,txdata
1  1131	    01BE  66| C1 E0 04			 shl	 eax,4
1  1132	    01C2  66| 01 06 0552r		 add	 vcpi_gdtr,eax
1  1133	    01C7  66| 01 06 0556r		 add	 vcpi_idtr,eax
1  1134	    01CC  66| 81 06 055Er     +		 add	 vcpi_cs_eip,offset c32_init
   1135		  00001A63r
1  1136	    01D5  C3				 ret
1  1137
1  1138	    01D6				 vcpi_init_error:
1  1139	    01D6  BA 035Dr				 mov	 dx,offset vcpi_init_err_msg
1  1140	    01D9  E8 0BC3				 call	 printf
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 21
DarkX.ASM



1  1141	    01DC  E9 0826				 jmp	 fin
1  1142
1  1143	    01DF			 vcpi_init	 endp
1  1144					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1145
   1146					 INCLUDE	 dpmi.inc
1  1147		  =0007			 SELECTORS	 equ 7	  ; no queremos	los 4 del VCPI ni el del PSP
1  1148					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1149	    01DF			 dpmi_error:
1  1150					 ; DS =	D16_SEL
1  1151						 ; ponemos la real mode	call structure
1  1152	    01DF  1E				 push	 ds
1  1153	    01E0  07				 pop	 es
1  1154	    01E1  66| BF 00000407r		 mov	 edi,offset dpmi_rm_call
1  1155	    01E7  67| C6 47 1C 09		 mov	 byte ptr [edi+1Ch],9
1  1156	    01EC  67| C7 47 24 0000s		 mov	 word ptr [edi+24h],txdata
1  1157	    01F2  67| C7 47 14 03A6r		 mov	 word ptr [edi+14h],offset dpmi_init_error
1  1158					 ;	  mov	  word ptr [di+30h],txpila
1  1159					 ;	  mov	  word ptr [di+2Eh],size txpila
1  1160	    01F8  BB 0021			 mov	 bx,21h
1  1161	    01FB  33 C9				 xor	 cx,cx
1  1162	    01FD  B8 0300			 mov	 ax,300h
1  1163	    0200  CD 31				 int	 31h
1  1164	    0202  E9 081F			 jmp	 no_vcpi_end
1  1165
1  1166					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1167
1  1168	    0205			 save_dpmi_data	 proc
1  1169	    0205  BA 0380r			 mov	 dx,offset dpmi_32b_error
1  1170	    0208  F6 C3	01			 test	 bl,1
1  1171	    020B  0F 84	0B84			 jz	 error_handle
1  1172						 ASSUME	 DS:txdata
1  1173	    020F  B8 0000s			 mov	 ax,txdata
1  1174	    0212  8E D8				 mov	 ds,ax
1  1175						 ; guardamos el	DPMI mode-switch entry point
1  1176	    0214  2E: 89 3E 0234r		 mov	 word ptr cs:dpmi_mode_switch,di
1  1177	    0219  2E: 8C 06 0236r		 mov	 word ptr cs:dpmi_mode_switch+2,es
1  1178	    021E  56				 push	 si
1  1179						 ; alojamos la memoria que necesite el DPMI
1  1180	    021F  5B				 pop bx
1  1181	    0220  E8 0BAF			 call	 get_dos_mem
1  1182	    0223  A3 03F1r			 mov	 dpmi_private_buffer,ax
1  1183	    0226  C3				 ret
1  1184	    0227			 save_dpmi_data	 endp
1  1185					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1186
1  1187	    0227			 dpmi_init:
1  1188							 ; cargamos en DS el segmento para corregirlo todo
1  1189	    0227  B8 0000s				 mov	 ax,txdata
1  1190	    022A  8E D8					 mov	 ds,ax
1  1191
1  1192							 ; PM switch
1  1193	    022C  B8 0001				 mov	 ax,1
1  1194	    022F  8E 06	03F1r				 mov	 es,dpmi_private_buffer
1  1195	    0233  9A						 db	 9Ah	 ; CALL	FAR PTR
1  1196	    0234  00000000		 dpmi_mode_switch	 dd 0
1  1197	    0238  FA					 cli			 ; por si acaso...
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 22
DarkX.ASM



1  1198	    0239  BA 03A6r				 mov	 dx,offset dpmi_init_error
1  1199	    023C  0F 82	0B53				 jc	 error_handle	 ; estaremos todav¡a en	real
1  1200
1  1201							 ; guardamos el	selector del PSP
1  1202	    0240  8C 06	0335r				 mov	 psp_selector,es
1  1203
1  1204							 ; guardamos el	selector del entorno
1  1205
1  1206							 ; estamos en protegido
1  1207							 ; alojamos descriptores
1  1208	    0244  33 C0					 xor	 ax,ax
1  1209	    0246  B9 0007				 mov	 cx,SELECTORS
1  1210	    0249  CD 31					 int	 31h
1  1211	    024B  72 92					 jc	 dpmi_error
1  1212	    024D  50					 push	 ax
1  1213
1  1214							 ; miramos el incremento de selector
1  1215	    024E  B8 0003				 mov	 ax,3
1  1216	    0251  CD 31					 int	 31h
1  1217
1  1218	    0253  8B E8					 mov	 bp,ax
1  1219	    0255  5B					 pop	 bx
1  1220
1  1221							 ; corregimos los selectores
1  1222	    0256  66| B9 00000007			 mov	 ecx,SELECTORS
1  1223							 ASSUME	 DS:txdata
1  1224	    025C  66| BF 00000427r			 mov	 edi,offset dpmi_sels
1  1225	    0262  8B D3					 mov	 dx,bx
1  1226	    0264					 suma_sels:
1  1227	    0264  67| 89 17					 mov	 [edi],dx
1  1228	    0267  03 D0						 add	 dx,ax
1  1229	    0269  66| 83 C7 04					 add	 edi,4
1  1230	    026D  E2 F5					 loop	 suma_sels
1  1231
1  1232							 ; averiguamos el PL actual y lo ponemos en los	descriptores
1  1233	    026F  1E					 push	 ds
1  1234	    0270  07					 pop	 es
1  1235	    0271  8C C8					 mov	 ax,cs
1  1236	    0273  0F 02	D0				 lar	 dx,ax	 ; coge	access rights
1  1237	    0276  80 E6	60				 and	 dh,60h	 ; a¡sla PL
1  1238	    0279  66| B9 00000007			 mov	 ecx,SELECTORS
1  1239	    027F  66| BF 0000056Cr			 mov	 edi,offset gdt+8
1  1240	    0285					 pon_dpl:
1  1241	    0285  26: 67| 08 77	05				 or	 es:[edi+5],dh
1  1242	    028A  B8 000C					 mov	 ax,0Ch
1  1243	    028D  CD 31						 int	 31h
1  1244	    028F  0F 82	FF4C					 jc	 dpmi_error
1  1245	    0293  66| 83 C7 08					 add	 edi,8
1  1246	    0297  03 DD						 add	 bx,bp
1  1247	    0299  E2 EA					 loop	 pon_dpl
1  1248							 ; fix-up de selectores
1  1249	    029B  8E 06	042Br				 mov	 es,word ptr dpmi_sels+4
1  1250	    029F  66| BF 00000000s			 mov	 edi,txcode32
1  1251	    02A5  66| C1 E7 04				 shl	 edi,4
1  1252	    02A9  66| 81 C7 00000000r			 add	 edi,offset C32_SEL
1  1253
1  1254	    02B0  66| BE 00000427r			 mov	 esi,offset dpmi_sels
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 23
DarkX.ASM



1  1255	    02B6  66| B9 00000007			 mov	 ecx,SELECTORS
1  1256							 ; si los copiamos con MOVSD no	los copia bien (???)
1  1257	    02BC					 copia_sels:
1  1258	    02BC  66| 67| 8B 06					 mov	 eax,[esi]
1  1259	    02C0  66| 26: 67| 89 07				 mov	 es:[edi],eax
1  1260	    02C5  66| 83 C7 04					 add	 edi,4
1  1261	    02C9  66| 83 C6 04					 add	 esi,4
1  1262	    02CD  E2 ED					 loop copia_sels
1  1263	    02CF  A1 0427r				 mov	 ax,word ptr dpmi_sels
1  1264
1  1265							 ; SS:ESP = D32_SEL:STACK_PTR
1  1266					 ;		  mov	  ss,dpmi_sels+4
1  1267					 ;		  mov	  esp,stack_ptr
1  1268
1  1269							 ; hacemos el fix-up del salto a protegido antes de cargarnos DS
1  1270	    02D2  A3 0536r				 mov	 word ptr prot_code_address+4,ax
1  1271	    02D5  50					 push	 ax
1  1272
1  1273					 ;		  ; pedimos las	direcciones de los procs. de save/restore
1  1274					 ;		  mov	  ax,305h
1  1275					 ;		  int	  31h
1  1276					 ;		  mov	  word ptr dpmi_save_restore_real,cx
1  1277					 ;		  mov	  word ptr dpmi_save_restore_real+2,bx
1  1278					 ;		  mov	  dword	ptr dpmi_save_restore_pm,edi
1  1279					 ;		  mov	  word ptr dpmi_save_restore_pm+4,si
1  1280					 ;		  ; pedimos las	direcciones de switch en raw mode
1  1281					 ;		  mov	  ax,306h
1  1282					 ;		  int	  31h
1  1283					 ;		  mov	  word ptr dpmi_real_to_pm,cx
1  1284					 ;		  mov	  word ptr dpmi_real_to_pm+2,bx
1  1285					 ;		  mov	  dword	ptr dpmi_pm_to_real,edi
1  1286					 ;		  mov	  word ptr dpmi_pm_to_real+4,si
1  1287
1  1288							 ; nos guardamos las excepciones
1  1289	    02D6  32 DB					 xor	 bl,bl
1  1290	    02D8  66| BF 00000443r			 mov	 edi,offset dpmi_exc_handlers
1  1291	    02DE					 guarda_excs:
1  1292	    02DE  B8 0202					 mov	 ax,202h
1  1293	    02E1  CD 31						 int	 31h
1  1294	    02E3  66| 67| 89 17					 mov	 [edi],edx
1  1295	    02E7  67| 89 4F 04					 mov	 [edi+4],cx
1  1296	    02EB  66| 83 C7 06					 add	 edi,6
1  1297	    02EF  FE C3						 inc	 bl
1  1298	    02F1  80 FB	0F				 cmp	 bl,15
1  1299	    02F4  75 E8					 jnz guarda_excs
1  1300							 ; ajustamos las excepciones 0,1,3-0Eh
1  1301	    02F6  59					 pop	 cx
1  1302	    02F7  51					 push	 cx
1  1303	    02F8  32 DB					 xor	 bl,bl
1  1304	    02FA  66| BA 00002718r			 mov	 edx,offset interrup_redir
1  1305	    0300					 dpmi_set_excs:
1  1306	    0300  B8 0203					 mov	 ax,203h
1  1307	    0303  CD 31						 int	 31h
1  1308	    0305  0F 82	FED6					 jc	 dpmi_error
1  1309	    0309  FE C3						 inc	 bl
1  1310	    030B  66| 83 C2 08					 add	 edx,8
1  1311	    030F  80 FB	0F				 cmp	 bl,15
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 24
DarkX.ASM



1  1312	    0312  75 EC					 jnz	 dpmi_set_excs
1  1313	    0314  66| 8B 16 044Fr			 mov	 edx,dword ptr dpmi_exc_handlers+2*6
1  1314	    0319  8B 0E	0453r				 mov	 cx,word ptr dpmi_exc_handlers+2*6+4
1  1315	    031D  B8 0203				 mov	 ax,203h
1  1316	    0320  B3 02					 mov	 bl,2	 ; la 2	no es excepci¢n...
1  1317	    0322  CD 31					 int	 31h
1  1318	    0324  0F 82	FEB7				 jc	 dpmi_error
1  1319
1  1320							 ; guardamos las interrupciones
1  1321	    0328  32 DB					 xor	 bl,bl
1  1322	    032A  66| BF 00000000s			 mov	 edi,txcode32
1  1323	    0330  66| C1 E7 04				 shl	 edi,4
1  1324	    0334					 guarda_ints:
1  1325	    0334  B8 0204					 mov	 ax,204h
1  1326	    0337  CD 31						 int	 31h
1  1327								 ASSUME	 ES:txcode32
1  1328	    0339  66| 26: 67| 89 97   +				 mov	 dword ptr es:[edi+idt],edx
   1329		  00001F18r
1  1330	    0342  26: 67| 89 8F	      +				 mov	 word ptr es:[edi+idt+4],cx
   1331		  00001F1Cr
1  1332	    034A  66| 83 C7 06					 add	 edi,6
1  1333	    034E  FE C3					 inc bl
1  1334	    0350  75 E2					 jnz guarda_ints
1  1335
1  1336							 ; ponemos las nuevas int's 21h	y 31h
1  1337	    0352  59					 pop	 cx
1  1338	    0353  51					 push	 cx
1  1339	    0354  B3 21					 mov	 bl,21h
1  1340	    0356  66| BA 00000F4Dr			 mov	 edx,offset tx_int21h
1  1341	    035C  B8 0205				 mov	 ax,205h
1  1342	    035F  CD 31					 int	 31h
1  1343	    0361  0F 82	FE7A				 jc	 dpmi_error
1  1344
1  1345	    0365  59					 pop	 cx
1  1346	    0366  B3 31					 mov	 bl,31h
1  1347	    0368  66| BA 0000001Cr			 mov	 edx,offset tx_int31h
1  1348	    036E  B8 0205				 mov	 ax,205h
1  1349	    0371  CD 31					 int	 31h
1  1350	    0373  0F 82	FE68				 jc	 dpmi_error
1  1351
1  1352							 ; rellenamos info varia para la funci¢n OEM 3201h
1  1353	    0377  2E: 67| A1 00000004r			 mov	 ax,cs:D32_SEL
1  1354	    037E  A3 0331r				 mov	 zero_sel,ax
1  1355	    0381  2E: 67| A1 00000014r			 mov	 ax,cs:DATA_SEL
1  1356	    0388  A3 0333r				 mov	 prog_sel,ax
1  1357	    038B  2E: 67| A1 00000018r			 mov	 ax,cs:ENVRN_SEL
1  1358	    0392  A3 0337r				 mov	 env_selector,ax
1  1359							 ASSUME	 ES:txdata
1  1360
1  1361							 ; y nos vamos al programa
1  1362	    0395  66| FF 2E 0532r			 jmp	 fword ptr prot_code_address
1  1363					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1364
   1365					 INCLUDE	 ints16.inc
1  1366					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1367					 ; Standard DPMI 0.9 Real Mode Call and	Interrupt execution with segment pass
1  1368					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 25
DarkX.ASM



1  1369	    039A			 dpmi_rm_int:
1  1370	    039A  FA				 cli
1  1371
1  1372						 ASSUME	 SS:txdata
1  1373	    039B  B8 0000s			 mov	 ax,txdata
1  1374	    039E  8E D0				 mov	 ss,ax
1  1375	    03A0  BC 03E9r			 mov	 sp,offset dpmi_rm_call_struc+2Ah
1  1376	    03A3  2E: 8F 06 04BAr		 pop	 word ptr cs:rm_proc_address
1  1377	    03A8  2E: 8F 06 04BCr		 pop	 word ptr cs:rm_proc_address+2
1  1378	    03AD  2E: 8F 06 04B4r		 pop	 cs:stack_frame
1  1379	    03B2  2E: 8F 06 04B6r		 pop	 cs:stack_frame+2
1  1380	    03B7  66| 2E: 83 3E	04B4r +		 cmp	 dword ptr cs:stack_frame,0
   1381		  00
1  1382	    03BE  75 0E				 jnz	 need_a_stack
1  1383	    03C0  2E: C7 06 04B4r 4000		 mov	 cs:stack_frame,size txpr
1  1384	    03C7  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   1385		  0000s
1  1386	    03CE				 need_a_stack:
1  1387	    03CE  2E: A1 04B8r			 mov	 ax,cs:bytes_in_stack
1  1388	    03D2  2E: 29 06 04B4r		 sub	 cs:stack_frame,ax
1  1389	    03D7  66| 36: A1 0504r		 mov	 eax,ss:pm_eax
1  1390	    03DC  2E: A3 0452r			 mov	 cs:int_or_call,ax
1  1391	    03E0  3D 0300			 cmp	 ax,300h
1  1392	    03E3  75 1E				 jnz	 pre_rm_call
1  1393
1  1394						 ; reajustamos la pila para int	en modo	real
1  1395	    03E5  33 DB				 xor	 bx,bx
1  1396	    03E7  2E: 8C 1E 04B2r		 mov	 cs:trash,ds
1  1397	    03EC  8E DB				 mov	 ds,bx
1  1398	    03EE  36: 8A 1E 0508r		 mov	 bl,byte ptr ss:pm_ebx
1  1399	    03F3  C1 E3	02			 shl	 bx,2
1  1400	    03F6  66| 8B 07			 mov	 eax,ds:[bx]
1  1401	    03F9  66| 2E: A3 04BAr		 mov	 cs:rm_proc_address,eax
1  1402	    03FE  2E: 8E 1E 04B2r		 mov	 ds,cs:trash
1  1403
1  1404	    0403			 pre_rm_call:
1  1405	    0403  BC 03BFr			 mov	 sp,offset dpmi_rm_call_struc
1  1406	    0406  66| 61			 popad
1  1407	    0408  2E: 8F 06 04B2r		 pop	 cs:trash	 ; trash = FLAGS para no cambiarlos con	el CMP
1  1408	    040D  07				 pop	 es
1  1409	    040E  1F				 pop	 ds
1  1410	    040F  0F A1				 pop	 fs
1  1411	    0411  0F A9				 pop	 gs
1  1412	    0413  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
1  1413	    0419  2E: 81 3E 0452r 0301		 cmp	 cs:int_or_call,301h
1  1414	    0420  74 05				 jz	 no_flag_save
1  1415	    0422  2E: FF 36 04B2r		 push	 cs:trash	 ; para	formar un stack	frame de interrupci¢n
1  1416	    0427				 no_flag_save:
1  1417	    0427  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1418
1  1419						 ; copiamos los	segmentos a la estructura
1  1420						 ASSUME	 DS:txdata
1  1421	    042C  1E				 push	 ds
1  1422	    042D  68 0000s			 push	 txdata
1  1423	    0430  1F				 pop	 ds
1  1424	    0431  8C 06	04F4r			 mov	 real_es,es
1  1425	    0435  8C 26	04F8r			 mov	 real_fs,fs
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 26
DarkX.ASM



1  1426	    0439  8C 2E	04FAr			 mov	 real_gs,gs
1  1427	    043D  8F 06	04F6r			 pop	 real_ds
1  1428
1  1429						 ; restablecemos la pila por defecto por si ha habido int31h/ax=30xh
1  1430	    0441  2E: C7 06 04B4r 4000		 mov	 cs:stack_frame,size txpr
1  1431	    0448  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   1432		  0000s
1  1433
1  1434	    044F  E9 053C			 jmp	 set_pm		 ; SET_PM nos grabar  el estado
1  1435
1  1436	    0452  ????			 int_or_call	 dw ?
1  1437					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1438					 ; Real	Mode Interrupt execution without segment pass
1  1439					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1440					 ASSUME	 DS:txdata
1  1441	    0454			 rm_int:
1  1442						 ; reajustamos la pila para int	en modo	real
1  1443	    0454  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
1  1444	    045A  33 DB				 xor	 bx,bx
1  1445	    045C  2E: 8C 1E 04B2r		 mov	 cs:trash,ds
1  1446	    0461  8E DB				 mov	 ds,bx
1  1447	    0463  2E: 8A 1E 04B1r		 mov	 bl,cs:int_num
1  1448	    0468  C1 E3	02			 shl	 bx,2
1  1449	    046B  66| 8B 07			 mov	 eax,[bx]
1  1450	    046E  66| 2E: A3 04BAr		 mov	 cs:rm_proc_address,eax
1  1451	    0473  2E: 8E 1E 04B2r		 mov	 ds,cs:trash
1  1452
1  1453	    0478  1E				 push	 ds
1  1454
1  1455	    0479  B8 0000s			 mov	 ax,txdata
1  1456	    047C  8E D8				 mov	 ds,ax
1  1457
1  1458						 ; recuperamos los registros
1  1459	    047E  66| A1 0504r			 mov	 eax,pm_eax
1  1460	    0482  66| 8B 1E 0508r		 mov	 ebx,pm_ebx
1  1461	    0487  66| 8B 0E 050Cr		 mov	 ecx,pm_ecx
1  1462	    048C  66| 8B 16 0510r		 mov	 edx,pm_edx
1  1463	    0491  66| 8B 36 0514r		 mov	 esi,pm_esi
1  1464	    0496  66| 8B 3E 0518r		 mov	 edi,pm_edi
1  1465	    049B  66| 8B 2E 051Cr		 mov	 ebp,pm_ebp
1  1466	    04A0  66| FF 36 0524r		 push	 pm_eflags
1  1467	    04A5  66| 9D			 popfd
1  1468	    04A7  1F				 pop	 ds
1  1469
1  1470	    04A8  9C				 pushf		 ; para	formar un stack	frame de interrupci¢n
1  1471	    04A9  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1472
1  1473	    04AE  E9 04DD			 jmp	 set_pm		 ; SET_PM nos grabar  el estado
1  1474
1  1475	    04B1  ??			 int_num	 db ?
1  1476	    04B2  ????			 trash		 dw ?
1  1477	    04B4  4000 ????		 stack_frame	 dw size txpr,?
1  1478	    04B8  0000			 bytes_in_stack	 dw 0
1  1479	    04BA  ????????		 rm_proc_address dd ?
1  1480					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1481	    04BE			 irq16:
1  1482	    04BE  2E: 0F B2 26 04B4r		 lss	 sp,dword ptr cs:stack_frame
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 27
DarkX.ASM



1  1483	    04C4  81 EC	2000			 sub	 sp,(RM_STACKSIZE/2)*4	 ; por si pillamos un proc real	entrando
1  1484	    04C8  9C				 pushf			 ; stack frame de interrupci¢n
1  1485	    04C9  2E: FF 1E 04BAr		 call	 dword ptr cs:rm_proc_address
1  1486	    04CE  B8 0000s			 mov	 ax,txdata
1  1487	    04D1  8E D8				 mov	 ds,ax
1  1488	    04D3  FF 26	0530r			 jmp	 set_pm_address
1  1489					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1490
   1491					 INCLUDE	 cback16.inc
1  1492					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1493					 ; Real	Mode Call-Back routines
1  1494					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1495
1  1496					 ; call-back address table
1  1497	    04D7			 callback_address_table:
1  1498	    04D7  50				 push	 ax
1  1499	    04D8  B8 0000			 mov	 ax,0
1  1500	    04DB  E9 0117			 jmp	 callback_manager
1  1501	    04DE			 end_of_cb_address:    ; we need it to calculate the length
1  1502		  =000F			 CBSLOT=size TCallBack
1  1503					 REPT	 (NUM_RM_CALLBACKS-1)
1  1504						 push	 ax
1  1505						 mov	 ax,CBSLOT
1  1506						 jmp	 word ptr callback_manager
1  1507						 CBSLOT=CBSLOT+size TCallBack
1  1508					 ENDM
2  1509	    04DE  50				 push	 ax
2  1510	    04DF  B8 000F			 mov	 ax,CBSLOT
2  1511	    04E2  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1512	    04E7  50				 push	 ax
2  1513	    04E8  B8 001E			 mov	 ax,CBSLOT
2  1514	    04EB  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1515	    04F0  50				 push	 ax
2  1516	    04F1  B8 002D			 mov	 ax,CBSLOT
2  1517	    04F4  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1518	    04F9  50				 push	 ax
2  1519	    04FA  B8 003C			 mov	 ax,CBSLOT
2  1520	    04FD  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1521	    0502  50				 push	 ax
2  1522	    0503  B8 004B			 mov	 ax,CBSLOT
2  1523	    0506  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1524	    050B  50				 push	 ax
2  1525	    050C  B8 005A			 mov	 ax,CBSLOT
2  1526	    050F  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1527	    0514  50				 push	 ax
2  1528	    0515  B8 0069			 mov	 ax,CBSLOT
2  1529	    0518  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1530	    051D  50				 push	 ax
2  1531	    051E  B8 0078			 mov	 ax,CBSLOT
2  1532	    0521  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1533	    0526  50				 push	 ax
2  1534	    0527  B8 0087			 mov	 ax,CBSLOT
2  1535	    052A  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1536	    052F  50				 push	 ax
2  1537	    0530  B8 0096			 mov	 ax,CBSLOT
2  1538	    0533  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1539	    0538  50				 push	 ax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 28
DarkX.ASM



2  1540	    0539  B8 00A5			 mov	 ax,CBSLOT
2  1541	    053C  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1542	    0541  50				 push	 ax
2  1543	    0542  B8 00B4			 mov	 ax,CBSLOT
2  1544	    0545  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1545	    054A  50				 push	 ax
2  1546	    054B  B8 00C3			 mov	 ax,CBSLOT
2  1547	    054E  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1548	    0553  50				 push	 ax
2  1549	    0554  B8 00D2			 mov	 ax,CBSLOT
2  1550	    0557  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1551	    055C  50				 push	 ax
2  1552	    055D  B8 00E1			 mov	 ax,CBSLOT
2  1553	    0560  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1554	    0565  50				 push	 ax
2  1555	    0566  B8 00F0			 mov	 ax,CBSLOT
2  1556	    0569  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1557	    056E  50				 push	 ax
2  1558	    056F  B8 00FF			 mov	 ax,CBSLOT
2  1559	    0572  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1560	    0577  50				 push	 ax
2  1561	    0578  B8 010E			 mov	 ax,CBSLOT
2  1562	    057B  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1563	    0580  50				 push	 ax
2  1564	    0581  B8 011D			 mov	 ax,CBSLOT
2  1565	    0584  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1566	    0589  50				 push	 ax
2  1567	    058A  B8 012C			 mov	 ax,CBSLOT
2  1568	    058D  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1569	    0592  50				 push	 ax
2  1570	    0593  B8 013B			 mov	 ax,CBSLOT
2  1571	    0596  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1572	    059B  50				 push	 ax
2  1573	    059C  B8 014A			 mov	 ax,CBSLOT
2  1574	    059F  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1575	    05A4  50				 push	 ax
2  1576	    05A5  B8 0159			 mov	 ax,CBSLOT
2  1577	    05A8  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1578	    05AD  50				 push	 ax
2  1579	    05AE  B8 0168			 mov	 ax,CBSLOT
2  1580	    05B1  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1581	    05B6  50				 push	 ax
2  1582	    05B7  B8 0177			 mov	 ax,CBSLOT
2  1583	    05BA  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1584	    05BF  50				 push	 ax
2  1585	    05C0  B8 0186			 mov	 ax,CBSLOT
2  1586	    05C3  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1587	    05C8  50				 push	 ax
2  1588	    05C9  B8 0195			 mov	 ax,CBSLOT
2  1589	    05CC  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1590	    05D1  50				 push	 ax
2  1591	    05D2  B8 01A4			 mov	 ax,CBSLOT
2  1592	    05D5  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1593	    05DA  50				 push	 ax
2  1594	    05DB  B8 01B3			 mov	 ax,CBSLOT
2  1595	    05DE  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1596	    05E3  50				 push	 ax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 29
DarkX.ASM



2  1597	    05E4  B8 01C2			 mov	 ax,CBSLOT
2  1598	    05E7  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
2  1599	    05EC  50				 push	 ax
2  1600	    05ED  B8 01D1			 mov	 ax,CBSLOT
2  1601	    05F0  2E: FF 26 05F5r		 jmp	 word ptr callback_manager
1  1602
1  1603	000005F5			 Trm_reg	 STRUC
1  1604	00000000  01*(????????)			 rm_edi		 dd ?
1  1605	00000004  01*(????????)			 rm_esi		 dd ?
1  1606	00000008  01*(????????)			 rm_ebp		 dd ?
1  1607	0000000C  01*(????????)					 dd ?
1  1608	00000010  01*(????????)			 rm_ebx		 dd ?
1  1609	00000014  01*(????????)			 rm_edx		 dd ?
1  1610	00000018  01*(????????)			 rm_ecx		 dd ?
1  1611	0000001C  01*(????????)			 rm_eax		 dd ?
1  1612	00000020  01*(????)			 rm_flags	 dw ?
1  1613	00000022  01*(????)			 rm_es		 dw ?
1  1614	00000024  01*(????)			 rm_ds		 dw ?
1  1615	00000026  01*(????)			 rm_fs		 dw ?
1  1616	00000028  01*(????)			 rm_gs		 dw ?
1  1617	0000002A  01*(????)			 rm_ip		 dw ?
1  1618	0000002C  01*(????)			 rm_cs		 dw ?
1  1619	0000002E  01*(????)			 rm_sp		 dw ?
1  1620	00000030  01*(????)			 rm_ss		 dw ?
1  1621	00000032			 ENDS
1  1622
1  1623					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1624					 ; Call-Back Management	procedure with IMS technology (Infinite	Mode Switch)
1  1625					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  1626	    05F5			 callback_manager:
1  1627						 ; guardamos el	puntero	de pila	actual en modo real
1  1628	    05F5  2E: 89 26 0692r		 mov	 word ptr cs:pila_real,sp
1  1629	    05FA  2E: 8C 16 0694r		 mov	 word ptr cs:pila_real+2,ss
1  1630						 ; guardamos el	n£mero de call-back para el c¢digo en protegido
1  1631	    05FF  2E: A3 0690r			 mov	 cs:callback_code,ax
1  1632						 ; guardamos el	estado de la CPU
1  1633	    0603  66| 9C			 pushfd
1  1634	    0605  66| 60			 pushad
1  1635	    0607  1E 06	0F A0 0F A8		 push	 ds es fs gs
1  1636
1  1637						 ; protegemos el stack switching
1  1638	    060D  FA				 cli
1  1639
1  1640						 ; ahora que podemos cambiar los flags,	cambiamos 'pila_real'
1  1641	    060E  2E: 83 06 0692r 02		 add	 word ptr cs:pila_real,2	 ; POP AX
1  1642
1  1643						 ; guardamos las direcciones de	cambio de modos
1  1644						 ASSUME	 DS:txdata
1  1645	    0614  B8 0000s			 mov	 ax,txdata
1  1646	    0617  8E D8				 mov	 ds,ax
1  1647	    0619  66| FF 36 0532r		 push	 dword ptr prot_code_address
1  1648	    061E  FF 36	0536r			 push	 word ptr prot_code_address+4
1  1649	    0622  66| 2E: FF 36	0019r		 push	 dword ptr cs:saltito+1
1  1650
1  1651						 ; ponemos las nuevas
1  1652	    0628  66| C7 06 0532r     +		 mov	 dword ptr prot_code_address,offset callback_pm
   1653		  00000E82r
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 30
DarkX.ASM



1  1654
1  1655						 ; guardamos el	stack frame anterior en	la pila	actual
1  1656	    0631  66| 2E: FF 36	0682r		 push	 dword ptr cs:current_stackframe
1  1657						 ; stack frame actual en la variable de	c¢digo
1  1658	    0637  2E: 89 26 0682r		 mov	 word ptr cs:current_stackframe,sp
1  1659	    063C  2E: 8C 16 0684r		 mov	 word ptr cs:current_stackframe+2,ss
1  1660
1  1661	    0641  FF 26	0530r			 jmp	 set_pm_address
1  1662
1  1663	    0645				 cback16_return:
1  1664	    0645  FA				 cli
1  1665						 ; recuperamos el stack	frame
1  1666	    0646  2E: 0F B2 26 0682r		 lss	 sp,dword ptr cs:current_stackframe
1  1667						 ; ponemos el del posible call back anterior
1  1668	    064C  66| 2E: 8F 06	0682r		 pop	 dword ptr cs:current_stackframe
1  1669
1  1670						 ; recuperamos las direcciones de cambio de modo
1  1671	    0652  B8 0000s			 mov	 ax,txdata
1  1672	    0655  8E D8				 mov	 ds,ax
1  1673	    0657  66| 2E: 8F 06	0019r		 pop	 dword ptr cs:saltito+1
1  1674	    065D  8F 06	0536r			 pop	 word ptr prot_code_address+4
1  1675	    0661  66| 8F 06 0532r		 pop	 dword ptr prot_code_address
1  1676
1  1677						 ; recuperamos el estado de la CPU
1  1678	    0666  0F A9	0F A1 07 1F		 pop	 gs fs es ds
1  1679	    066C  66| 61			 popad
1  1680	    066E  66| 9D			 popfd
1  1681
1  1682	    0670  58				 pop	 ax
1  1683
1  1684						 ; restauramos SS,SP,CS,IP y FLAGS de la estructura de modo real	mov
1  1685	    0671  2E: FF 36 068Er		 push	 cs:new_flags
1  1686	    0676  9D				 popf
1  1687	    0677  2E: 0F B2 26 068Ar		 lss	 sp,cs:new_stack
1  1688	    067D  2E: FF 2E 0686r		 jmp	 dword ptr cs:new_code
1  1689
1  1690	    0682  ????????		 current_stackframe	 dd ?
1  1691	    0686  ????????		 new_code		 dd ?
1  1692	    068A  ????????		 new_stack		 dd ?
1  1693	    068E  ????			 new_flags		 dw ?
1  1694	    0690  ????			 callback_code		 dw ?
1  1695	    0692  ????????		 pila_real		 dd ?
1  1696
   1697
   1698
   1699					 ; ////////////////////////////
   1700					 ; PUNTO DE ENTRADA DE DarkX.EXE
   1701					 ; ////////////////////////////
   1702	    0696			 init_pm:
   1703					 ;	  inc	  dx
   1704					 ;	  xor	  ax,2E32h
   1705					 ;	  dec	  dx
   1706					 ;	  xor	  ax,2e32h
   1707
   1708						 ; presentamos el Copyright y el t¡tulo
   1709	    0696  1E				 push	 ds
   1710	    0697  BA 0000r			 mov	 dx,offset copyright_msg
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 31
DarkX.ASM



   1711	    069A  E8 0702			 call	 printf
   1712	    069D  1F				 pop	 ds
   1713
   1714						 ; comprobamos que el DOS sea 3.0+
   1715	    069E  B4 30				 mov	 ah,30h
   1716	    06A0  CD 21				 int	 21h
   1717	    06A2  3C 03				 cmp	 al,3
   1718	    06A4  BA 0144r			 mov	 dx,offset dos_version_error_msg
   1719	    06A7  0F 82	06EE			 jb	 error_handle1
   1720
   1721						 ; buscamos nuestro nombre
   1722	    06AB  8E 06	002C			 mov	 es,ds:[2Ch]
   1723	    06AF  33 FF				 xor	 di,di
   1724	    06B1  B9 FFFF			 mov	 cx,-1
   1725	    06B4  33 C0				 xor	 ax,ax
   1726	    06B6				 cont_searching:
   1727	    06B6  F2> AE			 repnz	 scasb
   1728	    06B8  AE				 scasb
   1729	    06B9  75 FB				 jnz	 cont_searching
   1730	    06BB  83 C7	02			 add	 di,2
   1731	    06BE  66| 33 C9			 xor	 ecx,ecx
   1732	    06C1  8C C1				 mov	 cx,es
   1733	    06C3  66| 0F B7 FF			 movzx	 edi,di
   1734	    06C7  66| C1 E1 04			 shl	 ecx,4
   1735	    06CB  66| 03 CF			 add	 ecx,edi
   1736
   1737						 ; rellenamos info varia
   1738	    06CE  66| 33 DB			 xor	 ebx,ebx
   1739	    06D1  8C DB				 mov	 bx,ds
   1740	    06D3  B8 0000s			 mov	 ax,txdata
   1741	    06D6  8E D8				 mov	 ds,ax
   1742	    06D8  89 1E	04D0r			 mov	 psp_seg,bx
   1743	    06DC  66| C1 E3 04			 shl	 ebx,4
   1744	    06E0  66| 89 1E 0325r		 mov	 psp_offset,ebx
   1745	    06E5  66| 33 DB			 xor	 ebx,ebx
   1746	    06E8  8C C3				 mov	 bx,es
   1747	    06EA  66| C1 E3 04			 shl	 ebx,4
   1748	    06EE  66| 89 1E 0329r		 mov	 env_offset,ebx
   1749	    06F3  66| 89 0E 032Dr		 mov	 program_name_ptr,ecx
   1750	    06F8  B8 0000s			 mov	 ax,disk
   1751	    06FB  A3 0339r			 mov	 disk_seg,ax
   1752						 ; fix-up del descriptor del ENVIRONMENT (necesario bajo todos sistemas)
   1753	    06FE  8E 26	04D0r			 mov	 fs,psp_seg
   1754	    0702  66| 64: 0F B7	06    +		 movzx	 eax,word ptr fs:[2Ch]
   1755		  002C
   1756	    0709  66| C1 E0 04			 shl	 eax,4
   1757	    070D  A3 059Er			 mov	 word ptr env_desc+2,ax
   1758	    0710  66| C1 E8 10			 shr	 eax,16
   1759	    0714  A2 05A0r			 mov	 byte ptr env_desc+4,al
   1760	    0717  88 26	05A3r			 mov	 byte ptr env_desc+7,ah
   1761
   1762	    071B  E8 058A			 call	 cpuid
   1763	    071E  BA 01C2r			 mov	 dx,offset no386_error_msg
   1764	    0721  0F 82	0674			 jc	 error_handle1
   1765	    0725  A3 033Fr			 mov	 cpu_info,ax
   1766	    0728  80 FC	05			 cmp	 ah,5
   1767	    072B  76 02				 jbe	 have_cpu_name
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 32
DarkX.ASM



   1768	    072D  B4 05					 mov	 ah,5
   1769	    072F				 have_cpu_name:
   1770	    072F  50				 push	 ax
   1771	    0730  33 DB				 xor	 bx,bx
   1772	    0732  8A DC				 mov	 bl,ah
   1773	    0734  D1 E3				 shl	 bx,1
   1774	    0736  8B 97	00A6r			 mov	 dx,[bx+cpu_strings-3*2]
   1775	    073A  52				 push	 dx
   1776	    073B  BA 009Br			 mov	 dx,offset cpu_type_msg
   1777	    073E  E8 065E			 call	 printf
   1778	    0741  5A				 pop	 dx
   1779	    0742  E8 065A			 call	 printf
   1780	    0745  58				 pop	 ax
   1781	    0746  80 FC	05			 cmp	 ah,5
   1782	    0749  73 13				 jae	 no_fpu_det_needed
   1783
   1784	    074B  E8 05E9			 call	 fpuid
   1785	    074E  A2 0342r			 mov	 fpu_info,al
   1786	    0751  33 DB				 xor	 bx,bx
   1787	    0753  8A D8				 mov	 bl,al
   1788	    0755  D1 E3				 shl	 bx,1
   1789	    0757  8B 97	00C3r			 mov	 dx,[bx+fpu_strings]
   1790	    075B  E8 0641			 call	 printf
   1791
   1792	    075E				 no_fpu_det_needed:
   1793						 ; cambiamos el	tama¤o del bloque de programa
   1794	    075E  E8 0648			 call	 init_mem
   1795
   1796						 ; comprobamos si hay DPMI
   1797	    0761  B8 1687			 mov	 ax,1687h
   1798	    0764  CD 2F				 int	 2Fh
   1799	    0766  0B C0				 or	 ax,ax
   1800	    0768  75 0B				 jnz	 no_dpmi
   1801
   1802	    076A  80 0E	0341r 02			 or	 system_type,2
   1803	    076F  E8 FA93				 call	 save_dpmi_data
   1804	    0772  E9 01CB				 jmp	 mem_alloc_done
   1805
   1806	    0775				 no_dpmi:
   1807						 ; ponemos un par de selectores
   1808	    0775  B8 0000s			 mov	 ax,txcode32
   1809	    0778  8E D8				 mov	 ds,ax
   1810						 ASSUME	 DS:txcode32
   1811	    077A  67| A1 00000000r		 mov	 ax,C32_SEL
   1812						 ASSUME	 DS:txdata
   1813	    0780  BB 0000s			 mov	 bx,txdata
   1814	    0783  8E DB				 mov	 ds,bx
   1815	    0785  A3 0562r			 mov	 word ptr vcpi_cs_eip+4,ax
   1816	    0788  A3 0536r			 mov	 word ptr prot_code_address+4,ax
   1817
   1818						 ; comprobamos si hay VCPI
   1819						 ; primero miramos si hay vector o no...
   1820	    078B  33 C0				 xor	 ax,ax
   1821	    078D  8E C0				 mov	 es,ax
   1822	    078F  66| 26: 83 3E	019C  +		 cmp	 dword ptr es:[67h*4],0
   1823		  00
   1824	    0796  74 20				 jz	 vcpi_not_present
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 33
DarkX.ASM



   1825	    0798  B8 DE00			 mov	 ax,0DE00h
   1826	    079B  CD 67				 int	 67h
   1827	    079D  0A E4				 or	 ah,ah
   1828	    079F  75 17				 jnz	 vcpi_not_present
   1829							 ASSUME	 DS:txdata
   1830	    07A1  FE 06	0341r				 inc	 system_type
   1831							 save_vcpi_data
1  1832	    07A5  B8 0000s			 mov	 ax,txdata
1  1833	    07A8  8E D8				 mov	 ds,ax
1  1834	    07AA  C7 06	0530r 0090r		 mov	 set_pm_address,offset set_pm_vcpi
1  1835	    07B0  C7 06	0538r 0038r		 mov	 ret_real_address,offset ret_real_vcpi
   1836	    07B6  EB 13					 jmp	 avoid_v86_test
   1837							 ASSUME	 DS:txdata
   1838	    07B8				 vcpi_not_present:
   1839
   1840						 ; si no hay VCPI tampoco, comprobamos si estamos en V86
   1841	    07B8  80 3E	0341r 00		 cmp	 system_type,0
   1842	    07BD  75 0C				 jnz	 avoid_v86_test
   1843	    07BF  0F 01	E0			 smsw	 ax
   1844	    07C2  A8 01				 test	 al,1
   1845						 ; si lo estamos salimos con error
   1846	    07C4  BA 0186r			 mov	 dx,offset v86_error_msg
   1847	    07C7  0F 85	05CE			 jnz	 error_handle1
   1848
   1849						 ; si llegamos aki, estamos en RAW / XMS : lo averiguamos
   1850	    07CB				 avoid_v86_test:
   1851	    07CB  B8 4300			 mov	 ax,4300h
   1852	    07CE  CD 2F				 int	 2Fh
   1853	    07D0  3C 80				 cmp	 al,80h
   1854	    07D2  0F 85	0095			 jnz	 no_xms
   1855	    07D6  B8 4310				 mov	 ax,4310h
   1856	    07D9  CD 2F					 int	 2Fh
   1857	    07DB  89 1E	0347r				 mov	 word ptr xms_entry_point,bx
   1858	    07DF  8C 06	0349r				 mov	 word ptr xms_entry_point+2,es
   1859	    07E3  B4 05					 mov	 ah,5
   1860	    07E5  FF 1E	0347r				 call	 dword ptr xms_entry_point
   1861	    07E9  0B C0					 or	 ax,ax
   1862	    07EB  75 0A					 jnz	 a20_ok
   1863	    07ED  3D 0094				 cmp	 ax,94h		 ; already enabled
   1864	    07F0  BA 0165r				 mov	 dx,offset A20_error_msg
   1865	    07F3  0F 85	05A2				 jnz	 error_handle1
   1866	    07F7					 a20_ok:
   1867							 alloc_xms_mem
1  1868	    07F7  B8 0000s			 mov	 ax,txcode32
1  1869	    07FA  8E C0				 mov	 es,ax
1  1870	    07FC  26: 67| C6 05	      +		 mov	 byte ptr es:extended_pointers,0
   1871		  00003249r 00
1  1872	    0805  33 FF				 xor	 di,di
1  1873	    0807				 cont_adding_xms:
1  1874	    0807  B4 08				 mov	 ah,8
1  1875	    0809  32 DB				 xor	 bl,bl
1  1876	    080B  FF 1E	0347r			 call	 dword ptr xms_entry_point
1  1877	    080F  0A DB				 or	 bl,bl
1  1878	    0811  75 55				 jnz	 xms_alloc_done
1  1879	    0813  50				 push	 ax
1  1880	    0814  8B D0				 mov	 dx,ax
1  1881	    0816  B4 09				 mov	 ah,9
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 34
DarkX.ASM



1  1882	    0818  FF 1E	0347r			 call	 dword ptr xms_entry_point
1  1883	    081C  59				 pop	 cx
1  1884	    081D  0B C0				 or	 ax,ax
1  1885	    081F  74 47				 jz	 xms_alloc_done
1  1886	    0821  26: 89 95 356Ar		 mov	 word ptr es:[di+xms_handles],dx
1  1887	    0826  26: 67| FE 05	      +		 inc	 byte ptr es:extended_pointers
   1888		  00003249r
1  1889	    082E  B4 0C				 mov	 ah,0Ch
1  1890	    0830  FF 1E	0347r			 call	 dword ptr xms_entry_point
1  1891	    0834  0B C0				 or	 ax, ax
1  1892	    0836  75 0B				 jnz	 page_is_locked	 ; si no la bloquea, no	la a¤adimos a la heap
1  1893	    0838  26: 67| FE 0D	      +			 dec	 byte ptr es:extended_pointers
   1894		  00003249r
1  1895	    0840  E9 0256				 jmp	 cont_adding
1  1896	    0843				 page_is_locked:
1  1897	    0843  66| C1 E2 10			 shl	 edx,16
1  1898	    0847  8B D3				 mov	 dx,bx
1  1899	    0849  66| 0F B7 C9			 movzx	 ecx,cx
1  1900	    084D  66| C1 E1 0A			 shl	 ecx,10
1  1901	    0851  66| 26: 89 95	324Ar		 mov	 dword ptr es:[di+extended_pointers+1],edx
1  1902	    0857  66| 26: 89 8D	324Er		 mov	 dword ptr es:[di+extended_pointers+1+4],ecx
1  1903	    085D  83 C7	08			 add	 di,8
1  1904	    0860  81 FF	0320			 cmp	 di,8*100
1  1905	    0864  74 02				 je	 xms_alloc_done
1  1906	    0866  EB 9F				 jmp	 cont_adding_xms
1  1907	    0868				 xms_alloc_done:
   1908	    0868  E9 00D5				 jmp	 mem_alloc_done
   1909	    086B				 no_xms:
   1910						 ; activamos la	A20 a mano
   1911	    086B  E8 03A9			 call	 enable_A20
   1912						 ; pillamos extendida con int15h
   1913	    086E  B8 0000s			 mov	 ax,txcode32
   1914	    0871  8E C0				 mov	 es,ax
   1915	    0873  26: 67| C6 05	      +		 mov	 byte ptr es:extended_pointers,0
   1916		  00003249r 00
   1917	    087C  B4 88				 mov	 ah,88h
   1918	    087E  CD 15				 int	 15h
   1919	    0880  66| 0F B7 C0			 movzx	 eax,ax
   1920	    0884  66| 0B C0			 or	 eax,eax
   1921	    0887  0F 84	00B5			 jz	 mem_alloc_done		 ; ¨tenemos extendida?
   1922	    088B  66| C1 E0 0A			 shl	 eax,10	 ; *1024 pq lo queremos	en bytes
   1923						 ASSUME	 ES:txcode32
   1924	    088F  26: 67| FE 05	      +		 inc	 byte ptr es:extended_pointers
   1925		  00003249r
   1926	    0897  66| 26: 67| A3      +		 mov	 dword ptr es:extended_pointers+5,eax
   1927		  0000324Er
   1928						 look_for_extended_beginning
1  1929	    089F  33 C0				 xor	 ax,ax
1  1930	    08A1  8E E0				 mov	 fs,ax
1  1931	    08A3  48				 dec	 ax
1  1932	    08A4  8E E8				 mov	 gs,ax
1  1933	    08A6  64: 8E 26 0066		 mov	 fs,fs:[19h*4+2]
1  1934	    08AB  66| B8 00100000		 mov	 eax,100000h
1  1935	    08B1  66| 64: 81 3E	0012  +		 cmp	 dword ptr fs:[12h],'SIDV'
   1936		  53494456
1  1937	    08BB  75 24				 jnz	 method_2
1  1938	    08BD  66| 64: 8B 16	0016		 mov	 edx,fs:[12h+4]
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 35
DarkX.ASM



1  1939	    08C3  66| C1 E2 08			 shl	 edx,8
1  1940	    08C7  66| C1 EA 08			 shr	 edx,8
1  1941	    08CB  66| 81 FA 0056204B		 cmp	 edx,'V	K'
1  1942	    08D2  75 0D				 jnz	 method_2
1  1943	    08D4  66| 64: A1 002C		 mov	 eax,fs:[2Ch]
1  1944	    08D9  66| C1 E0 08			 shl	 eax,8
1  1945	    08DD  66| C1 E8 08			 shr	 eax,8
1  1946	    08E1				 method_2:
1  1947	    08E1  66| 65: 81 3E	0013  +		 cmp	 dword ptr gs:[16+3],'SIDV'
   1948		  53494456
1  1949	    08EB  75 21				 jnz	 extended_init_found
1  1950	    08ED  65: 80 3E 0017 4B		 cmp	 byte ptr gs:[16+3+4],'K'
1  1951	    08F3  75 19				 jnz	 extended_init_found
1  1952	    08F5  66| 65: 0F B7	16    +		 movzx	 edx,word ptr gs:[16+1Eh]     ;	+16 para el siguiente segmento
   1953		  002E
1  1954	    08FC  66| C1 E2 0A			 shl	 edx,10
1  1955	    0900  66| 81 C2 00100000		 add	 edx,100000h
1  1956	    0907  66| 3B D0			 cmp	 edx,eax
1  1957	    090A  76 02				 jbe	 extended_init_found
1  1958	    090C  66| 92			 xchg	 edx,eax
1  1959	    090E				 extended_init_found:
   1960	    090E  66| 26: 67| A3      +		 mov	 dword ptr es:extended_pointers+1,eax
   1961		  0000324Ar
   1962	    0916  66| 26: 67| 29 05   +		 sub	 dword ptr es:extended_pointers+5,eax	 ; si empieza despu‚s,
   1963		  0000324Er
   1964	    091F  66| 26: 67| 81 05   +		 add	 dword ptr es:extended_pointers+5,100000h; es m s peque¤a
   1965		  0000324Er 00100000
   1966	    092C  66| 26: 67| 83 3D   +		 cmp	 dword ptr es:extended_pointers+5,0	 ; ¨tenemos extendida?
   1967		  0000324Er 00
   1968	    0936  75 08				 jnz	 mem_alloc_done
   1969	    0938  26: 67| FE 0D	      +			 dec	 byte ptr es:extended_pointers	 ; si no, 0 bloques
   1970		  00003249r
   1971
   1972	    0940				 mem_alloc_done:
   1973						 ; inicializamos los datos comunes
   1974	    0940  E8 0198			 call	 init_data
   1975
   1976						 ; si tenemos DPMI, entramos en	protegido aqu¡ (s¢lo inicializaci¢n)
   1977	    0943  B8 0000s			 mov	 ax,txdata
   1978	    0946  8E D8				 mov	 ds,ax
   1979	    0948  A0 0341r			 mov	 al,system_type
   1980	    094B  A8 02				 test	 al,2
   1981	    094D  74 17				 jz	 no_dpmi_init
   1982					 ;		  call	  alloc_dos_mem
   1983	    094F  BB FFFF				 mov	 bx,-1
   1984	    0952  B4 48					 mov	 ah,48h
   1985	    0954  CD 21					 int	 21h	 ; largest DOS memory block for	info exit
   1986	    0956  66| 0F B7 DB				 movzx	 ebx,bx
   1987	    095A  66| C1 E3 04				 shl	 ebx,4
   1988	    095E  66| 89 1E 031Dr			 mov	 dos_mem_size,ebx
   1989	    0963  E9 F8C1				 jmp	 dpmi_init
   1990
   1991	    0966				 no_dpmi_init:
   1992						 ; si tenemos VCPI lo inicializamos
   1993	    0966  A8 01				 test	 al,1
   1994	    0968  74 03				 jz	 get_all_mem	 ; Si es RAW/XMS no hace falta inicializar nada
   1995
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 36
DarkX.ASM



   1996	    096A  E8 F741				 call	 vcpi_init
   1997
   1998	    096D				 get_all_mem :
   1999						 ; int's 50h-57h = irq's para el redireccionamiento
   2000	    096D  33 C0				 xor	 ax,ax
   2001	    096F  8E D8				 mov	 ds,ax
   2002	    0971  8E C0				 mov	 es,ax
   2003	    0973  BF 0140			 mov	 di,50h*4
   2004	    0976  2E: 0F B6 36 0A68r		 movzx	 si,cs:irq_base
   2005	    097C  C1 E6	02			 shl	 si,2
   2006	    097F  B9 0008			 mov	 cx,8
   2007	    0982  FA				 cli
   2008	    0983  F3> 66| A5			 rep	 movsd
   2009						 ; redireccionamos las irqs
   2010	    0986  B4 50				 mov	 ah,50h
   2011	    0988  E8 0451			 call	 irq_redir
   2012						 ; alojamos toda la memoria del	DOS
   2013	    098B  E8 00FB			 call	 alloc_dos_mem
   2014
   2015					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2016					 ; RUTINA DE SALTO A PROTEGIDO PARA TODOS LOS SISTEMAS (MODO REAL)
   2017					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2018	    098E			 set_pm:
   2019	    098E  9C				 pushf
   2020	    098F  FA				 cli
   2021	    0990  68 0000s			 push	 txdata
   2022	    0993  1F				 pop	 ds
   2023	    0994  8F 06	04F2r			 pop	 word ptr real_flags
   2024	    0998  66| A3 04EEr			 mov	 real_eax,eax
   2025					 ;	  mov	  ax,word ptr pm_eflags
   2026					 ;	  and	  ax,1 SHL 9	      ;	IF will	be 1 if	activated in any mode
   2027					 ;	  or	  word ptr real_flags,ax
   2028	    099C  66| 89 1E 04E2r		 mov	 real_ebx,ebx
   2029	    09A1  66| 89 0E 04EAr		 mov	 real_ecx,ecx
   2030	    09A6  66| 89 16 04E6r		 mov	 real_edx,edx
   2031	    09AB  66| 89 36 04D6r		 mov	 real_esi,esi
   2032	    09B0  66| 89 3E 04D2r		 mov	 real_edi,edi
   2033	    09B5  66| 89 2E 04DAr		 mov	 real_ebp,ebp
   2034	    09BA  FF 26	0530r			 jmp	 set_pm_address
   2035
   2036					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2037					 ; RUTINA DE VUELTA A REAL PARA	TODOS LOS SISTEMAS (MODO PROTEGIDO)
   2038					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2039					 ; como	se ejecuta en segmento de 16 bits, hay que evitar prefijos
   2040	    09BE			 ret_real:
   2041	    09BE  66| 9C			 pushfd
   2042	    09C0  66| 8F 06 0524r		 pop	 dword ptr pm_eflags
   2043	    09C5  FA				 cli
   2044	    09C6  8C 16	037Er			 mov	 pm_ss,ss
   2045	    09CA  66| A3 0504r			 mov	 pm_eax,eax
   2046	    09CE  66| 89 1E 0508r		 mov	 pm_ebx,ebx
   2047	    09D3  66| 89 0E 050Cr		 mov	 pm_ecx,ecx
   2048	    09D8  66| 89 16 0510r		 mov	 pm_edx,edx
   2049	    09DD  66| 89 36 0514r		 mov	 pm_esi,esi
   2050	    09E2  66| 89 3E 0518r		 mov	 pm_edi,edi
   2051	    09E7  66| 89 2E 051Cr		 mov	 pm_ebp,ebp
   2052	    09EC  66| 89 26 0520r		 mov	 pm_esp,esp
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 37
DarkX.ASM



   2053	    09F1  FF 26	0538r			 jmp	 ret_real_address
   2054
   2055					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2056					 ; RUTINAS DE SALIDA AL	SISTEMA	OPERATIVO PARA TODOS LOS SISTEMAS (MODO	REAL)
   2057					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2058					 ; Rutina de salida normal
   2059	    09F5			 s16:
   2060	    09F5  FA				 cli
   2061
   2062						 ; reajustamos la pila para modo real
   2063	    09F6  66| B8 00000000s		 mov	 eax,txpila
   2064	    09FC  8E D0				 mov	 ss,ax
   2065	    09FE  66| C1 E0 04			 shl	 eax,4
   2066	    0A02  66| 2B E0			 sub	 esp,eax
   2067
   2068	    0A05				 fin:
   2069	    0A05  B8 0000s			 mov	 ax,txdata
   2070	    0A08  8E D8				 mov	 ds,ax
   2071	    0A0A  F6 06	0341r 01		 test	 system_type,1
   2072	    0A0F  74 13				 jz	 no_vcpi_end
   2073							 ; avisamos al VCPI de que restauramos las irq's
   2074	    0A11  B8 DE0A				 mov	 ax,0DE0Ah
   2075	    0A14  CD 67					 int	 67h
   2076	    0A16  33 DB					 xor	 bx,bx
   2077	    0A18  2E: 8A 1E 0A68r			 mov	 bl,cs:irq_base
   2078	    0A1D  B8 DE0B				 mov	 ax,0DE0Bh
   2079	    0A20  FA					 cli
   2080	    0A21  CD 67					 int	 67h
   2081	    0A23  FB					 sti
   2082
   2083	    0A24				 no_vcpi_end:
   2084	    0A24  2E: 8A 26 0A68r		 mov	 ah,cs:irq_base
   2085	    0A29  E8 03B0			 call	 irq_redir
   2086	    0A2C				 exit_redirless:
   2087	    0A2C  66| 83 3E 0347r 00		 cmp	 dword ptr xms_entry_point,0
   2088	    0A32  74 2E				 jz	 no_xms_allocated
   2089							 free_xms_mem
1  2090	    0A34  B8 0000s			 mov	 ax,txcode32
1  2091	    0A37  8E D8				 mov	 ds,ax
1  2092	    0A39  B8 0000s			 mov	 ax,txdata
1  2093	    0A3C  8E C0				 mov	 es,ax
1  2094	    0A3E  BE 356Ar			 mov	 si,offset xms_handles
1  2095	    0A41  67| 0F B6 0D	      +		 movzx	 cx,byte ptr extended_pointers
   2096		  00003249r
1  2097	    0A49  0B C9				 or	 cx,cx
1  2098	    0A4B  74 15				 jz	 xms_mem_freed
1  2099	    0A4D				 free_xms_blocks:
1  2100	    0A4D  8B 14					 mov	 dx,[si]
1  2101	    0A4F  B4 0D					 mov	 ah,0Dh		 ; UNLOCK block
1  2102	    0A51  26: FF 1E 0347r			 call	 dword ptr es:xms_entry_point
1  2103	    0A56  B4 0A					 mov	 ah,0Ah		 ; FREE	block
1  2104	    0A58  26: FF 1E 0347r			 call	 dword ptr es:xms_entry_point
1  2105	    0A5D  83 C6	08				 add	 si,8
1  2106	    0A60  E2 EB				 loop	 free_xms_blocks
1  2107	    0A62				 xms_mem_freed:
   2108	    0A62				 no_xms_allocated:
   2109	    0A62  FB				 sti		 ; activamos irqs por si hubo excepci¢n	despu‚s	de CLI
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 38
DarkX.ASM



   2110	    0A63  B8 4C00			 mov	 ax,4C00h
   2111	    0A66  CD 21				 int	 21h
   2112
   2113	    0A68  08			 irq_base	 db 8
   2114					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2115
   2116					 ; Rutina de salida por	excepci¢n con informaci¢n de depuraci¢n
   2117	    0A69			 debug_info:
   2118	    0A69  FA				 cli
   2119
   2120	    0A6A  B8 0000s			 mov	 ax,txdata
   2121	    0A6D  8E D8				 mov	 ds,ax
   2122
   2123						 ; reajustamos la pila para modo real
   2124	    0A6F  66| B8 00000000s		 mov	 eax,txpila
   2125	    0A75  8E D0				 mov	 ss,ax
   2126	    0A77  66| C1 E0 04			 shl	 eax,4
   2127	    0A7B  66| 2B E0			 sub	 esp,eax
   2128
   2129	    0A7E  B8 0003			 mov	 ax,3
   2130	    0A81  CD 10				 int	 10h
   2131
   2132	    0A83  BA 06CEr			 mov	 dx,offset debug_info_msg
   2133	    0A86  E9 030A			 jmp	 error_handle
   2134
   2135					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2136					 ; RUTINA DE INICIALIZACION DE DATOS COMUNES A TODOS LOS SISTEMAS (MODO	REAL)
   2137					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2138
   2139	    0A89			 alloc_dos_mem	 proc
   2140
   2141						 ; alojamos la memoria en real por si tenemos un DPMI paginador	de %$#&!
   2142	    0A89  B8 0000s			 mov	 ax,txcode32
   2143	    0A8C  8E D8				 mov	 ds,ax
   2144						 ASSUME	 DS:txcode32
   2145	    0A8E  67| C6 05 00002F20r +		 mov	 byte ptr dos_pointers,0
   2146		  00
   2147	    0A96  BF 2F21r			 mov	 di,offset dos_pointers+1
   2148	    0A99				 cont_adding:
   2149	    0A99  B4 48				 mov	 ah,48h
   2150	    0A9B  BB FFFF			 mov	 bx,0FFFFh
   2151	    0A9E  CD 21				 int	 21h
   2152	    0AA0  83 FB	02			 cmp	 bx,2
   2153	    0AA3  72 32				 jb	 dos_heap_done
   2154	    0AA5  53				 push	 bx
   2155	    0AA6  B4 48				 mov	 ah,48h
   2156	    0AA8  CD 21				 int	 21h
   2157	    0AAA  59				 pop	 cx
   2158	    0AAB  72 2C				 jc	 heap_error
   2159	    0AAD  67| FE 05 00002F20r		 inc	 byte ptr dos_pointers
   2160						 ASSUME	 DS:txdata
   2161	    0AB4  66| 33 DB			 xor	 ebx,ebx
   2162	    0AB7  8B D8				 mov	 bx,ax
   2163	    0AB9  66| C1 E3 04			 shl	 ebx,4
   2164	    0ABD  66| 0F B7 C9			 movzx	 ecx,cx
   2165	    0AC1  66| C1 E1 04			 shl	 ecx,4
   2166	    0AC5  66| 89 1D			 mov	 [di],ebx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 39
DarkX.ASM



   2167	    0AC8  66| 89 4D 04			 mov	 [di+4],ecx
   2168	    0ACC  83 C7	08			 add	 di,8
   2169	    0ACF  81 FF	3241r			 cmp	 di,offset dos_pointers+8*100+1
   2170	    0AD3  74 02				 je	 dos_heap_done
   2171	    0AD5  EB C2				 jmp	 cont_adding
   2172	    0AD7				 dos_heap_done:
   2173	    0AD7  F8				 clc
   2174	    0AD8  C3				 ret
   2175
   2176	    0AD9				 heap_error:
   2177	    0AD9  F9				 stc
   2178	    0ADA  C3				 ret
   2179
   2180	    0ADB			 alloc_dos_mem	 endp
   2181
   2182					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2183
   2184	    0ADB			 init_data	 proc
   2185
   2186						 ; inicializamos el stack frame	para interrupciones reales
   2187	    0ADB  2E: C7 06 04B6r     +		 mov	 cs:stack_frame+2,txpila_real
   2188		  0000s
   2189
   2190	    0AE2  FC				 cld
   2191	    0AE3  B8 0000s			 mov	 ax,txcode32
   2192	    0AE6  8E C0				 mov	 es,ax
   2193	    0AE8  B8 0000s			 mov	 ax,txdata
   2194	    0AEB  8E D8				 mov	 ds,ax
   2195
   2196						 ASSUME	 DS:txdata
   2197	    0AED  F6 06	0341r 02		 test	 system_type,2
   2198	    0AF2  75 4C				 jnz	 no_gen_idt
   2199						 ; GENERAMOS LA	IDT
   2200	    0AF4  B8 0008			 mov	 ax,1 SHL 3	 ; C32_SEL con RAW/XMS y VCPI
   2201	    0AF7  66| C1 E0 10			 shl	 eax,16
   2202						 ASSUME	 DS:txcode32
   2203	    0AFB  B8 2718r			 mov	 ax,offset interrup_redir
   2204	    0AFE  BF 1F18r			 mov	 di,offset idt
   2205	    0B01  32 C9				 xor	 cl,cl
   2206	    0B03  FC				 cld
   2207	    0B04				 gen_idt:
   2208	    0B04  66| AB				 stosd
   2209	    0B06  66| 26: C7 05	      +			 mov	 dword ptr es:[di],8E00h
   2210		  00008E00
   2211	    0B0E  83 C7	04				 add	 di,4
   2212	    0B11  05 0008				 add	 ax,8
   2213	    0B14  FE C9				 dec	 cl
   2214	    0B16  75 EC				 jnz	 gen_idt
   2215
   2216						 ASSUME	 ES:txcode32
   2217	    0B18  B8 001Cr			 mov	 ax,offset tx_int31h
   2218	    0B1B  66| 26: 67| A3      +		 mov	 es:[idt+8*31h],eax
   2219		  000020A0r
   2220	    0B23  B8 0F4Dr			 mov	 ax,offset tx_int21h
   2221	    0B26  66| 26: 67| A3      +		 mov	 es:[idt+8*21h],eax
   2222		  00002020r
   2223
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 40
DarkX.ASM



   2224						 ; fix-up del descriptor del PSP (no necesario bajo DPMI)
   2225						 ASSUME	 DS:txdata
   2226	    0B2E  66| A1 0325r			 mov	 eax,psp_offset
   2227	    0B32  A3 05A6r			 mov	 word ptr psp_desc+2,ax
   2228	    0B35  66| C1 E8 10			 shr	 eax,16
   2229	    0B39  A2 05A8r			 mov	 byte ptr psp_desc+4,al
   2230	    0B3C  88 26	05ABr			 mov	 byte ptr psp_desc+7,ah
   2231
   2232	    0B40				 no_gen_idt:
   2233						 ; preparamos la tabla de redireccionamiento de	interrupciones
   2234	    0B40  BF 2718r			 mov	 di,offset interrup_redir
   2235	    0B43  32 C9				 xor	 cl,cl
   2236	    0B45  66| B8 E900B050		 mov	 eax,0E900B050h		 ; PUSH	EAX , MOV AL,00h , JMP
   2237	    0B4B  66| BB FFFFE27B		 mov	 ebx,offset real_int-offset interrup_redir-8 ; desplazamiento salto
   2238	    0B51				 gen_ints:
   2239	    0B51  66| AB				 stosd
   2240	    0B53  66| 93				 xchg	 ebx,eax
   2241	    0B55  66| AB				 stosd
   2242	    0B57  66| 93				 xchg	 ebx,eax
   2243	    0B59  66| 05 00010000			 add	 eax,10000h	 ; inc.	c¢digo interrupci¢n
   2244	    0B5F  66| 83 EB 08				 sub	 ebx,8		 ; dec.	desp. salto
   2245	    0B63  FE C9				 dec	 cl
   2246	    0B65  75 EA				 jnz	 short gen_ints
   2247						 ; arreglamos las irq's
   2248	    0B67  B8 E0BE			 mov	 ax,offset real_irq-(offset interrup_redir+8*50h)-8
   2249	    0B6A  BF 299Cr			 mov	 di,offset interrup_redir+8*50h+4
   2250	    0B6D  B9 0008			 mov	 cx,8	 ; irqs. bajas
   2251	    0B70				 fix_irqs:
   2252	    0B70  AB					 stosw
   2253	    0B71  66| 83 C7 06				 add	 edi,2+4
   2254	    0B75  2D 0008				 sub	 ax,8
   2255	    0B78  E2 F6				 loop	 fix_irqs
   2256						 ; arreglamos las excepciones
   2257	    0B7A  B8 E3ED			 mov	 ax,offset exceptions-offset interrup_redir-8
   2258	    0B7D  BF 271Cr			 mov	 di,offset interrup_redir+4
   2259	    0B80  AB				 stosw					 ; exc.0
   2260	    0B81  2D 0008			 sub	 ax,8
   2261	    0B84  26: 89 45 06			 mov	 word ptr es:[di-2+8],ax	 ; exc.1
   2262	    0B88  2D 0010			 sub	 ax,8*2
   2263	    0B8B  83 C7	16			 add	 di,3*8-2			 ; exc.3
   2264	    0B8E  B1 0C				 mov	 cl,14-3+1			 ; hasta la 0Eh
   2265	    0B90				 repara_excs:
   2266	    0B90  AB					 stosw
   2267	    0B91  2D 0008				 sub	 ax,8
   2268	    0B94  83 C7	06				 add	 di,8-2
   2269	    0B97  FE C9				 dec	 cl
   2270	    0B99  75 F5				 jnz	 repara_excs
   2271
   2272						 ASSUME	 DS:txdata
   2273						 ; ARREGLAMOS LA GDT
   2274						 ; ponemos la base del descriptor de datos de 16 bits (	txdata )
   2275	    0B9B  66| B8 00000000s		 mov	 eax,txdata
   2276	    0BA1  66| C1 E0 04			 shl	 eax,4
   2277	    0BA5  A3 0586r			 mov	 word ptr d16_desc+2,ax
   2278	    0BA8  66| C1 E8 10			 shr	 eax,16
   2279	    0BAC  A2 0588r			 mov	 byte ptr d16_desc+4,al
   2280
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 41
DarkX.ASM



   2281						 ; base	del de c¢digo de 32 bits
   2282	    0BAF  66| B8 00000000s		 mov	 eax,txcode32
   2283	    0BB5  66| C1 E0 04			 shl	 eax,4
   2284	    0BB9  A3 056Er			 mov	 word ptr code_descriptor+2,ax
   2285	    0BBC  66| C1 E8 10			 shr	 eax,16
   2286	    0BC0  A2 0570r			 mov	 byte ptr code_descriptor+4,al
   2287
   2288						 ; base	del de c¢digo de 16 bits
   2289	    0BC3  66| B8 00000000s		 mov	 eax,txcode
   2290	    0BC9  66| C1 E0 04			 shl	 eax,4
   2291	    0BCD  A3 057Er			 mov	 word ptr c16_desc+2,ax
   2292	    0BD0  66| C1 E8 10			 shr	 eax,16
   2293	    0BD4  A2 0580r			 mov	 byte ptr c16_desc+4,al
   2294
   2295						 ; direcci¢n de	entrada	inicial	en PM
   2296	    0BD7  66| C7 06 0532r     +		 mov	 prot_code_address,offset c32_init
   2297		  00001A63r
   2298
   2299						 ; direcciones de 32 bits de la	IDT y la GDT
   2300	    0BE0  66| B8 00000000s		 mov	 eax,txdata
   2301	    0BE6  66| C1 E0 04			 shl	 eax,4
   2302	    0BEA  66| 05 00000564r		 add	 eax,offset gdt		   ; direcci¢n GDT (32 bits)
   2303	    0BF0  66| A3 053Er			 mov	 gdt_base,eax
   2304
   2305	    0BF4  66| B8 00000000s		 mov	 eax,txcode32
   2306	    0BFA  66| C1 E0 04			 shl	 eax,4
   2307						 ASSUME	 DS:txcode32
   2308	    0BFE  66| 05 00001F18r		 add	 eax,offset idt
   2309						 ASSUME	 DS:txdata
   2310	    0C04  66| A3 0544r			 mov	 idt_base,eax		   ; base de IDT
   2311
   2312						 ; habilitamos el punto	de entrada en RM a la rutina de	interrupci¢n real
   2313						 ASSUME	 DS:txcode
   2314	    0C08  2E: C7 06 0019r     +		 mov	 word ptr cs:saltito+1,offset rm_int
   2315		  0454r
   2316	    0C0F  2E: C7 06 001Br     +		 mov	 word ptr cs:saltito+3,txcode
   2317		  0000s
   2318						 ASSUME	 DS:txdata
   2319
   2320	    0C16  C3				 ret
   2321
   2322	    0C17			 init_data	 endp
   2323					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2324					 ; Rutina de activaci¢n	de la l¡nea A20	por hard
   2325					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2326	    0C17			 enable_A20	 proc		 ; Thanx go to Tran ;D
   2327	    0C17  33 C0				 xor	 ax,ax
   2328	    0C19  8E E0				 mov	 fs,ax
   2329	    0C1B  48				 dec	 ax
   2330	    0C1C  8E E8				 mov	 gs,ax
   2331	    0C1E  E8 003E			 call	 test_A20
   2332	    0C21  74 28				 jz	 A20_enabled
   2333	    0C23  E4 92				 in	 al,92h			      ;	para PS/2
   2334	    0C25  0C 02				 or	 al,2
   2335	    0C27  EB 00				 jmp	 $+2
   2336	    0C29  EB 00				 jmp	 $+2
   2337	    0C2B  EB 00				 jmp	 $+2
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 42
DarkX.ASM



   2338	    0C2D  E6 92				 out	 92h,al
   2339	    0C2F  E8 002D			 call	 test_A20
   2340	    0C32  74 17				 jz	 A20_enabled
   2341	    0C34  E8 0015			 call	 A20_check_state	      ;	para AT
   2342	    0C37  75 47				 jnz	 wait_for_A20
   2343	    0C39  B0 D1				 mov	 al,0d1h
   2344	    0C3B  E6 64				 out	 64h,al
   2345	    0C3D  E8 000C			 call	 A20_check_state
   2346	    0C40  75 3E				 jnz	 wait_for_A20
   2347	    0C42  B0 DF				 mov	 al,0dfh
   2348	    0C44  E6 60				 out	 60h,al
   2349	    0C46  E8 0003			 call	 A20_check_state
   2350	    0C49  EB 35				 jmp	 wait_for_A20
   2351	    0C4B				 A20_enabled:
   2352	    0C4B  C3				 ret
   2353	    0C4C			 enable_A20	 endp
   2354					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2355	    0C4C			 A20_check_state proc
   2356	    0C4C  66| B9 00020000		 mov	 ecx,20000h
   2357	    0C52				 wait_that_state:
   2358	    0C52  EB 00				 jmp	 $+2
   2359	    0C54  EB 00				 jmp	 $+2
   2360	    0C56  EB 00				 jmp	 $+2
   2361	    0C58  E4 64				 in	 al,64h
   2362	    0C5A  A8 02				 test	 al,2
   2363	    0C5C  E0 F4				 loopnz	 wait_that_state
   2364	    0C5E  C3				 ret
   2365	    0C5F			 A20_check_state endp
   2366					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2367	    0C5F			 test_A20	 proc
   2368	    0C5F  64: A0 0000			 mov	 al,fs:[0]
   2369	    0C63  8A E0				 mov	 ah,al
   2370	    0C65  F6 D0				 not	 al
   2371	    0C67  65: FF 36 0010		 push	 word ptr gs:[10h]
   2372	    0C6C  65: A2 0010			 mov	 gs:[10h],al
   2373	    0C70  64: 3A 26 0000		 cmp	 ah,fs:[0]
   2374	    0C75  64: 88 26 0000		 mov	 fs:[0],ah
   2375	    0C7A  65: 8F 06 0010		 pop	 word ptr gs:[10h]
   2376	    0C7F  C3				 ret
   2377	    0C80			 test_A20	 endp
   2378					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2379	    0C80			 wait_for_A20	 proc
   2380	    0C80  B0 36				 mov	 al,36h
   2381	    0C82  E6 43				 out	 43h,al
   2382	    0C84  32 C0				 xor	 al,al
   2383	    0C86  E6 40				 out	 40h,al
   2384	    0C88  E6 40				 out	 40h,al
   2385	    0C8A  B9 0800			 mov	 cx,800h
   2386	    0C8D			 A20_bucle1:
   2387	    0C8D  E8 FFCF			 call	 test_A20
   2388	    0C90  74 B9				 je	 A20_enabled
   2389	    0C92  E4 40				 in	 al,40h
   2390	    0C94  E4 40				 in	 al,40h
   2391	    0C96  8A E0				 mov	 ah,al
   2392	    0C98			 A20_bucle2:
   2393	    0C98  E4 40				 in	 al,40h
   2394	    0C9A  E4 40				 in	 al,40h
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 43
DarkX.ASM



   2395	    0C9C  3A C4				 cmp	 al,ah
   2396	    0C9E  74 F8				 je	 A20_bucle2
   2397	    0CA0  E2 EB				 loop	 A20_bucle1
   2398	    0CA2  BA 0165r			 mov	 dx,offset A20_error_msg
   2399	    0CA5  E9 00F1			 jmp	 error_handle1
   2400	    0CA8			 wait_for_A20	 endp
   2401					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2402					 ; Procedimiento de identificaci¢n de la CPU
   2403					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2404	    0CA8			 cpuid	 proc
   2405					 ; OUTPUT -> CF	set if no 386 or better	detected
   2406					 ;	     CF	clear if 386 or	better detected
   2407					 ;		 if CPUID supported
   2408					 ;			 AX = code returned by CPUID if	supported
   2409					 ;			      (	AH = 5 if Pentium , ...	)
   2410					 ;		 if CPUID not supported
   2411					 ;			 AH = cpu family
   2412					 ;				 03h = 386
   2413					 ;				 04h = 486
   2414					 ;			 AL = 0
   2415	    0CA8  66| 9C			 pushfd
   2416	    0CAA  FA				 cli	 ; no queremos ninguna irq por si acaso
   2417						 ; comprobamos si tenemos un 386 como m¡nimo
   2418	    0CAB  32 E4				 xor	 ah,ah
   2419	    0CAD  50				 push	 ax
   2420	    0CAE  9D				 popf
   2421	    0CAF  9C				 pushf
   2422	    0CB0  58				 pop	 ax
   2423	    0CB1  80 E4	F0			 and	 ah,0f0h
   2424	    0CB4  80 FC	F0			 cmp	 ah,0f0h
   2425	    0CB7  74 7A	90 90			 jz	 no_386
   2426	    0CBB  B4 F0				 mov	 ah,0f0h
   2427	    0CBD  50				 push	 ax
   2428	    0CBE  9D				 popf
   2429	    0CBF  9C				 pushf
   2430	    0CC0  58				 pop	 ax
   2431	    0CC1  80 E4	F0			 and	 ah,0f0h
   2432	    0CC4  74 6D				 jz	 no_386
   2433	    0CC6  B8 0300			 mov	 ax,300h	 ; 386 por el momento
   2434						 ; comprobamos tenemos 486
   2435	    0CC9  66| 8B CC			 mov	 ecx,esp
   2436	    0CCC  66| 83 E4 FC			 and	 esp,0FFFFFFFCh	 ; as¡ evitamos	un AC fault en el 486
   2437	    0CD0  66| 9C			 pushfd
   2438	    0CD2  66| 5B			 pop	 ebx
   2439	    0CD4  66| 8B D3			 mov	 edx,ebx
   2440	    0CD7  66| 81 E2 00040000		 and	 edx,40000h
   2441	    0CDE  66| 81 F3 00040000		 xor	 ebx,40000h	 ; cambiamos el	bit de AC
   2442	    0CE5  66| 53			 push	 ebx
   2443	    0CE7  66| 9D			 popfd
   2444	    0CE9  66| 9C			 pushfd
   2445	    0CEB  66| 5B			 pop	 ebx
   2446	    0CED  66| 81 E3 00040000		 and	 ebx,40000h
   2447	    0CF4  66| 8B E1			 mov	 esp,ecx
   2448	    0CF7  66| 3B DA			 cmp	 ebx,edx
   2449	    0CFA  74 33				 je	 id_done
   2450	    0CFC  FE C4				 inc	 ah		 ; de momento, tenemos un 486
   2451	    0CFE  66| 9C			 pushfd
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 44
DarkX.ASM



   2452	    0D00  66| 5B			 pop	 ebx
   2453	    0D02  66| 8B D3			 mov	 edx,ebx
   2454	    0D05  66| 81 F3 00200000		 xor	 ebx,200000h
   2455	    0D0C  66| 53			 push	 ebx
   2456	    0D0E  66| 9D			 popfd
   2457	    0D10  66| 9C			 pushfd
   2458	    0D12  66| 5B			 pop	 ebx
   2459	    0D14  66| 81 E3 00200000		 and	 ebx,200000h
   2460	    0D1B  66| 81 E2 00200000		 and	 edx,200000h
   2461	    0D22  66| 3B DA			 cmp	 ebx,edx
   2462	    0D25  74 08				 je	 id_done
   2463
   2464						 ; tiene CPUID (puede ser 486)
   2465	    0D27  66| B8 00000001		 mov	 eax,1
   2466	    0D2D  0F A2				 db	 0fh,0a2h
   2467	    0D2F				 id_done:
   2468	    0D2F  66| 9D			 popfd
   2469	    0D31  F8				 clc
   2470	    0D32  C3				 ret
   2471
   2472	    0D33			 no_386:
   2473	    0D33  66| 9D			 popfd
   2474	    0D35  F9				 stc
   2475	    0D36  C3				 ret
   2476
   2477	    0D37			 cpuid	 endp
   2478					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2479					 ; Procedimiento de identificaci¢n de la FPU
   2480					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2481	    0D37			 fpuid	 proc	 ; inspired on CPUID32.ASM by ??? ;)
   2482					 ; OUTPUT -> AL	= FPU type ( 00h = no present ;	02h = 287 ; 03h	= 387 ;	04h = 487+ )
   2483	    0D37  32 C0				 xor	 al,al
   2484	    0D39  DB E3				 fninit				 ; reseteamos el estado	de la FPU
   2485	    0D3B  2E: C7 06 0D91r 5A5A		 mov	 cs:fpu_status,5A5Ah
   2486	    0D42  2E: DD 3E 0D91r		 fnstsw	 cs:fpu_status		 ; comprobamos el estado
   2487	    0D47  2E: 80 3E 0D91r 00		 cmp	 byte ptr cs:fpu_status,0
   2488	    0D4D  75 41				 jne	 fpu_found		 ; any FPU on system :(
   2489	    0D4F  2E: D9 3E 0D91r		 fnstcw	 cs:fpu_status		 ; miramos el control word
   2490	    0D54  2E: 8B 1E 0D91r		 mov	 bx,cs:fpu_status
   2491	    0D59  81 E3	103F			 and	 bx,103fh
   2492	    0D5D  80 FB	3F			 cmp	 bl,3Fh
   2493	    0D60  75 2E				 jne	 fpu_found		 ; no FPU <:'(
   2494						 ; Si llegamos aqu¡, hay FPU
   2495						 ; 486+	-> 487 compatible
   2496						 ; 386	-> 287 o 387: lo averiguamos
   2497	    0D62  B8 0000s			 mov	 ax,txdata
   2498	    0D65  8E D8				 mov	 ds,ax
   2499	    0D67  A1 033Fr			 mov	 ax,cpu_info
   2500	    0D6A  80 FC	04			 cmp	 ah,4
   2501	    0D6D  72 04				 jb	 no_487
   2502	    0D6F  B0 04					 mov	 al,4
   2503	    0D71  EB 1D					 jmp	 fpu_found
   2504	    0D73				 no_487:
   2505						 ; para	saber si es 287	o 387 miramos 'infinity'
   2506	    0D73  D9 E8				 fld1
   2507	    0D75  D9 EE				 fldz
   2508	    0D77  DE F9				 fdiv			 ; tenemos +infinito
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 45
DarkX.ASM



   2509	    0D79  D9 C0				 fld	 st
   2510	    0D7B  D9 E0				 fchs			 ; formamos -infinito
   2511	    0D7D  DE D9				 fcompp			 ; si nos dice que +inf.=-inf.,	es un 287
   2512	    0D7F  9B 2E: DD 3E 0D91r		 fstsw	 cs:fpu_status	 ; necesitamos los flags
   2513	    0D85  2E: A1 0D91r			 mov	 ax,cs:fpu_status
   2514	    0D89  B0 02				 mov	 al,2
   2515	    0D8B  9E				 sahf
   2516	    0D8C  74 02				 jz	 fpu_found	 ; si son iguales, 287
   2517	    0D8E  FE C0				 inc	 al		 ; si no, 387
   2518	    0D90				 fpu_found:
   2519	    0D90  C3				 ret
   2520	    0D91  ????			 fpu_status	 dw ?
   2521	    0D93			 fpuid	 endp
   2522					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2523					 ; RUTINAS GENERALES DE	GESTION	PARA TODOS LOS SISTEMAS	(MODO REAL)
   2524					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2525
   2526	    0D93			 error_handle:
   2527	    0D93  E8 0009			 call	 printf
   2528	    0D96  E9 FC6C			 jmp	 fin
   2529
   2530	    0D99			 error_handle1:
   2531	    0D99  E8 0003			 call	 printf
   2532	    0D9C  E9 FC8D			 jmp	 exit_redirless
   2533
   2534					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2535
   2536	    0D9F			 printf	 proc
   2537
   2538	    0D9F  B8 0000s			 mov	 ax,txdata
   2539	    0DA2  8E D8				 mov	 ds,ax
   2540	    0DA4  B4 09				 mov	 ah,9
   2541	    0DA6  CD 21				 int	 21h
   2542	    0DA8  C3				 ret
   2543
   2544	    0DA9			 printf	 endp
   2545
   2546					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2547
   2548	    0DA9			 init_mem	 proc
   2549
   2550						 ; cambiamos el	tama¤o del bloque reservado para nuestro programa
   2551	    0DA9  66| BB 00000000s		 mov	 ebx,disk
   2552	    0DAF  66| 81 EB 00000000s		 sub	 ebx,txdata
   2553	    0DB6  66| C1 E3 04			 shl	 ebx,4
   2554	    0DBA  66| 81 C3 00008000		 add	 ebx,size disk_buffer
   2555	    0DC1  66| C1 EB 04			 shr	 ebx,4
   2556	    0DC5  83 C3	11			 add	 bx,11h	 ; redondeamos sumando un p rrafo + 16
   2557						 ASSUME	 DS:txdata
   2558	    0DC8  A1 04D0r			 mov	 ax,psp_seg
   2559	    0DCB  8E C0				 mov	 es,ax
   2560	    0DCD  B4 4A				 mov	 ah,4Ah
   2561	    0DCF  CD 21				 int	 21h
   2562	    0DD1  C3				 ret
   2563
   2564	    0DD2			 init_mem	 endp
   2565
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 46
DarkX.ASM



   2566					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2567
   2568	    0DD2			 get_dos_mem	 proc
   2569
   2570	    0DD2  B4 48				 mov	 ah,48h
   2571	    0DD4  CD 21				 int	 21h
   2572	    0DD6  BA 04AAr			 mov	 dx,offset not_enough_mem
   2573					 ;	  pop	  ecx	  ; si salimos,	la pila	estar  limpia
   2574	    0DD9  72 B8				 jc	 error_handle
   2575					 ;	  push	  ecx
   2576	    0DDB  C3				 ret
   2577
   2578	    0DDC			 get_dos_mem	 endp
   2579
   2580					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2581
   2582	    0DDC			 irq_redir	 proc
   2583					 ; INPUT -> AH = base de IRQ's 0-7
   2584
   2585	    0DDC  FA				 cli
   2586
   2587						 ; enmascaramos	todas las irq's
   2588	    0DDD  B0 FF				 mov	 al,0FFh
   2589	    0DDF  E6 21				 out	 21h,al
   2590	    0DE1  EB 00				 jmp	 short $+2	 ; delay
   2591
   2592	    0DE3  B0 11				 mov	 al,10001b	 ; level, master, ICW4 on
   2593	    0DE5  E6 20				 out	 20h,al		 ; ICW1
   2594	    0DE7  EB 00				 jmp	 short $+2
   2595
   2596	    0DE9  8A C4				 mov	 al,ah		 ; INT AH = nueva base de irq's
   2597	    0DEB  E6 21				 out	 21h,al		 ; ICW2
   2598	    0DED  EB 00				 jmp	 short $+2
   2599
   2600	    0DEF  B0 04				 mov	 al,4		 ; pq estamos en un AT
   2601	    0DF1  E6 21				 out	 21h,al		 ; ICW3
   2602	    0DF3  EB 00				 jmp	 short $+2
   2603
   2604	    0DF5  B0 01				 mov	 al,1		 ; modo	8086, EOI normal
   2605	    0DF7  E6 21				 out	 21h,al		 ; ICW4
   2606	    0DF9  EB 00				 jmp	 short $+2
   2607
   2608	    0DFB  32 C0				 xor	 al,al		 ; desenmascaramos las irq's
   2609	    0DFD  E6 21				 out	 21h,al
   2610
   2611	    0DFF  FB				 sti
   2612
   2613	    0E00  C3				 ret
   2614
   2615	    0E01			 irq_redir	 endp
   2616
   2617					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2618	    0E01			 TXCODE	 ENDS
   2619
   2620					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   2621					 ; SEGMENTO DE CODIGO DE 32 BITS ( 'ENTRY POINT' AL PROGRAMA )
   2622					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 47
DarkX.ASM



   2623
   2624	00000000			 TXCODE32  SEGMENT PARA	USE32 'CODE32'
   2625					 ASSUME	   CS:txcode32,SS:txpila,DS:txdata
   2626
   2627					 ; ponemos los selectores en el	segmento de c¢digo para	referenciar con	CS
   2628	00000000  0008 0000		 C32_SEL		 dw 1 SHL 3,0
   2629	00000004  0010 0000		 D32_SEL		 dw 2 SHL 3,0
   2630	00000008  0018 0000		 C16_SEL		 dw 3 SHL 3,0
   2631	0000000C  0020 0000		 D16_SEL		 dw 4 SHL 3,0
   2632	00000010  0028 0000		 CODE_SEL		 dw 5 SHL 3,0
   2633	00000014  0030 0000		 DATA_SEL		 dw 6 SHL 3,0
   2634	00000018  0038 0000		 ENVRN_SEL		 dw 7 SHL 3,0
   2635
   2636					 INCLUDE		 dpmisup.inc
1  2637					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2638					 ; Standard DPMI 0.9 INT 31h support routines
1  2639					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2640	0000001C			 tx_int31h:
1  2641						 ; TX32	OEM functions
1  2642	0000001C  66| 3D 3200			 cmp	 ax,3200h	 ; get system information
1  2643	00000020  0F 84	000008C9		 jz	 get_sys_info
1  2644	00000026  66| 3D 3201			 cmp	 ax,3201h	 ; get program information
1  2645	0000002A  0F 84	00000904		 jz	 get_program_info
1  2646
1  2647						 ; for DOS32 compatibility
1  2648	00000030  66| 3D EE00			 cmp	 ax,0EE00h
1  2649	00000034  0F 84	00000951		 jz	 dos32_info	 ; get DOS32 version
1  2650	0000003A  66| 3D EE02			 cmp	 ax,0EE02h
1  2651	0000003E  0F 84	00000920		 jz	 dos32_sys_info	 ; get DOS32 address information
1  2652
1  2653	00000044  1E				 push	 ds
1  2654	00000045  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2655						 ASSUME	 DS:txdata
1  2656	0000004C  67| F6 06 0341r 02		 test	 system_type,2
1  2657	00000052  1F				 pop	 ds
1  2658	00000053  0F 85	000000DD		 jnz	 dpmi_handles_standard_funcs
1  2659
1  2660	00000059  66| 3D 0500			 cmp	 ax,500h
1  2661	0000005D  0F 84	00000358		 jz	 ext_mem_info	 ; get free memory info
1  2662	00000063  66| 3D 0501			 cmp	 ax,501h
1  2663	00000067  0F 84	00000397		 jz	 ext_mem_alloc	 ; allocate memory block
1  2664	0000006D  66| 3D 0502			 cmp	 ax,502h
1  2665	00000071  0F 84	000003E0		 jz	 ext_mem_free	 ; free	memory block
1  2666	00000077  66| 3D 0503			 cmp	 ax,503h
1  2667	0000007B  0F 84	0000040E		 jz	 ext_mem_resize	 ; resize memory block
1  2668
1  2669	00000081  66| 3D 0100			 cmp	 ax,100h
1  2670	00000085  0F 84	00000230		 jz	 dos_mem_alloc	 ; allocate DOS	memory
1  2671	0000008B  66| 3D 0101			 cmp	 ax,101h
1  2672	0000008F  0F 84	0000028A		 jz	 dos_mem_free	 ; free	DOS memory block
1  2673	00000095  66| 3D 0102			 cmp	 ax,102h
1  2674	00000099  0F 84	000002BF		 jz	 dos_mem_resize	 ; resize DOS memory block
1  2675
1  2676	0000009F  66| 3D 0200			 cmp	 ax,200h	 ; get real mode interrupt vector
1  2677	000000A3  0F 84	000007E6		 jz	 get_rm_int_vec
1  2678	000000A9  66| 3D 0201			 cmp	 ax,201h
1  2679	000000AD  0F 84	0000080D		 jz	 set_rm_int_vec	 ; set real mode interrupt vector
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 48
DarkX.ASM



1  2680
1  2681	000000B3  66| 3D 0300			 cmp	 ax,300h
1  2682	000000B7  0F 84	00000087		 jz	 make_rm_int	 ; simulate RM interrupt
1  2683	000000BD  66| 3D 0301			 cmp	 ax,301h
1  2684	000000C1  0F 84	0000007D		 jz	 make_rm_int	 ; RM call with	FAR RET	frame
1  2685	000000C7  66| 3D 0302			 cmp	 ax,302h
1  2686	000000CB  74 77				 jz	 make_rm_int	 ; RM call with	IRET frame
1  2687
1  2688	000000CD  66| 3D 0303			 cmp	 ax,303h
1  2689	000000D1  0F 84	000006FB		 jz	 callback_alloc	 ; allocate real mode call-back	address
1  2690	000000D7  66| 3D 0304			 cmp	 ax,304h
1  2691	000000DB  0F 84	00000766		 jz	 callback_free	 ; free	real mode call-back address
1  2692
1  2693	000000E1  66| 3D 0204			 cmp	 ax,204h
1  2694	000000E5  0F 84	0000054A		 jz	 get_int_vector
1  2695	000000EB  66| 3D 0205			 cmp	 ax,205h
1  2696	000000EF  0F 84	00000586		 jz	 set_int_vector
1  2697
1  2698	000000F5  66| 0B C0			 or	 ax,ax
1  2699	000000F8  0F 84	000003F5		 jz	 alloc_desc	 ; allocate LDT	descriptors
1  2700	000000FE  66| 3D 0001			 cmp	 ax,1
1  2701	00000102  0F 84	00000468		 jz	 free_desc	 ; free	LDT descriptor
1  2702	00000108  66| 3D 0003			 cmp	 ax,3
1  2703	0000010C  0F 84	0000048C		 jz	 next_desc	 ; get next selector increment value
1  2704	00000112  66| 3D 000C			 cmp	 ax,0Ch
1  2705	00000116  0F 84	0000048C		 jz	 set_desc	 ; set descriptor
1  2706	0000011C  66| 3D 0006			 cmp	 ax,6
1  2707	00000120  0F 84	000004C7		 jz	 get_seg_base	 ; get segment base
1  2708
1  2709	00000126  66| 3D 0800			 cmp	 ax,0800h
1  2710	0000012A  0F 84	00000593		 jz	 map_memory
1  2711
1  2712						 ; si no es una	funci¢n	soportada, salimos con CF = 1
1  2713	00000130  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2714	00000135  CF				 iretd
1  2715
1  2716	00000136				 dpmi_handles_standard_funcs:
1  2717	00000136  9C				 pushfd
1  2718	00000137  2E: FF 1D 0000203Er		 call	 fword ptr cs:[idt+31h*6]
1  2719	0000013E  9C				 pushfd
1  2720	0000013F  8F 44	24 08			 pop	 dword ptr ss:[esp+4*2]	 ; ponemos los flags devueltos
1  2721	00000143  CF				 iretd
1  2722
1  2723					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2724					 ; Real	Mode Services for Interrupt and	Far Call execution
1  2725					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2726	00000144			 make_rm_int:
1  2727	00000144  60				 pushad
1  2728	00000145  06 57				 push	 es edi
1  2729	00000147  66| 8C DA			 mov	 dx,ds
1  2730	0000014A  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2731	00000151  66| 67| 8C 06	0378r		 mov	 pm_es,es
1  2732	00000157  66| 67| 8C 26	037Ar		 mov	 pm_fs,fs
1  2733	0000015D  66| 67| 8C 2E	037Cr		 mov	 pm_gs,gs
1  2734	00000163  66| 67| 89 16	0376r		 mov	 pm_ds,dx
1  2735						 ; copiamos en pila el n£mero de WORDS indicados por CX
1  2736	00000169  66| 0B C9			 or	 cx,cx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 49
DarkX.ASM



1  2737	0000016C  74 4E				 jz	 no_stack_parameters
1  2738	0000016E  8B F4				 mov	 esi,esp
1  2739	00000170  83 C6	34			 add	 esi,13*4	 ; justo antes del CS:EIP, EFLAGS, ...
1  2740	00000173  0F B7	C9			 movzx	 ecx,cx
1  2741	00000176  16				 push	 ss
1  2742	00000177  1F				 pop	 ds
1  2743						 ; ajustamos el	puntero	a la pila real
1  2744	00000178  26: 8B 57 2E			 mov	 edx,dword ptr es:[edi+2Eh]
1  2745	0000017C  0B D2				 or	 edx,edx
1  2746	0000017E  75 0B				 jnz	 no_default_stack
1  2747	00000180  66| BA 0000s				 mov	 dx,txpila_real
1  2748	00000184  C1 E2	10				 shl	 edx,16
1  2749	00000187  66| BA 4000				 mov	 dx,size txpr
1  2750	0000018B				 no_default_stack:
1  2751	0000018B  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  2752						 ; guardamos el	n£mero de BYTES	en pila
1  2753	00000192  BD 00000000s			 mov	 ebp,txcode
1  2754	00000197  C1 E5	04			 shl	 ebp,4
1  2755						 ASSUME	 ES:txcode
1  2756	0000019A  D1 E1				 shl	 ecx,1
1  2757	0000019C  66| 26: 89 8D	      +		 mov	 word ptr es:[ebp+bytes_in_stack],cx
   2758		  000004B8r
1  2759						 ; calculamos el offset	lineal de la pila real
1  2760	000001A4  33 FF				 xor	 edi,edi
1  2761	000001A6  66| 8B FA			 mov	 di,dx
1  2762	000001A9  81 E2	FFFF0000		 and	 edx,0FFFF0000h
1  2763	000001AF  C1 EA	0C			 shr	 edx,16-4
1  2764	000001B2  03 FA				 add	 edi,edx
1  2765	000001B4  2B F9				 sub	 edi,ecx
1  2766						 ; lo copiamos todo
1  2767	000001B6  D1 E9				 shr	 ecx,1
1  2768	000001B8  FC				 cld
1  2769	000001B9  F3> 66| A5			 rep	 movsw
1  2770
1  2771	000001BC				 no_stack_parameters:
1  2772						 ; copiamos la estructura del DPMI
1  2773						 ; (as¡	no tiene pq estar en el	primer Mb)
1  2774	000001BC  5E				 pop	 esi
1  2775	000001BD  1F				 pop	 ds
1  2776	000001BE  1E				 push	 ds
1  2777	000001BF  56				 push	 esi
1  2778	000001C0  BF 000003BFr			 mov	 edi,offset dpmi_rm_call_struc
1  2779	000001C5  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  2780	000001CC  B9 00000019			 mov	 ecx,32h/2
1  2781	000001D1  FC				 cld
1  2782	000001D2  F3> 66| A5			 rep	 movsw
1  2783						 ; corregimos el salto a real
1  2784	000001D5  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2785	000001DC  BF 00000000s			 mov	 edi,txcode
1  2786	000001E1  C1 E7	04			 shl	 edi,4
1  2787						 ASSUME	 DS:txcode
1  2788	000001E4  66| C7 87 00000019r +		 mov	 word ptr ds:[edi+saltito+1],offset dpmi_rm_int
   2789		  039Ar
1  2790						 ; corregimos el salto de vuelta a protegido
1  2791						 ASSUME	 ES:txdata
1  2792	000001ED  26: 67| C7 06	0532r +		 mov	 es:prot_code_address,offset back_from_dpmi_int
   2793		  00000212r
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 50
DarkX.ASM



1  2794
1  2795	000001F7  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2796	000001FE  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  2797	00000205  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  2798						 pushd	 ret_real
2  2799	0000020C  68				 db 68h
2  2800	0000020D  09BEr	0000			 dw offset ret_real,0
1  2801	00000211  CB				 retf
1  2802
1  2803	00000212				 back_from_dpmi_int:
1  2804	00000212  FA				 cli
1  2805						 ; restauramos el salto	a real
1  2806	00000213  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2807	0000021A  BB 00000000s			 mov	 ebx,txcode
1  2808	0000021F  C1 E3	04			 shl	 ebx,4
1  2809	00000222  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset rm_int
   2810		  0454r
1  2811
1  2812						 ; copiamos los	valores	de la pila real
1  2813						 ASSUME	 DS:txdata
1  2814	0000022B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2815	00000232  67| 8B 3E 0520r		 mov	 edi,pm_esp
1  2816	00000237  83 C7	34			 add	 edi,13*4	 ; POP ES,POP EDI,POPAD,POP EIP,POP CS,POPFD
1  2817	0000023A  67| 8E 06 037Er		 mov	 es,pm_ss
1  2818						 ASSUME	 DS:txcode
1  2819	0000023F  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2820	00000246  BE 00000000s			 mov	 esi,txcode
1  2821	0000024B  C1 E6	04			 shl	 esi,4
1  2822	0000024E  33 C9				 xor	 ecx,ecx
1  2823	00000250  66| 8B 8E 000004B8r		 mov	 cx,[esi+bytes_in_stack]
1  2824	00000257  66| 0B C9			 or	 cx,cx
1  2825	0000025A  74 1F				 jz	 no_return_vals
1  2826	0000025C  66| C7 86 000004B8r +		 mov	 [esi+bytes_in_stack],0
   2827		  0000
1  2828	00000265  BE 00000000s			 mov	 esi,txpila_real
1  2829	0000026A  C1 E6	04			 shl	 esi,4
1  2830	0000026D  81 C6	00004000		 add	 esi,size txpr
1  2831	00000273  2B F1				 sub	 esi,ecx
1  2832	00000275  D1 E9				 shr	 ecx,1
1  2833	00000277  FC				 cld
1  2834	00000278  F3> 66| A5			 rep	 movsw
1  2835						 ASSUME	 DS:txdata
1  2836
1  2837	0000027B				 no_return_vals:
1  2838						 ; volvemos a poner bien la direcci¢n de retorno a protegido
1  2839	0000027B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  2840						 ASSUME	 DS:txdata
1  2841	00000282  67| C7 06 0532r     +		 mov	 prot_code_address,offset pm_ret_point
   2842		  00000A0Br
1  2843						 ; copiamos todos los valores obtenidos	en la estructura
1  2844	0000028B  67| 8E 16 037Er		 mov	 ss,pm_ss
1  2845	00000290  67| 8B 26 0520r		 mov	 esp,pm_esp
1  2846	00000295  5F 07				 pop	 edi es
1  2847	00000297  BE 000004D2r			 mov	 esi,offset rm_regs_struc
1  2848	0000029C  B9 00000019			 mov	 ecx,32h/2
1  2849	000002A1  FC				 cld
1  2850	000002A2  F3> 66| A5			 rep	 movsw
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 51
DarkX.ASM



1  2851						 ; restauramos los registros
1  2852	000002A5  61				 popad
1  2853						 ; restauramos los selectores de protegido
1  2854	000002A6  67| 8E 06 0378r		 mov	 es,pm_es
1  2855	000002AB  67| 8E 26 037Ar		 mov	 fs,pm_fs
1  2856	000002B0  67| 8E 2E 037Cr		 mov	 gs,pm_gs
1  2857	000002B5  67| 8E 1E 0376r		 mov	 ds,pm_ds
1  2858	000002BA  CF				 iretd
1  2859
1  2860					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2861					 ; DOS Memory Management Services
1  2862					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2863					 ASSUME	 DS:txcode32
1  2864	000002BB			 dos_mem_alloc:
1  2865	000002BB  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1	 ; CF =	1 por si hay error
1  2866	000002C0  1E 53	51			 push	 ds ebx	ecx
1  2867	000002C3  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2868	000002CA  B8 00000000s			 mov	 eax,txcode32
1  2869	000002CF  C1 E0	04			 shl	 eax,4
1  2870	000002D2  80 B8	00002F20r 00		 cmp	 byte ptr [eax+dos_pointers],0
1  2871	000002D9  74 3A				 jz	 no_dos_heap_error
1  2872	000002DB  05 00002F18r			 add	 eax,offset dos_heap_info
1  2873	000002E0  0F B7	CB			 movzx	 ecx,bx
1  2874	000002E3  C1 E1	04			 shl	 ecx,4
1  2875	000002E6  50				 push	 eax
1  2876	000002E7  E8 00000FB3			 call	 malloc
1  2877	000002EC  58				 pop	 eax
1  2878	000002ED  0B DB				 or	 ebx,ebx
1  2879	000002EF  74 10				 jz	 dos_alloc_error
1  2880	000002F1  8B C3				 mov	 eax,ebx
1  2881	000002F3  C1 E8	04			 shr	 eax,4	 ; estar  alineada a p rrafo pq	lo est 	toda la	heap
1  2882	000002F6  8B D0				 mov	 edx,eax ; selector = segmento para handling posterior
1  2883	000002F8  59 5B	1F			 pop	 ecx ebx ds
1  2884	000002FB  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh ; CF = 0 pq	no hay error
1  2885	00000300  CF				 iretd
1  2886	00000301			 dos_alloc_error:
1  2887						 ; buscamos el bloque m s grande memoria para devolverlo en BX
1  2888	00000301  E8 00001187			 call	 getmeminfo
1  2889	00000306  8B D8				 mov	 ebx,eax
1  2890	00000308  C1 EB	04			 shr	 ebx,4
1  2891	0000030B  66| B8 0008			 mov	 ax,8			 ; error code =	not enough memory
1  2892	0000030F  59				 pop	 ecx
1  2893	00000310  83 C4	04			 add	 esp,4
1  2894	00000313  1F				 pop	 ds
1  2895					 ;	  or	  byte ptr ss:[esp+4*2],1 ; CF = 1 por si error
1  2896	00000314  CF				 iretd
1  2897	00000315			 no_dos_heap_error:
1  2898	00000315  59 5B	1F			 pop	 ecx ebx ds
1  2899	00000318  66| B8 0008			 mov	 ax,8			 ; error 8 = not enough	memory
1  2900	0000031C  33 DB				 xor	 ebx,ebx		 ; 0 paragraphs	available
1  2901	0000031E  CF				 iretd
1  2902					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2903	0000031F			 dos_mem_free:
1  2904	0000031F  1E 50	53 51			 push	 ds eax	ebx ecx
1  2905	00000323  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2906	0000032A  BB 00000000s			 mov	 ebx,txcode32
1  2907	0000032F  C1 E3	04			 shl	 ebx,4
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 52
DarkX.ASM



1  2908	00000332  80 BB	00002F20r 00		 cmp	 byte ptr [ebx+dos_pointers],0
1  2909	00000339  74 15				 jz	 no_dos_heap_error1
1  2910	0000033B  0F B7	DA			 movzx	 ebx,dx
1  2911	0000033E  C1 E3	04			 shl	 ebx,4
1  2912	00000341  E8 00000FB2			 call	 free
1  2913	00000346  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2914	0000034A  80 64	24 08 FC		 and	 byte ptr ss:[esp+4*2],0FCh
1  2915	0000034F  CF				 iretd
1  2916	00000350			 no_dos_heap_error1:
1  2917	00000350  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2918	00000354  66| B8 0009			 mov	 ax,9			 ; error 9 = invalid block segment
1  2919	00000358  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2920	0000035D  CF				 iretd
1  2921					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2922	0000035E			 dos_mem_resize:
1  2923	0000035E  1E 50	51 52			 push	 ds eax	ecx edx
1  2924	00000362  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2925	00000369  B8 00000000s			 mov	 eax,txcode32
1  2926	0000036E  C1 E0	04			 shl	 eax,4
1  2927	00000371  80 B8	00002F20r 00		 cmp	 byte ptr [eax+dos_pointers],0
1  2928	00000378  74 33				 jz	 no_dos_heap_error2
1  2929	0000037A  05 00002F18r			 add	 eax,offset dos_heap_info
1  2930	0000037F  0F B7	CB			 movzx	 ecx,bx
1  2931	00000382  C1 E1	04			 shl	 ecx,4
1  2932	00000385  0F B7	DA			 movzx	 ebx,dx
1  2933	00000388  C1 E3	04			 shl	 ebx,4
1  2934	0000038B  50 56	57			 push	 eax esi edi
1  2935	0000038E  E8 00000FCC			 call	 realloc
1  2936	00000393  5F 5E	58 5A			 pop	 edi esi eax edx
1  2937	00000397  0B DB				 or	 ebx,ebx
1  2938	00000399  0F 84	FFFFFF62		 jz	 dos_alloc_error
1  2939	0000039F  C1 EB	04			 shr	 ebx,4
1  2940	000003A2  8B D3				 mov	 edx,ebx
1  2941	000003A4  59 58	1F			 pop	 ecx eax ds
1  2942	000003A7  80 64	24 08 FC		 and	 byte ptr ss:[esp+4*2],0FCh
1  2943	000003AC  CF				 iretd
1  2944	000003AD			 no_dos_heap_error2:
1  2945	000003AD  5A 59	58 1F			 pop	 edx ecx eax ds
1  2946	000003B1  66| B8 0009			 mov	 ax,9			 ; error 9 = invalid block segment
1  2947	000003B5  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2948	000003BA  CF				 iretd
1  2949
1  2950					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2951					 ; Extended Memory Management Services
1  2952					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2953	000003BB			 ext_mem_info:
1  2954	000003BB  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  2955	000003C0  1E 50	53 51 57		 push	 ds eax	ebx ecx	edi
1  2956	000003C5  33 C0				 xor	 eax,eax
1  2957	000003C7  48				 dec	 eax
1  2958	000003C8  B9 0000000C			 mov	 ecx,30h/4
1  2959	000003CD  FC				 cld
1  2960	000003CE  F3> AB			 rep	 stosd
1  2961	000003D0  5F				 pop	 edi
1  2962	000003D1  40				 inc	 eax
1  2963	000003D2  26: 89 07			 mov	 es:[edi],eax	 ; 0 bytes si no hay heap
1  2964	000003D5  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 53
DarkX.ASM



1  2965	000003DC  B8 00000000s			 mov	 eax,txcode32
1  2966	000003E1  C1 E0	04			 shl	 eax,4
1  2967	000003E4  80 B8	00003249r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  2968	000003EB  74 12				 jz	 no_ext_heap_error
1  2969	000003ED  05 00003241r			 add	 eax,offset extended_heap_info
1  2970	000003F2  E8 00001096			 call	 getmeminfo
1  2971	000003F7  26: 89 07			 mov	 es:[edi],eax
1  2972	000003FA  80 64	24 18 FC		 and	 byte ptr ss:[esp+4*6],0FCh
1  2973	000003FF				 no_ext_heap_error:
1  2974	000003FF  59 5B	58 1F			 pop	 ecx ebx eax ds
1  2975	00000403  CF				 iretd
1  2976					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  2977	00000404			 ext_mem_alloc:
1  2978	00000404  50 53	51 1E			 push	 eax ebx ecx ds
1  2979	00000408  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  2980	0000040F  B8 00000000s			 mov	 eax,txcode32
1  2981	00000414  C1 E0	04			 shl	 eax,4
1  2982	00000417  80 B8	00003249r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  2983	0000041E  74 2D				 jz	 alloc_error	 ; salta si no hay heap
1  2984	00000420  05 00003241r			 add	 eax,offset extended_heap_info
1  2985	00000425  C1 E3	10			 shl	 ebx,16
1  2986	00000428  81 E1	0000FFFF		 and	 ecx,0FFFFh
1  2987	0000042E  0B CB				 or	 ecx,ebx
1  2988	00000430  E8 00000E6A			 call	 malloc
1  2989	00000435  0B DB				 or	 ebx,ebx
1  2990	00000437  74 14				 jz	 alloc_error
1  2991	00000439  1F				 pop	 ds
1  2992	0000043A  8B CB				 mov	 ecx,ebx
1  2993	0000043C  C1 EB	10			 shr	 ebx,16
1  2994	0000043F  8B F3				 mov	 esi,ebx			 ; handle = linear address
1  2995	00000441  8B F9				 mov	 edi,ecx
1  2996	00000443  83 C4	08			 add	 esp,4*2
1  2997	00000446  58				 pop	 eax
1  2998	00000447  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  2999	0000044C  CF				 iretd
1  3000	0000044D			 alloc_error:
1  3001	0000044D  1F 59	5B 58			 pop	 ds ecx	ebx eax
1  3002	00000451  80 4C	24 08 01		 or	 byte ptr ss:[esp+2*4],1	 ; CF =	1 si por si hay	error
1  3003	00000456  CF				 iretd
1  3004					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3005	00000457			 ext_mem_free:
1  3006	00000457  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3007	0000045C  1E 50	53 51			 push	 ds eax	ebx ecx
1  3008	00000460  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3009	00000467  BB 00000000s			 mov	 ebx,txcode32
1  3010	0000046C  C1 E3	04			 shl	 ebx,4
1  3011	0000046F  80 BB	00003249r 00		 cmp	 byte ptr [ebx+extended_pointers],0
1  3012	00000476  74 12				 jz	 ext_free_error
1  3013	00000478  8B DE				 mov	 ebx,esi
1  3014	0000047A  C1 E3	10			 shl	 ebx,16
1  3015	0000047D  66| 8B DF			 mov	 bx,di
1  3016	00000480  E8 00000E73			 call	 free
1  3017	00000485  80 64	24 18 FE		 and	 byte ptr ss:[esp+4*6],0FEh
1  3018	0000048A				 ext_free_error:
1  3019	0000048A  59 5B	58 1F			 pop	 ecx ebx eax ds
1  3020	0000048E  CF				 iretd
1  3021					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 54
DarkX.ASM



1  3022	0000048F			 ext_mem_resize:
1  3023	0000048F  50 52	53 51 56 57 1E		 push	 eax edx ebx ecx esi edi ds
1  3024	00000496  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3025	0000049D  B8 00000000s			 mov	 eax,txcode32
1  3026	000004A2  C1 E0	04			 shl	 eax,4
1  3027	000004A5  80 B8	00003249r 00		 cmp	 byte ptr [eax+extended_pointers],0
1  3028	000004AC  74 38				 jz	 realloc_error
1  3029	000004AE  05 00003241r			 add	 eax,offset extended_heap_info
1  3030	000004B3  81 E1	0000FFFF		 and	 ecx,0FFFFh
1  3031	000004B9  C1 E3	10			 shl	 ebx,16
1  3032	000004BC  0B CB				 or	 ecx,ebx
1  3033	000004BE  8B DE				 mov	 ebx,esi
1  3034	000004C0  C1 E3	10			 shl	 ebx,16
1  3035	000004C3  66| 8B DF			 mov	 bx,di
1  3036	000004C6  E8 00000E94			 call	 realloc
1  3037	000004CB  0B DB				 or	 ebx,ebx
1  3038	000004CD  74 17				 jz	 realloc_error
1  3039	000004CF  1F				 pop	 ds
1  3040	000004D0  8B FB				 mov	 edi,ebx
1  3041	000004D2  8B F3				 mov	 esi,ebx
1  3042	000004D4  C1 EE	10			 shr	 esi,16
1  3043	000004D7  8B DE				 mov	 ebx,esi
1  3044	000004D9  8B CF				 mov	 ecx,edi
1  3045	000004DB  83 C4	10			 add	 esp,4*4
1  3046	000004DE  5A 58				 pop	 edx eax
1  3047	000004E0  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3048	000004E5  CF				 iretd
1  3049	000004E6			 realloc_error:
1  3050	000004E6  1F 5F	5E 59 5B 5A 58		 pop	 ds edi	esi ecx	ebx edx	eax
1  3051	000004ED  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3052	000004F2  CF				 iretd
1  3053
1  3054					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3055					 ; LDT Access Services
1  3056					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3057					 ASSUME	 DS:txdata
1  3058	000004F3			 alloc_desc:
1  3059	000004F3  50 1E	53			 push	 eax ds	ebx
1  3060	000004F6  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3061	000004FD  33 C0				 xor	 eax,eax
1  3062	000004FF  BB 0000000A			 mov	 ebx,FREE_DESCS
1  3063	00000504  0F B7	C9			 movzx	 ecx,cx
1  3064
1  3065	00000507				 search_free_descs:
1  3066	00000507  0B DB					 or	 ebx,ebx
1  3067	00000509  74 5C					 jz	 not_enough_descs
1  3068	0000050B  80 B8	0000061Cr 00			 cmp	 byte ptr [eax+free_descs_handles],0
1  3069	00000512  74 06					 jz	 found_one_slot
1  3070	00000514  40					 inc	 eax
1  3071	00000515  4B				 dec	 ebx
1  3072	00000516  75 EF				 jnz	 search_free_descs
1  3073	00000518  EB 4D				 jmp	 not_enough_descs
1  3074	0000051A				 found_one_slot:
1  3075	0000051A  51 50				 push	 ecx eax
1  3076	0000051C				 find_the_rest:
1  3077	0000051C  80 B8	0000061Cr 00			 cmp	 byte ptr [eax+free_descs_handles],0
1  3078	00000523  75 06					 jnz	 couldnt_find_em
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 55
DarkX.ASM



1  3079	00000525  40					 inc	 eax
1  3080	00000526  4B					 dec	 ebx
1  3081	00000527  E2 F3				 loop	 find_the_rest
1  3082	00000529  EB 06				 jmp	 found_descs
1  3083	0000052B				 couldnt_find_em:
1  3084	0000052B  83 C4	04			 add	 esp,4
1  3085	0000052E  59				 pop	 ecx
1  3086	0000052F  EB D6				 jmp	 search_free_descs
1  3087
1  3088	00000531				 found_descs:
1  3089	00000531  58 59	5B			 pop	 eax ecx ebx
1  3090	00000534  50 51				 push	 eax ecx
1  3091	00000536				 alloc_em:
1  3092	00000536  FE 80	0000061Cr			 inc	 byte ptr [eax+free_descs_handles]
1  3093	0000053C  C7 04	C5 000005CCr  +			 mov	 dword ptr [eax*8+free_descs_start],0
   3094		  00000000
1  3095	00000547  C7 04	C5 000005D0r  +			 mov	 dword ptr [eax*8+free_descs_start+4],0C09300h
   3096		  00C09300
1  3097	00000552  40					 inc	 eax
1  3098	00000553  E2 E1				 loop	 alloc_em
1  3099	00000555  59 58				 pop	 ecx eax
1  3100	00000557  83 C0	0C			 add	 eax,NUM_DESCS
1  3101	0000055A  C1 E0	03			 shl	 eax,3
1  3102	0000055D  1F				 pop	 ds
1  3103	0000055E  83 C4	04			 add	 esp,4
1  3104	00000561  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3105	00000566  CF				 iretd
1  3106
1  3107	00000567				 not_enough_descs:
1  3108	00000567  5B 1F	58			 pop	 ebx ds	eax
1  3109	0000056A  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3110	0000056F  CF				 iretd
1  3111					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3112	00000570			 free_desc:
1  3113	00000570  1E 53				 push	 ds ebx
1  3114	00000572  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3115	00000579  0F B7	DB			 movzx	 ebx,bx
1  3116	0000057C  66| C1 EB 03			 shr	 bx,3
1  3117	00000580  80 4C	24 10 01		 or	 byte ptr ss:[esp+4*4],1
1  3118	00000585  80 FB	0C			 cmp	 bl,NUM_DESCS
1  3119	00000588  72 11				 jb	 free_desc_error
1  3120	0000058A  80 FB	16			 cmp	 bl,NUM_DESCS+FREE_DESCS
1  3121	0000058D  73 0C				 jae	 free_desc_error
1  3122	0000058F  C6 83	00000610r 00		 mov	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3123	00000596  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3124	0000059B				 free_desc_error:
1  3125	0000059B  5B 1F				 pop	 ebx ds
1  3126	0000059D  CF				 iretd
1  3127					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3128	0000059E			 next_desc:
1  3129	0000059E  66| B8 0008			 mov	 ax,8
1  3130	000005A2  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3131	000005A7  CF				 iretd
1  3132					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3133	000005A8			 set_desc:
1  3134	000005A8  1E 53				 push	 ds ebx
1  3135	000005AA  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 56
DarkX.ASM



1  3136	000005B1  0F B7	DB			 movzx	 ebx,bx
1  3137	000005B4  66| C1 EB 03			 shr	 bx,3
1  3138	000005B8  80 4C	24 10 01		 or	 byte ptr ss:[esp+4*4],1
1  3139	000005BD  83 FB	0C			 cmp	 ebx,NUM_DESCS
1  3140	000005C0  72 28				 jb	 set_desc_error
1  3141	000005C2  83 FB	16			 cmp	 ebx,NUM_DESCS+FREE_DESCS
1  3142	000005C5  73 23				 jae	 set_desc_error
1  3143	000005C7  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3144	000005CE  74 1A				 jz	 set_desc_error
1  3145	000005D0  26: FF 37			 push	 dword ptr es:[edi]
1  3146	000005D3  8F 04	DD 00000564r		 pop	 dword ptr [ebx*8+gdt]
1  3147	000005DA  26: FF 77 04			 push	 dword ptr es:[edi+4]
1  3148	000005DE  8F 04	DD 00000568r		 pop	 dword ptr [ebx*8+gdt+4]
1  3149	000005E5  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3150	000005EA				 set_desc_error:
1  3151	000005EA  5B 1F				 pop	 ebx ds
1  3152	000005EC  CF				 iretd
1  3153					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3154	000005ED			 get_seg_base:
1  3155	000005ED  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3156	000005F2  53 1E				 push	 ebx ds
1  3157	000005F4  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3158	000005FB  0F B7	DB			 movzx	 ebx,bx
1  3159	000005FE  66| C1 EB 03			 shr	 bx,3
1  3160	00000602  66| 83 FB 16			 cmp	 bx,NUM_DESCS+FREE_DESCS
1  3161	00000606  73 2A				 jae	 get_seg_base_error
1  3162	00000608  66| 83 FB 0C			 cmp	 bx,NUM_DESCS
1  3163	0000060C  72 09				 jb	 get_this_base
1  3164	0000060E  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3165	00000615  74 1B				 jz	 get_seg_base_error
1  3166	00000617				 get_this_base:
1  3167	00000617  66| 8B 14 DD	      +		 mov	 dx,word ptr [ebx*8+gdt+2]
   3168		  00000566r
1  3169	0000061F  8A 0C	DD 00000568r		 mov	 cl,byte ptr [ebx*8+gdt+4]
1  3170	00000626  8A 2C	DD 0000056Br		 mov	 ch,byte ptr [ebx*8+gdt+7]
1  3171	0000062D  80 64	24 10 FE		 and	 byte ptr ss:[esp+4*4],0FEh
1  3172	00000632				 get_seg_base_error:
1  3173	00000632  1F 5B				 pop	 ds ebx
1  3174	00000634  CF				 iretd
1  3175
1  3176					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3177					 ; Interrupt Vector Services
1  3178					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3179					 ASSUME	 DS:txcode32
1  3180	00000635			 get_int_vector:
1  3181	00000635  1E 50	53			 push	 ds eax	ebx
1  3182	00000638  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3183	0000063F  B8 00000000s			 mov	 eax,txcode32
1  3184	00000644  C1 E0	04			 shl	 eax,4
1  3185	00000647  0F B6	DB			 movzx	 ebx,bl
1  3186	0000064A  80 FB	08			 cmp	 bl,8
1  3187	0000064D  72 08				 jb	 no_irq_fixup1
1  3188	0000064F  80 FB	0F			 cmp	 bl,15
1  3189	00000652  77 03				 ja	 no_irq_fixup1
1  3190	00000654  80 C3	48				 add	 bl,50h-8	 ; irq's redireccionadas
1  3191	00000657				 no_irq_fixup1:
1  3192	00000657  66| 8B 8C D8	      +		 mov	 cx,word ptr [ebx*8+eax+idt+2]
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 57
DarkX.ASM



   3193		  00001F1Ar
1  3194	0000065F  66| 8B 94 D8	      +		 mov	 dx,word ptr [ebx*8+eax+idt+6]
   3195		  00001F1Er
1  3196	00000667  C1 E2	10			 shl	 edx,16
1  3197	0000066A  66| 8B 94 D8	      +		 mov	 dx,word ptr [ebx*8+eax+idt]
   3198		  00001F18r
1  3199	00000672  5B 58	1F			 pop	 ebx eax ds
1  3200	00000675  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3201	0000067A  CF				 iretd
1  3202					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3203	0000067B			 set_int_vector:
1  3204	0000067B  1E 50	53			 push	 ds eax	ebx
1  3205	0000067E  FA				 cli
1  3206	0000067F  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3207	00000686  B8 00000000s			 mov	 eax,txcode32
1  3208	0000068B  C1 E0	04			 shl	 eax,4
1  3209	0000068E  0F B6	DB			 movzx	 ebx,bl
1  3210	00000691  80 FB	08			 cmp	 bl,8
1  3211	00000694  72 08				 jb	 no_irq_fixup2
1  3212	00000696  80 FB	0F			 cmp	 bl,15
1  3213	00000699  77 03				 ja	 no_irq_fixup2
1  3214	0000069B  80 C3	48				 add	 bl,50h-8
1  3215	0000069E				 no_irq_fixup2:
1  3216	0000069E  66| 89 8C D8	      +		 mov	 word ptr [ebx*8+eax+idt+2],cx
   3217		  00001F1Ar
1  3218	000006A6  66| 89 94 D8	      +		 mov	 word ptr [ebx*8+eax+idt],dx
   3219		  00001F18r
1  3220	000006AE  C1 EA	10			 shr	 edx,16
1  3221	000006B1  66| 89 94 D8	      +		 mov	 word ptr [ebx*8+eax+idt+6],dx
   3222		  00001F1Er
1  3223	000006B9  FB				 sti
1  3224	000006BA  5B 58	1F			 pop	 ebx eax ds
1  3225	000006BD  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3226	000006C2  CF				 iretd
1  3227					 ASSUME	 DS:txdata
1  3228
1  3229					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3230					 ; Memory Mapping Services
1  3231					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3232	000006C3			 map_memory:
1  3233	000006C3  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3234	000006C8  1E				 push	 ds
1  3235	000006C9  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3236	000006D0  67| F6 06 0341r 01		 test	 system_type,1
1  3237	000006D6  0F 84	000000EB		 jz	 no_mapping_needed
1  3238	000006DC  FA					 cli
1  3239							 ; s¢lo	hacemos	algo si	tenemos	VCPI
1  3240	000006DD  60					 pushad
1  3241	000006DE  06					 push	 es
1  3242	000006DF  66| 53				 push	 bx
1  3243	000006E1  66| 51				 push	 cx
1  3244	000006E3  5B					 pop	 ebx		 ; EBX = linear	address	of region
1  3245	000006E4  66| 81 E3 F000			 and	 bx,0F000h	 ; 4Kb alignment
1  3246	000006E9  81 FB	00100000			 cmp	 ebx,100000h	 ; si est  en el primer	Mb
1  3247	000006EF  0F 86	000000D4			 jbe	 no_pageable	 ; no se puede paginar
1  3248	000006F5  66| 56				 push	 si
1  3249	000006F7  66| 57				 push	 di
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 58
DarkX.ASM



1  3250	000006F9  59					 pop	 ecx		 ; ECX = size of region	in bytes
1  3251	000006FA  0B C9					 or	 ecx,ecx
1  3252	000006FC  0F 84	000000C7			 jz	 no_pageable
1  3253	00000702  66| 81 C1 0FFF			 add	 cx,0FFFh
1  3254	00000707  66| 81 E1 F000			 and	 cx,0F000h	 ; 4Kb multiple
1  3255	0000070C  C1 E9	0A				 shr	 ecx,10		 ; size/1024
1  3256
1  3257							 ; alojamos 1Kb	por cada 1Mb que queramos paginar
1  3258	0000070F  53 51					 push	 ebx ecx
1  3259	00000711  66| B8 0100				 mov	 ax,100h
1  3260	00000715  8B D9					 mov	 ebx,ecx
1  3261	00000717  C1 EB	04				 shr	 ebx,4		 ; /16 -> p rrafos
1  3262	0000071A  66| 81 C3 0100			 add	 bx,4096/16	 ; para	alinear	a 4Kb
1  3263	0000071F  CD 31					 int	 31h
1  3264	00000721  59 5B					 pop	 ecx ebx
1  3265	00000723  0F 82	000000A0			 jc	 no_pageable
1  3266	00000729  66| 05 00FF				 add	 ax,0FFh
1  3267	0000072D  66| 25 FF00				 and	 ax,0FF00h	 ; alineamos
1  3268	00000731  0F B7	C0				 movzx	 eax,ax
1  3269	00000734  C1 E0	04				 shl	 eax,4	 ; EAX = linear	address	of first entry
1  3270
1  3271							 ; buscamos p ginas con	el present bit = 0
1  3272	00000737  2E: 8E 05 00000004r			 mov	 es,cs:D32_SEL
1  3273	0000073E  67| 8B 3E 0355r			 mov	 edi,page_dir_base
1  3274	00000743  8B D1					 mov	 edx,ecx
1  3275	00000745  66| 81 C2 0FFF			 add	 dx,0FFFh
1  3276	0000074A  66| 81 E2 F000			 and	 dx,0F000h
1  3277	0000074F  C1 EA	0C				 shr	 edx,12		 ; EDX = page dir. entries needed
1  3278	00000752  67| 8B 2E 0359r			 mov	 ebp,page_dir_entries
1  3279	00000757					 search_nopresent_entries:
1  3280	00000757  52						 push	 edx
1  3281	00000758  26: F6 07 01					 test	 byte ptr es:[edi],1
1  3282	0000075C  75 0E						 jnz	 present_entry
1  3283	0000075E						 look_for_enough_space:
1  3284	0000075E  26: F6 07 01						 test	 byte ptr es:[edi],1
1  3285	00000762  75 08							 jnz	 present_entry
1  3286	00000764  83 C7	04						 add	 edi,4
1  3287	00000767  4A						 dec	 edx
1  3288	00000768  75 F4						 jnz	 look_for_enough_space
1  3289	0000076A  EB 09						 jmp	 found_space_for_paging
1  3290	0000076C						 present_entry:
1  3291	0000076C  83 C7	04					 add	 edi,4
1  3292	0000076F  5A						 pop	 edx
1  3293	00000770  4D					 dec	 ebp
1  3294	00000771  75 E4					 jnz	 search_nopresent_entries
1  3295	00000773  EB 54					 jmp	 no_pageable
1  3296
1  3297	00000775					 found_space_for_paging:
1  3298	00000775  5A					 pop	 edx
1  3299	00000776  C1 E2	02				 shl	 edx,2
1  3300	00000779  2B FA					 sub	 edi,edx	  ; EDI	-> group of free entries
1  3301
1  3302							 ; entradas del	directorio de p gs. = tablas de	p gs.
1  3303	0000077B  8B D1					 mov	 edx,ecx
1  3304	0000077D  66| 81 C2 0FFF			 add	 dx,0FFFh	  ; round up size to 4Mb
1  3305	00000782  66| 81 E2 F000			 and	 dx,0F000h
1  3306	00000787  C1 EA	0C				 shr	 edx,12
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 59
DarkX.ASM



1  3307	0000078A  50					 push	 eax
1  3308	0000078B  0C 07					 or	 al,7
1  3309	0000078D  57					 push	 edi
1  3310	0000078E  FC					 cld
1  3311	0000078F					 set_dir_entries:
1  3312	0000078F  AB						 stosd
1  3313	00000790  05 00001000					 add	 eax,1000h
1  3314	00000795  4A					 dec	 edx
1  3315	00000796  75 F7					 jnz	 set_dir_entries
1  3316	00000798  5F 58					 pop	 edi eax
1  3317
1  3318	0000079A  C1 E9	02				 shr	 ecx,2		 ; size/4Kb
1  3319	0000079D  80 CB	67				 or	 bl,67h		 ; dirty,accessed,user,writeable,present
1  3320	000007A0					 map_the_region:
1  3321	000007A0  26: 89 18					 mov	 es:[eax],ebx
1  3322	000007A3  81 C3	00001000				 add	 ebx,1000h
1  3323	000007A9  83 C0	04					 add	 eax,4
1  3324	000007AC  E2 F2					 loop	 map_the_region
1  3325	000007AE  67| 2B 3E 0351r			 sub	 edi,dir_base
1  3326	000007B3  C1 E7	14				 shl	 edi,20
1  3327	000007B6  57					 push	 edi
1  3328	000007B7  66| 59 66| 5B				 pop	 cx bx
1  3329	000007BB  07					 pop	 es
1  3330	000007BC  66| 89 5C 24 10			 mov	 ss:[esp+4*4],bx
1  3331	000007C1  66| 89 4C 24 18			 mov	 ss:[esp+4*6],cx
1  3332	000007C6  61					 popad
1  3333	000007C7				 no_mapping_needed:
1  3334	000007C7  1F				 pop	 ds
1  3335	000007C8  CF				 iretd
1  3336
1  3337	000007C9				 no_pageable:
1  3338	000007C9  07				 pop	 es
1  3339	000007CA  61				 popad
1  3340	000007CB  80 4C	24 0C 01		 or	 byte ptr ss:[esp+4*3],1
1  3341	000007D0  EB F5				 jmp	 no_mapping_needed
1  3342
1  3343					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3344					 ; Real	Mode Call-Back Services
1  3345					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3346					 ASSUME	 DS:txdata
1  3347	000007D2			 callback_alloc:
1  3348	000007D2  50 53	51 52			 push	 eax ebx ecx edx
1  3349	000007D6  66| 8C DB			 mov	 bx,ds
1  3350	000007D9  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3351	000007E0  B9 00000020			 mov	 ecx,NUM_RM_CALLBACKS
1  3352	000007E5  33 C0				 xor	 eax,eax
1  3353	000007E7				 search_a_free_callback:
1  3354	000007E7  80 B8	00000CFFr 00			 cmp	 [eax+callback_data.callback_state],FREE_CB
1  3355	000007EE  74 0F					 jz	 cb_found
1  3356	000007F0  83 C0	0F				 add	 eax,size TCallback
1  3357	000007F3  E2 F2				 loop	 search_a_free_callback
1  3358						 ; error: no more free call-back addresses
1  3359	000007F5  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3360	000007F9  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3361	000007FE  CF				 iretd
1  3362
1  3363	000007FF				 cb_found:
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 60
DarkX.ASM



1  3364	000007FF  C6 80	00000CFFr 01		 mov	 [eax+callback_data.callback_state],ALLOCATED_CB    ; now it's allocated
1  3365	00000806  89 B0	00000D02r		 mov	 [eax+callback_data.pm_proc_to_call.loffset],esi
1  3366	0000080C  66| 89 98 00000D06r		 mov	 [eax+callback_data.pm_proc_to_call.selector],bx
1  3367	00000813  89 B8	00000D08r		 mov	 [eax+callback_data.rm_call_struc.loffset],edi
1  3368	00000819  66| 8C 80 00000D0Cr		 mov	 [eax+callback_data.rm_call_struc.selector],es
1  3369	00000820  8E DB				 mov	 ds,bx	 ; segment restore
1  3370	00000822  5A 59				 pop	 edx ecx
1  3371	00000824  66| B9 0000s			 mov	 cx,txcode
1  3372						 ; OFFSET = (EAX / size	TCallback) * size CallbackSlot
1  3373	00000828  BB 0000000F			 mov	 ebx,size TCallback
1  3374	0000082D  33 D2				 xor	 edx,edx
1  3375	0000082F  F7 F3				 div	 ebx
1  3376	00000831  BB 00000007			 mov	 ebx,offset end_of_cb_address-offset callback_address_table
1  3377	00000836  F7 E3				 mul	 ebx
1  3378	00000838  05 000004D7r			 add	 eax,offset callback_address_table
1  3379	0000083D  8B D0				 mov	 edx,eax	 ; CX:DX -> call-back address
1  3380	0000083F  5B 58				 pop	 ebx eax
1  3381	00000841  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3382	00000846  CF				 iretd
1  3383					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3384	00000847			 callback_free:
1  3385	00000847  50 53	51 52			 push	 eax ebx ecx edx
1  3386	0000084B  66| 81 F9 0000s			 cmp		 cx,txcode
1  3387	00000850  75 19					 jnz		 cb_not_found
1  3388	00000852  66| BB 04D7r			 mov	 bx,offset callback_address_table
1  3389	00000856  33 C0				 xor	 eax,eax
1  3390	00000858  B9 00000020			 mov	 ecx,NUM_RM_CALLBACKS
1  3391	0000085D				 search_address:
1  3392	0000085D  66| 3B DA				 cmp	 bx,dx
1  3393	00000860  74 13					 jz	 address_found
1  3394	00000862  66| 83 C3 07				 add	 bx,offset end_of_cb_address-offset callback_address_table
1  3395	00000866  83 C0	0F				 add	 eax,size TCallback
1  3396	00000869  E2 F2				 loop	 search_address
1  3397	0000086B					 cb_not_found:
1  3398	0000086B  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3399	0000086F  80 4C	24 08 01		 or	 byte ptr ss:[esp+4*2],1
1  3400	00000874  CF				 iretd
1  3401
1  3402	00000875				 address_found:
1  3403	00000875  1E				 push	 ds
1  3404	00000876  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3405	0000087D  C6 80	00000CFFr 00		 mov	 [eax+callback_data.callback_state],FREE_CB ; now it's free
1  3406	00000884  1F				 pop	 ds
1  3407	00000885  5A 59	5B 58			 pop	 edx ecx ebx eax
1  3408	00000889  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3409	0000088E  CF				 iretd
1  3410
1  3411					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3412					 ; Real	Mode Interrupt Management Functions
1  3413					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3414	0000088F			 get_rm_int_vec:
1  3415	0000088F  1E 53				 push	 ds ebx
1  3416	00000891  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3417	00000898  80 FB	08			 cmp	 bl,8
1  3418	0000089B  72 08				 jb	 no_irq_fixup_rm1
1  3419	0000089D  80 FB	0F			 cmp	 bl,15
1  3420	000008A0  77 03				 ja	 no_irq_fixup_rm1
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 61
DarkX.ASM



1  3421	000008A2  80 C3	48				 add	 bl,50h-8	 ; irq's redireccionadas
1  3422	000008A5				 no_irq_fixup_rm1:
1  3423	000008A5  0F B6	DB			 movzx	 ebx,bl
1  3424	000008A8  66| 8B 14 9D	      +		 mov	 dx,[ebx*4]
   3425		  00000000
1  3426	000008B0  66| 8B 0C 9D	      +		 mov	 cx,[ebx*4+2]
   3427		  00000002
1  3428	000008B8  5B 1F				 pop	 ebx ds
1  3429	000008BA  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3430	000008BF  CF				 iretd
1  3431					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3432	000008C0			 set_rm_int_vec:
1  3433	000008C0  1E				 push	 ds
1  3434	000008C1  80 FB	08			 cmp	 bl,8
1  3435	000008C4  72 08				 jb	 no_irq_fixup_rm2
1  3436	000008C6  80 FB	0F			 cmp	 bl,15
1  3437	000008C9  77 03				 ja	 no_irq_fixup_rm2
1  3438	000008CB  80 C3	48				 add	 bl,50h-8	 ; irq's redireccionadas
1  3439	000008CE				 no_irq_fixup_rm2:
1  3440	000008CE  0F B6	DB			 movzx	 ebx,bl
1  3441	000008D1  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3442	000008D8  66| 89 14 9D	      +		 mov	 [ebx*4],dx
   3443		  00000000
1  3444	000008E0  66| 89 0C 9D	      +		 mov	 [ebx*4+2],cx
   3445		  00000002
1  3446	000008E8  1F				 pop	 ds
1  3447	000008E9  80 64	24 08 FE		 and	 byte ptr ss:[esp+4*2],0FEh
1  3448	000008EE  CF				 iretd
1  3449					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3450
1  3451
1  3452
   3453					 INCLUDE		 oemfuncs.inc	 ; DarkX OEM functions
1  3454		  =0062			 TX32_VERSION	 EQU 0098
1  3455
1  3456					 ASSUME	 DS:txdata
1  3457					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3458					 ; TX32	OEM functions
1  3459					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3460	000008EF			 get_sys_info:
1  3461					 ; OUTPUT -> AX	= cpu info
1  3462					 ;		 AH = cpu family ; AL =	b7..4: model
1  3463					 ;					b3..0: stepping
1  3464					 ;	     ( CPUID return code where available and 0300h or 0400h for	386
1  3465					 ;	      and 486 respectively )
1  3466					 ;	     BL	= FPU type
1  3467					 ;		  ( 00h	= not present ;	02h = 287 ; 03h	= 387 ;	04h = 487 )
1  3468					 ;	     CL	= system type
1  3469					 ;		  ( 01h	= RAW ;	02h = XMS ; 03h	= VCPI ; 04h = DPMI )
1  3470	000008EF  1E				 push	 ds
1  3471	000008F0  E8 00000016			 call	 determine_sys
1  3472	000008F5  8A CA				 mov	 cl,dl
1  3473	000008F7  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3474	000008FE  66| 67| A1 033Fr		 mov	 ax,cpu_info
1  3475	00000903  67| 8A 1E 0342r		 mov	 bl,fpu_info
1  3476	00000908  1F				 pop	 ds
1  3477	00000909  66| CF			 iret
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 62
DarkX.ASM



1  3478
1  3479	0000090B			 determine_sys	  proc
1  3480					 ; OUTPUT -> DL	= system type with output format
1  3481					 ;	     ( 01 = RAW	, 02 = XMS , 04	= VCPI , 08 = DPMI )
1  3482	0000090B  1E				 push	 ds
1  3483	0000090C  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3484	00000913  33 C0				 xor	 eax,eax
1  3485	00000915  67| A0 0341r			 mov	 al,system_type
1  3486	00000919  2E: 8A 90 00000931r		 mov	 dl,cs:[eax+sys_type_vals]
1  3487	00000920  80 FA	01			 cmp	 dl,1
1  3488	00000923  75 0A				 jnz	 sys_determined
1  3489	00000925  67| 83 3E 0347r 00			 cmp	 xms_entry_point,0
1  3490	0000092B  74 02					 jz	 sys_determined
1  3491	0000092D  FE C2					 inc	 dl
1  3492	0000092F				 sys_determined:
1  3493	0000092F  1F				 pop	 ds
1  3494	00000930  C3				 ret
1  3495	00000931  01 04	08		 sys_type_vals	 db 1,4,8
1  3496	00000934			 determine_sys	 endp
1  3497					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3498	00000934			 get_program_info:
1  3499					 ; INPUT  -> DS:ESI -> buffer for TX32 information
1  3500					 ;	     ECX = size	of buffer (for not overflowing with later versions)
1  3501					 ;
1  3502					 ; OUTPUT -> AX	= TX32 version in binary (v0.98	-> AX=0062h, for example)
1  3503					 ;			 AH = major version
1  3504					 ;			 AL = minor version
1  3505					 ;	     DS:ESI -> info buffer filled with a maximum of ECX	bytes
1  3506					 ;
1  3507					 ;		 Format	of info	buffer for TX32	v0.98:
1  3508					 ;
1  3509					 ;		 Offset	 Size	 Description
1  3510					 ;		 00h	 DWORD	 Program base (zero with LE's)
1  3511					 ;		 04h	 DWORD	 PSP offset relative to	program	base
1  3512					 ;		 08h	 DWORD	 Environment offset rel. to prog. base
1  3513					 ;		 0Ch	 DWORD	 ASCIIZ	exe name offset	rel. to	prog. base
1  3514					 ;		 10h	 WORD	 Zero based 4Gb	data selector
1  3515					 ;		 12h	 WORD	 Program based 4Gb data	selector
1  3516					 ;		 14h	 WORD	 PSP based 100h	bytes data selector
1  3517					 ;		 16h	 WORD	 Real mode disk	buffer segment
1  3518					 ;				 (used for disk	data interchange between real
1  3519					 ;				  mode and protected mode)
1  3520
1  3521	00000934  1E 06	56 57 51		 push	 ds es esi edi ecx
1  3522	00000939  0B C9				 or	 ecx,ecx
1  3523	0000093B  74 1D				 jz	 program_info_done
1  3524	0000093D  83 F9	18			 cmp	 ecx,24
1  3525	00000940  76 05				 jbe	 length_ok
1  3526	00000942  B9 00000018				 mov	 ecx,24
1  3527	00000947				 length_ok:
1  3528	00000947  1E 56				 push	 ds esi
1  3529	00000949  5F 07				 pop	 edi es
1  3530	0000094B  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3531	00000952  BE 00000321r			 mov	 esi,offset exe_info_struc
1  3532	00000957  FC				 cld
1  3533	00000958  F3> A4			 rep	 movsb
1  3534	0000095A				 program_info_done:
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 63
DarkX.ASM



1  3535	0000095A  66| B8 0062			 mov	 ax,TX32_VERSION	 ; version number
1  3536	0000095E  59 5F	5E 07 1F		 pop	 ecx edi esi es	ds
1  3537	00000963  CF				 iretd
1  3538					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3539
   3540					 INCLUDE		 dos32sup.inc	 ; DOS32 basic support
1  3541					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3542					 ; DOS32 basic support routines
1  3543					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3544					 ASSUME	 DS:txdata
1  3545	00000964			 dos32_sys_info:
1  3546	00000964  1E				 push	 ds
1  3547	00000965  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3548	0000096C  67| 8B 1E 0321r		 mov	 ebx,program_offset
1  3549	00000971  67| 8B 16 033Br		 mov	 edx,exe_size
1  3550	00000976  67| 8B 36 0325r		 mov	 esi,psp_offset
1  3551	0000097B  67| 8B 3E 0329r		 mov	 edi,env_offset
1  3552	00000980  67| 8B 0E 032Dr		 mov	 ecx,program_name_ptr
1  3553	00000985  66| B8 0000s			 mov	 ax,disk
1  3554	00000989  1F				 pop	 ds
1  3555	0000098A  CF				 iretd
1  3556					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3557	0000098B			 dos32_info:
1  3558	0000098B  E8 FFFFFF7B			 call	 determine_sys	 ; DL =	system type
1  3559	00000990  33 C0				 xor	 eax,eax	 ; DOS32 version = 0.0 cause nothing is	implemented
1  3560	00000992  66| 2E: 8B 1D	      +		 mov	 bx,cs:D32_SEL	 ; BX =	selector 32 bits base 0	l¡m. 4Gb
   3561		  00000004r
1  3562	0000099A  CF				 iretd
1  3563					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3564
   3565					 INCLUDE		 ints32.inc
1  3566					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3567	0000099B			 real_int:
1  3568	0000099B  53				 push	 ebx
1  3569	0000099C  8B 5C	24 10			 mov	 ebx,ss:[esp+4*4]
1  3570	000009A0  9C				 pushfd
1  3571	000009A1  81 E3	00000200		 and	 ebx,1 SHL 9
1  3572	000009A7  09 1C	24			 or	 ss:[esp],ebx
1  3573	000009AA  9D				 popfd
1  3574						 ; nos guardamos los segmentos
1  3575						 ASSUME	 DS:txdata
1  3576	000009AB  66| 8C DB			 mov	 bx,ds
1  3577	000009AE  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
1  3578	000009B5  66| 67| 89 1E	0376r		 mov	 pm_ds,bx
1  3579	000009BB  66| 67| 8C 06	0378r		 mov	 pm_es,es
1  3580	000009C1  66| 67| 8C 26	037Ar		 mov	 pm_fs,fs
1  3581	000009C7  66| 67| 8C 2E	037Cr		 mov	 pm_gs,gs
1  3582						 ; ponemos el int_num
1  3583	000009CD  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_sel
1  3584	000009D4  BB 00000000s			 mov	 ebx,txcode
1  3585	000009D9  8D 1C	DD 00000000		 lea	 ebx,[ebx*8]	 ; as¡,	no modificamos los flags
1  3586	000009E0  8D 1C	5D 00000000		 lea	 ebx,[ebx*2]
1  3587						 ASSUME	 DS:txcode
1  3588	000009E7  88 83	000004B1r		 mov	 [ebx+int_num],al
1  3589	000009ED  5B				 pop	 ebx
1  3590	000009EE  58				 pop	 eax
1  3591
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 64
DarkX.ASM



1  3592	000009EF				 need_real_segs:	 ; funny label (he,he...)
1  3593	000009EF  9C				 pushfd
1  3594	000009F0  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3595	000009F7  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3596	000009FE  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3597						 pushd	 ret_real
2  3598	00000A05  68				 db 68h
2  3599	00000A06  09BEr	0000			 dw offset ret_real,0
1  3600	00000A0A  CF				 iretd
1  3601
1  3602	00000A0B			 pm_ret_point:
1  3603	00000A0B  FA				 cli
1  3604
1  3605						 ; ajustamos pila para modo protegido
1  3606						 ASSUME	 DS:txdata
1  3607	00000A0C  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3608						 ; primero restauramos SS:ESP de protegido para	poder usar pila
1  3609	00000A13  67| 8B 26 0520r		 mov	 esp,pm_esp
1  3610	00000A18  67| 8E 16 037Er		 mov	 ss,pm_ss
1  3611
1  3612						 ; restauramos todos los registros de modo real
1  3613	00000A1D  66| 67| A1 04F2r		 mov	 ax,real_flags
1  3614	00000A22  66| 89 44 24 08		 mov	 ss:[esp+4*2],ax
1  3615	00000A27  67| A1 04EEr			 mov	 eax,real_eax
1  3616	00000A2B  67| 8B 1E 04E2r		 mov	 ebx,real_ebx
1  3617	00000A30  67| 8B 0E 04EAr		 mov	 ecx,real_ecx
1  3618	00000A35  67| 8B 16 04E6r		 mov	 edx,real_edx
1  3619	00000A3A  67| 8B 36 04D6r		 mov	 esi,real_esi
1  3620	00000A3F  67| 8B 3E 04D2r		 mov	 edi,real_edi
1  3621	00000A44  67| 8B 2E 04DAr		 mov	 ebp,real_ebp
1  3622					 ;	  push	  word ptr real_flags
1  3623					 ;	  pop	  word ptr ss:[esp+4*2]	  ; flags devueltos por	la int a protegido
1  3624
1  3625						 ; acabamos restaurando	los registros de segmento
1  3626	00000A49  67| 8E 06 0378r		 mov	 es,pm_es
1  3627	00000A4E  67| 8E 26 037Ar		 mov	 fs,pm_fs
1  3628	00000A53  67| 8E 2E 037Cr		 mov	 gs,pm_gs
1  3629	00000A58  67| 8E 1E 0376r		 mov	 ds,pm_ds	 ; si restauramos antes	DS, no podemos
1  3630									 ; direccionar RET_INFO
1  3631	00000A5D  CF				 iretd
1  3632					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3633	00000A5E			 real_irq:
1  3634					 ; INPUT -> AL = interrupt number
1  3635	00000A5E  60				 pushad
1  3636	00000A5F  1E 06	0F A0 0F A8		 push	 ds es fs gs
1  3637	00000A65  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3638	00000A6C  0F B6	C0			 movzx	 eax,al
1  3639	00000A6F  26: 8B 1C 85	      +		 mov	 ebx,es:[eax*4]	 ; direcci¢n real del handle de	interrupci¢n
   3640		  00000000
1  3641	00000A77  B9 00000000s			 mov	 ecx,txcode
1  3642	00000A7C  C1 E1	04			 shl	 ecx,4
1  3643						 ASSUME	 ES:txcode
1  3644	00000A7F  26: 89 99 000004BAr		 mov	 es:[ecx+rm_proc_address],ebx
1  3645	00000A86  26: FF B1 00000019r		 push	 dword ptr es:[ecx+saltito+1]
1  3646	00000A8D  66| 26: C7 81	      +		 mov	 word ptr es:[ecx+saltito+1],offset irq16
   3647		  00000019r 04BEr
1  3648	00000A97  66| 26: C7 81	      +		 mov	 word ptr es:[ecx+saltito+3],txcode
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 65
DarkX.ASM



   3649		  0000001Br 0000s
1  3650	00000AA1  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3651						 ASSUME	 DS:txdata
1  3652	00000AA8  67| FF 36 0532r		 push	 dword ptr prot_code_address
1  3653	00000AAD  67| FF 36 0536r		 push	 dword ptr prot_code_address+4
1  3654	00000AB2  67| C7 06 0532r     +		 mov	 dword ptr prot_code_address,offset back_from_irq16
   3655		  00000AD4r
1  3656	00000ABB  66| 67| 8C 16	037Er		 mov	 pm_ss,ss
1  3657	00000AC1  67| 89 26 0520r		 mov	 pm_esp,esp
1  3658	00000AC6  9C				 pushfd
1  3659	00000AC7  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3660	00000ACE  67| FF 36 0538r		 push	 dword ptr ret_real_address
1  3661	00000AD3  CF				 iretd
1  3662
1  3663	00000AD4				 back_from_irq16:
1  3664	00000AD4  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3665	00000ADB  67| 8E 16 037Er		 mov	 ss,pm_ss
1  3666	00000AE0  67| 8B 26 0520r		 mov	 esp,pm_esp
1  3667	00000AE5  67| 8F 06 0536r		 pop	 dword ptr prot_code_address+4
1  3668	00000AEA  67| 8F 06 0532r		 pop	 dword ptr prot_code_address
1  3669	00000AEF  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3670	00000AF6  B9 00000000s			 mov	 ecx,txcode
1  3671	00000AFB  C1 E1	04			 shl	 ecx,4
1  3672						 ASSUME	 DS:txcode
1  3673	00000AFE  8F 81	00000019r		 pop	 dword ptr [ecx+saltito+1]
1  3674						 ASSUME	 DS:txdata
1  3675	00000B04  0F A9	0F A1 07 1F		 pop	 gs fs es ds
1  3676	00000B0A  61				 popad
1  3677	00000B0B  58				 pop	 eax
1  3678	00000B0C  CF				 iretd
1  3679					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3680
1  3681
   3682					 INCLUDE		 excs32.inc
1  3683					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3684	00000B0D			 exceptions:
1  3685						 ASSUME	 DS:txdata
1  3686						 ; rellenamos el texto de salida con los valores de debugging
1  3687	00000B0D  1E 53	57 51 56 55 52		 push	 ds ebx	edi ecx	esi ebp	edx
1  3688	00000B14  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
1  3689						 ; n£mero de excepci¢n
1  3690	00000B1B  8A D0				 mov	 dl,al	 ; gate	number
1  3691	00000B1D  BF 00000719r			 mov	 edi,offset exception_number
1  3692	00000B22  32 C9				 xor	 cl,cl
1  3693	00000B24  E8 000002FB			 call	 reg_to_hex
1  3694						 ; ponemos los valores de EDX,EBP,ESI,ECX,EDI y	EBX
1  3695						 ASSUME	 DS:txcode32
1  3696	00000B29  BB 00000006			 mov	 ebx,6
1  3697	00000B2E				 pon_registros:
1  3698	00000B2E  58					 pop	 eax
1  3699	00000B2F  2E: 8B 3C 9D	      +			 mov	 edi,cs:[ebx*4+reg_offsets-4]
   3700		  00000D7Dr
1  3701	00000B37  B1 02					 mov	 cl,2
1  3702	00000B39  53					 push	 ebx
1  3703	00000B3A  E8 000002E5				 call	 reg_to_hex
1  3704	00000B3F  5B					 pop	 ebx
1  3705	00000B40  4B				 dec	 ebx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 66
DarkX.ASM



1  3706	00000B41  75 EB				 jnz	 pon_registros
1  3707						 ASSUME	 DS:txdata
1  3708
1  3709						 ; valor de DS
1  3710	00000B43  58				 pop	 eax	 ; pq estamos en un segmento de	32 bits
1  3711	00000B44  50				 push	 eax
1  3712	00000B45  BF 00000992r			 mov	 edi,offset debug_ds
1  3713	00000B4A  B1 01				 mov	 cl,1
1  3714	00000B4C  E8 000002D3			 call	 reg_to_hex
1  3715	00000B51  5B				 pop	 ebx
1  3716	00000B52  BF 000009A1r			 mov	 edi,offset desc_ds
1  3717	00000B57  E8 00000258			 call	 print_desc
1  3718						 ; valor de EAX
1  3719	00000B5C  58				 pop	 eax
1  3720	00000B5D  BF 00000852r			 mov	 edi,offset debug_eax
1  3721	00000B62  B1 02				 mov	 cl,2	 ; 32 bits
1  3722	00000B64  E8 000002BB			 call	 reg_to_hex
1  3723						 ; valor de ES ( lo hacemos ahora para poder usar ES sin "popearlo" )
1  3724	00000B69  66| 8C C0			 mov	 ax,es
1  3725	00000B6C  BF 000009BFr			 mov	 edi,offset debug_es
1  3726	00000B71  B1 01				 mov	 cl,1
1  3727	00000B73  E8 000002AC			 call	 reg_to_hex
1  3728	00000B78  66| 8C C3			 mov	 bx,es
1  3729	00000B7B  BF 000009CEr			 mov	 edi,offset desc_es
1  3730	00000B80  E8 0000022F			 call	 print_desc
1  3731						 ; si estamos bajo DPMI, tenemos CS:EIP	de retorno en pila y no	nos interesa
1  3732	00000B85  67| F6 06 0341r 02		 test	 system_type,2
1  3733	00000B8B  74 05				 jz	 no_tenemos_el_gusto
1  3734	00000B8D  83 C4	0C				 add	 esp,3*4
1  3735	00000B90  EB 0B					 jmp	 no_error_code
1  3736	00000B92				 no_tenemos_el_gusto:
1  3737						 ; volcamos el opcode causante del error
1  3738	00000B92  80 FA	0E			 cmp	 dl,14		 ; s¢lo	las int's 9-13 tendr n 'error code' en pila
1  3739	00000B95  77 06				 ja	 no_error_code
1  3740	00000B97  80 FA	09			 cmp	 dl,9
1  3741	00000B9A  72 01				 jb	 no_error_code
1  3742	00000B9C  58					 pop	 eax	 ; info	de debugging de	la CPU
1  3743	00000B9D				 no_error_code:
1  3744	00000B9D  58				 pop	 eax	 ; EIP
1  3745	00000B9E  5B				 pop	 ebx	 ; CS
1  3746	00000B9F  53				 push	 ebx
1  3747	00000BA0  50				 push	 eax
1  3748	00000BA1  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  3749	00000BA8  67| F6 06 0341r 02		 test	 system_type,2
1  3750	00000BAE  74 13				 jz	 normal_gdt
1  3751	00000BB0  50					 push	 eax
1  3752	00000BB1  66| B8 000B				 mov	 ax,0Bh
1  3753	00000BB5  BF 00000564r				 mov	 edi,offset gdt
1  3754	00000BBA  CD 31					 int	 31h
1  3755	00000BBC  72 48					 jc	 invalid_code_selector
1  3756	00000BBE  33 DB					 xor	 ebx,ebx
1  3757	00000BC0  58					 pop	 eax
1  3758	00000BC1  EB 06					 jmp	 continua_volcado
1  3759	00000BC3				 normal_gdt:
1  3760						 ; vamos a hacerlo con el selector de 4Gb por si el de c¢digo es s¢lo ejecutable
1  3761	00000BC3  0F B7	DB			 movzx	 ebx,bx		 ; selector c¢digo
1  3762	00000BC6  80 E3	F8			 and	 bl,11111000b	 ; limpiamos el	requested PL y nos queda BX = descriptor * 8
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 67
DarkX.ASM



1  3763						 ASSUME	 ES:txdata
1  3764	00000BC9				 continua_volcado:
1  3765	00000BC9  26: 8A 8B 0000056Br		 mov	 cl,byte ptr es:[ebx+7+gdt] ; CL = bits	24-31 de la base
1  3766	00000BD0  C1 E1	18			 shl	 ecx,24
1  3767	00000BD3  26: 8B 9B 00000566r		 mov	 ebx,dword ptr es:[ebx+2+gdt] ;	bits 0-23 de la	base
1  3768	00000BDA  81 E3	00FFFFFF		 and	 ebx,(1	SHL 24)-1	 ; limpiamos los 8 bits	superiores
1  3769	00000BE0  0B D9				 or	 ebx,ecx		 ; formamos la base completa
1  3770	00000BE2  03 D8				 add	 ebx,eax		 ; le sumamos el OFFSET
1  3771	00000BE4  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3772	00000BEB  BF 0000079Ar			 mov	 edi,offset crash_code
1  3773	00000BF0  B9 00000008			 mov	 ecx,8
1  3774	00000BF5				 vuelca_code:
1  3775	00000BF5  26: 8A 03				 mov	 al,es:[ebx]
1  3776	00000BF8  E8 00000269				 call	 bin_to_hex
1  3777	00000BFD  66| 89 07				 mov	 ds:[edi],ax
1  3778	00000C00  83 C7	03				 add	 edi,3
1  3779	00000C03  43					 inc	 ebx
1  3780	00000C04  E2 EF				 loop	 vuelca_code
1  3781
1  3782	00000C06				 invalid_code_selector:
1  3783						 ; valor de EIP
1  3784	00000C06  58				 pop	 eax	 ; EIP
1  3785	00000C07  B1 02				 mov	 cl,2
1  3786	00000C09  BF 0000078Br			 mov	 edi,offset debug_eip
1  3787	00000C0E  E8 00000211			 call	 reg_to_hex
1  3788						 ; valor de CS
1  3789	00000C13  58				 pop	 eax	 ; CS
1  3790	00000C14  50				 push	 eax
1  3791	00000C15  B1 01				 mov	 cl,1
1  3792	00000C17  BF 00000786r			 mov	 edi,offset debug_cs
1  3793	00000C1C  E8 00000203			 call	 reg_to_hex
1  3794	00000C21  67| A1 0786r			 mov	 eax,dword ptr debug_cs
1  3795	00000C25  67| A3 0965r			 mov	 dword ptr debug_cs1,eax
1  3796	00000C29  5B				 pop	 ebx
1  3797	00000C2A  BF 00000974r			 mov	 edi,offset desc_cs
1  3798	00000C2F  E8 00000180			 call	 print_desc
1  3799						 ; valor de FS
1  3800	00000C34  66| 8C E0			 mov	 ax,fs
1  3801	00000C37  BF 000009ECr			 mov	 edi,offset debug_fs
1  3802	00000C3C  B1 01				 mov	 cl,1
1  3803	00000C3E  E8 000001E1			 call	 reg_to_hex
1  3804	00000C43  66| 8C E3			 mov	 bx,fs
1  3805	00000C46  BF 000009FBr			 mov	 edi,offset desc_fs
1  3806	00000C4B  E8 00000164			 call	 print_desc
1  3807						 ; valor de GS
1  3808	00000C50  66| 8C E8			 mov	 ax,gs
1  3809	00000C53  BF 00000A19r			 mov	 edi,offset debug_gs
1  3810	00000C58  B1 01				 mov	 cl,1
1  3811	00000C5A  E8 000001C5			 call	 reg_to_hex
1  3812	00000C5F  66| 8C EB			 mov	 bx,gs
1  3813	00000C62  BF 00000A28r			 mov	 edi,offset desc_gs
1  3814	00000C67  E8 00000148			 call	 print_desc
1  3815						 ; valor de SS
1  3816	00000C6C  67| F6 06 0341r 02		 test	 system_type,2
1  3817	00000C72  74 06				 jz	 no_ss_de_pila
1  3818	00000C74  8B 44	24 08				 mov	 eax,ss:[esp+2*4]
1  3819	00000C78  EB 03					 jmp	 ss_de_pila
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 68
DarkX.ASM



1  3820	00000C7A				 no_ss_de_pila:
1  3821	00000C7A  66| 8C D0			 mov	 ax,ss
1  3822	00000C7D				 ss_de_pila:
1  3823	00000C7D  B1 01				 mov	 cl,1
1  3824	00000C7F  BF 00000A46r			 mov	 edi,offset debug_ss
1  3825	00000C84  50				 push	 eax
1  3826	00000C85  E8 0000019A			 call	 reg_to_hex
1  3827	00000C8A  5B				 pop	 ebx
1  3828	00000C8B  67| A1 0A46r			 mov	 eax,dword ptr debug_ss
1  3829	00000C8F  67| A3 07CCr			 mov	 dword ptr debug_ss0,eax
1  3830	00000C93  BF 00000A55r			 mov	 edi,offset desc_ss
1  3831	00000C98  E8 00000117			 call	 print_desc
1  3832						 ; valor de los	EFLAGS
1  3833	00000C9D  58				 pop	 eax
1  3834	00000C9E  50				 push	 eax
1  3835	00000C9F  B1 02				 mov	 cl,2
1  3836	00000CA1  BF 000008E3r			 mov	 edi,offset debug_flags
1  3837	00000CA6  E8 00000179			 call	 reg_to_hex
1  3838						 ; valor de ESP	antes de la excepci¢n
1  3839	00000CAB  8B C4				 mov	 eax,esp
1  3840	00000CAD  83 C0	04			 add	 eax,4	 ; EFLAGS
1  3841	00000CB0  67| F6 06 0341r 02		 test	 system_type,2
1  3842	00000CB6  74 04				 jz	 normal_esp
1  3843	00000CB8  8B 44	24 04				 mov	 eax,ss:[esp+1*4]
1  3844	00000CBC				 normal_esp:
1  3845	00000CBC  B1 02				 mov	 cl,2
1  3846	00000CBE  BF 000008CFr			 mov	 edi,offset debug_esp
1  3847	00000CC3  E8 0000015C			 call	 reg_to_hex
1  3848	00000CC8  67| A1 08CFr			 mov	 eax,dword ptr debug_esp
1  3849	00000CCC  67| A3 07D1r			 mov	 dword ptr debug_esp0,eax
1  3850	00000CD0  67| A1 08D3r			 mov	 eax,dword ptr debug_esp+4
1  3851	00000CD4  67| A3 07D5r			 mov	 dword ptr debug_esp0+4,eax
1  3852						 ; volcamos la pila
1  3853	00000CD8  BE 00000003			 mov	 esi,3
1  3854	00000CDD  BD 00000004			 mov	 ebp,4
1  3855	00000CE2  BF 000007E0r			 mov	 edi,offset stack_cont1
1  3856	00000CE7  66| 8C D0			 mov	 ax,ss
1  3857	00000CEA  8E C0				 mov	 es,ax
1  3858	00000CEC  03 EC				 add	 ebp,esp
1  3859	00000CEE  67| F6 06 0341r 02		 test	 system_type,2
1  3860	00000CF4  74 0B				 jz	 vuelca_pila
1  3861	00000CF6  66| 8B 44 24 08		 mov	 ax,ss:[esp+2*4]
1  3862	00000CFB  8B 6C	24 04			 mov	 ebp,ss:[esp+1*4]
1  3863	00000CFF  8E C0				 mov	 es,ax
1  3864	00000D01				 vuelca_pila:
1  3865	00000D01  26: 8B 45 00				 mov	 eax,es:[ebp]
1  3866	00000D05  B1 02					 mov	 cl,2
1  3867	00000D07  55					 push	 ebp
1  3868	00000D08  E8 00000117				 call	 reg_to_hex
1  3869	00000D0D  5D					 pop	 ebp
1  3870	00000D0E  83 C5	04				 add	 ebp,4
1  3871	00000D11  83 C7	09				 add	 edi,9
1  3872	00000D14  4E				 dec	 esi
1  3873	00000D15  75 EA				 jnz	 vuelca_pila
1  3874						 ; vamos a rellenar el campo de	info sobre el error
1  3875	00000D17  0F B6	F2			 movzx	 esi,dl
1  3876	00000D1A  D1 E6				 shl	 esi,1	 ; * 2
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 69
DarkX.ASM



1  3877	00000D1C  0F B7	B6 00000626r		 movzx	 esi,word ptr [esi + error_string_table]
1  3878	00000D23  BF 000006D5r			 mov	 edi,offset error_string
1  3879	00000D28  33 C9				 xor	 ecx,ecx
1  3880	00000D2A				 put_err_strn:
1  3881	00000D2A  8A 06					 mov	 al,[esi]
1  3882	00000D2C  0A C0					 or	 al,al
1  3883	00000D2E  74 07					 jz	 end_put
1  3884	00000D30  88 07					 mov	 [edi],al
1  3885	00000D32  47					 inc	 edi
1  3886	00000D33  46					 inc	 esi
1  3887	00000D34  49				 dec	 ecx
1  3888	00000D35  75 F3				 jnz	 put_err_strn
1  3889	00000D37				 end_put:
1  3890
1  3891						 ; hacemos un acknowledge a los	PIC por	si la excepci¢n	ocurri¢	en
1  3892						 ; una IRQ
1  3893	00000D37  B0 20				 mov	 al,20h		 ; acknowledge
1  3894	00000D39  E6 20				 out	 20h,al		 ; master PIC
1  3895	00000D3B  E6 A0				 out	 0A0h,al	 ; slave PIC
1  3896
1  3897	00000D3D  67| F6 06 0341r 02		 test	 system_type,2
1  3898	00000D43  75 54				 jnz	 dpmi_exception_exit
1  3899
1  3900						 ; vamos a modificar el	salto para que salga la	info de	debugging
1  3901	00000D45  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  3902	00000D4C  BB 00000000s			 mov	 ebx,txcode
1  3903	00000D51  C1 E3	04			 shl	 ebx,4
1  3904						 ASSUME	 DS:txcode
1  3905	00000D54  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset debug_info
   3906		  0A69r
1  3907	00000D5D  66| C7 83 0000001Br +		 mov	 word ptr [ebx+saltito+3],txcode
   3908		  0000s
1  3909
1  3910	00000D66  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  3911	00000D6D  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  3912	00000D74  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  3913						 pushd	 ret_real
2  3914	00000D7B  68				 db 68h
2  3915	00000D7C  09BEr	0000			 dw offset ret_real,0
1  3916	00000D80  CF				 iretd
1  3917
1  3918					 ASSUME	 DS:txdata
1  3919	00000D81  00000864r 000008ABr +	 reg_offsets	 dd offset debug_ebx,offset debug_edi,offset debug_ecx
   3920		  00000876r
1  3921	00000D8D  00000899r 000008BDr +			 dd offset debug_esi,offset debug_ebp,offset debug_edx
   3922		  00000888r
1  3923
1  3924					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3925
1  3926	00000D99			 dpmi_exception_exit:
1  3927					 ; DS =	D16_SEL
1  3928
1  3929	00000D99  9D				 popfd
1  3930	00000D9A  5B				 pop	 ebx
1  3931	00000D9B  58				 pop	 eax
1  3932	00000D9C  FA				 cli
1  3933	00000D9D  8E D0				 mov	 ss,ax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 70
DarkX.ASM



1  3934	00000D9F  8B E3				 mov	 esp,ebx
1  3935
1  3936	00000DA1  67| FE 06 04A9r		 inc	 dpmi_exception_flag
1  3937	00000DA6  9C				 pushfd
1  3938	00000DA7  2E: FF 35 00000000r		 push	 dword ptr cs:C32_SEL
1  3939						 pushd	 salida_dpmi
2  3940	00000DAE  68				 db 68h
2  3941	00000DAF  1E89r	0000			 dw offset salida_dpmi,0
1  3942	00000DB3  CF				 iretd
1  3943
1  3944					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3945
1  3946	00000DB4			 print_desc	 proc
1  3947					 ; INPUT  -> BX	= selector ; DS:EDI = direcci¢n	de destino
1  3948	00000DB4  67| F6 06 0341r 02		 test	 system_type,2
1  3949	00000DBA  74 31				 jz	 normal_sel
1  3950	00000DBC  06 57					 push	 es edi
1  3951	00000DBE  66| B8 000B				 mov	 ax,0Bh
1  3952	00000DC2  2E: 8E 05 0000000Cr			 mov	 es,cs:D16_SEL
1  3953	00000DC9  BF 00000564r				 mov	 edi,offset gdt
1  3954	00000DCE  CD 31					 int	 31h
1  3955	00000DD0  5F 07					 pop	 edi es
1  3956	00000DD2  73 17					 jnc	 sel_ok
1  3957	00000DD4  06						 push	 es
1  3958	00000DD5  2E: 8E 05 0000000Cr				 mov	 es,cs:D16_SEL
1  3959	00000DDC  B9 00000017					 mov	 ecx,7*3+2
1  3960	00000DE1  BE 000006B7r					 mov	 esi,offset invalid_sel_msg
1  3961	00000DE6  FC						 cld
1  3962	00000DE7  F3> A4					 rep	 movsb
1  3963	00000DE9  07						 pop	 es
1  3964	00000DEA  C3						 ret
1  3965	00000DEB					 sel_ok:
1  3966	00000DEB  33 DB					 xor	 ebx,ebx
1  3967	00000DED				 normal_sel:
1  3968	00000DED  0F B7	DB			 movzx	 ebx,bx
1  3969					 ;	  and	  bl,11111000b
1  3970	00000DF0  C1 EB	03			 shr	 ebx,3
1  3971	00000DF3  66| 83 FB 16			 cmp	 bx,NUM_DESCS+FREE_DESCS
1  3972	00000DF7  73 2A				 jae	 no_volcado_desc
1  3973	00000DF9  66| 83 FB 0C			 cmp	 bx,NUM_DESCS
1  3974	00000DFD  72 09				 jb	 volcado_desc
1  3975						 ASSUME	 DS:txdata
1  3976	00000DFF  80 BB	00000610r 00		 cmp	 byte ptr [ebx+free_descs_handles-NUM_DESCS],0
1  3977	00000E06  74 1B				 jz	 no_volcado_desc
1  3978	00000E08				 volcado_desc:
1  3979	00000E08  C1 E3	03			 shl	 ebx,3
1  3980	00000E0B  B1 08				 mov	 cl,8
1  3981	00000E0D				 vuelca_desc:
1  3982	00000E0D  8A 83	00000564r			 mov	 al,byte ptr [ebx+gdt]
1  3983	00000E13  E8 0000004E				 call	 bin_to_hex
1  3984	00000E18  66| 89 07				 mov	 [edi],ax
1  3985	00000E1B  83 C7	03				 add	 edi,3
1  3986	00000E1E  43					 inc	 ebx
1  3987	00000E1F  FE C9				 dec cl
1  3988	00000E21  75 EA				 jnz vuelca_desc
1  3989	00000E23				 no_volcado_desc:
1  3990	00000E23  C3				 ret
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 71
DarkX.ASM



1  3991	00000E24			 print_desc	 endp
1  3992
1  3993					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  3994
1  3995	00000E24			 reg_to_hex	 proc
1  3996					 ; INPUT -> EAX	= number to convert ; DS:EDI ->	destino
1  3997					 ;	    CL = 8/16/32 bit register (2=EAX ; 1=AX ; 0=AL)
1  3998
1  3999	00000E24  32 DB				 xor	 bl,bl
1  4000	00000E26  0A C9				 or	 cl,cl
1  4001	00000E28  74 0A				 jz	 es_al
1  4002	00000E2A  80 F9	01			 cmp	 cl,1
1  4003	00000E2D  74 0B				 jz	 es_ax
1  4004	00000E2F  80 F9	02			 cmp	 cl,2
1  4005	00000E32  74 0F				 jz	 es_eax
1  4006	00000E34				 es_al:
1  4007	00000E34  B1 01					 mov	 cl,1
1  4008	00000E36  33 ED					 xor	 ebp,ebp
1  4009	00000E38  EB 10					 jmp	 convert
1  4010	00000E3A				 es_ax:
1  4011	00000E3A  B1 02					 mov	 cl,2
1  4012	00000E3C  BD 00000002				 mov	 ebp,2
1  4013	00000E41  EB 07					 jmp	 convert
1  4014	00000E43				 es_eax:
1  4015	00000E43  B1 04					 mov	 cl,4
1  4016	00000E45  BD 00000006				 mov	 ebp,6
1  4017	00000E4A				 convert:
1  4018	00000E4A  51					 push	 ecx
1  4019	00000E4B  8A CB					 mov	 cl,bl
1  4020	00000E4D  50					 push	 eax
1  4021	00000E4E  D3 E8					 shr	 eax,cl
1  4022	00000E50  E8 00000011				 call	 bin_to_hex
1  4023	00000E55  66| 89 04 2F				 mov	 [edi+ebp],ax
1  4024	00000E59  58					 pop	 eax
1  4025	00000E5A  59					 pop	 ecx
1  4026	00000E5B  83 ED	02				 sub	 ebp,2
1  4027	00000E5E  80 C3	08				 add	 bl,8
1  4028	00000E61  FE C9				 dec	 cl
1  4029	00000E63  75 E5				 jnz	 convert
1  4030	00000E65  C3				 ret
1  4031	00000E66			 reg_to_hex	 endp
1  4032
1  4033					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4034
1  4035	00000E66			 bin_to_hex	 proc
1  4036					 ; INPUT  -> AL	= byte to convert
1  4037					 ; OUTPUT -> AX	= hex value
1  4038
1  4039	00000E66  8A E0				 mov	 ah,al
1  4040	00000E68  80 E4	0F			 and	 ah,0fh
1  4041	00000E6B  80 FC	09			 cmp	 ah,9
1  4042	00000E6E  76 03				 jbe	 cifra0
1  4043	00000E70  80 C4	07				 add	 ah,'A'-'9'-1
1  4044	00000E73				 cifra0:
1  4045	00000E73  80 C4	30			 add	 ah,'0'
1  4046	00000E76  C0 E8	04			 shr	 al,4
1  4047	00000E79  3C 09				 cmp	 al,9
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 72
DarkX.ASM



1  4048	00000E7B  76 02				 jbe	 cifra1
1  4049	00000E7D  04 07					 add	 al,'A'-'9'-1
1  4050	00000E7F				 cifra1:
1  4051	00000E7F  04 30				 add	 al,'0'
1  4052	00000E81  C3				 ret
1  4053
1  4054	00000E82			 bin_to_hex	 endp
1  4055
1  4056					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4057
   4058					 INCLUDE		 cback32.inc	 ; call-back's 32 bit code
1  4059	00000E82			 callback_pm:
1  4060	00000E82  FA				 cli
1  4061						 ; preparamos los datos	de entrada para	el call-back
1  4062	00000E83  66| 2E: A1 00000004r		 mov	 ax,cs:D32_SEL
1  4063	00000E8A  8E D8				 mov	 ds,ax
1  4064	00000E8C  8E D0				 mov	 ss,ax
1  4065	00000E8E  BB 00000000s			 mov	 ebx,txcode
1  4066	00000E93  C1 E3	04			 shl	 ebx,4
1  4067						 ASSUME	 DS:txcode
1  4068						 ; puntero a la	estructura de call-backs
1  4069	00000E96  0F B7	83 00000690r		 movzx	 eax,word ptr [ebx+callback_code]
1  4070						 ; DS:ESI -> real mode stack frame (SS:SP)
1  4071	00000E9D  0F B7	8B 00000692r		 movzx	 ecx,word ptr [ebx+pila_real]	; real mode SP
1  4072	00000EA4  0F B7	B3 00000694r		 movzx	 esi,word ptr [ebx+pila_real+2]	; real mode SS
1  4073	00000EAB  8B D6				 mov	 edx,esi
1  4074	00000EAD  8B E9				 mov	 ebp,ecx
1  4075	00000EAF  C1 E6	04			 shl	 esi,4
1  4076	00000EB2  03 F1				 add	 esi,ecx
1  4077						 ; ES:EDI -> real mode call structure
1  4078	00000EB4  B9 00000000s			 mov	 ecx,txdata
1  4079	00000EB9  C1 E1	04			 shl	 ecx,4
1  4080						 ASSUME	 DS:txdata
1  4081	00000EBC  8B BC	01 00000D08r		 mov	 edi,[ecx+eax+callback_data.rm_call_struc.loffset]   ; real mode
1  4082	00000EC3  8E 84	01 00000D0Cr		 mov	 es,[ecx+eax+callback_data.rm_call_struc.selector]   ; call struc.
1  4083						 ; SS:SP de real y CS:IP del call-back a la estructura
1  4084	00000ECA  66| 26: 89 6F	2E		 mov	 es:[edi.rm_sp],bp
1  4085	00000ECF  66| 26: 89 57	30		 mov	 es:[edi.rm_ss],dx
1  4086	00000ED4  66| 8B 94 01	      +		 mov	 dx,[ecx+eax+callback_data.rm_entry_point]
   4087		  00000D00r
1  4088	00000EDC  66| 26: 89 57	2A		 mov	 es:[edi.rm_ip],dx
1  4089	00000EE1  66| 26: C7 47	2C    +		 mov	 es:[edi.rm_cs],txcode
   4090		  0000s
1  4091						 ; SS:ESP -> locked protected mode API stack
1  4092					 ;	  mov	  esp,txpila
1  4093					 ;	  shl	  esp,4
1  4094					 ;	  add	  esp,size tx_pila-4*(PM_STACKSIZE/2)  ; we are	not using stack	before this
1  4095	00000EE8  8B A1	00000520r		 mov	 esp,[ecx+pm_esp]
1  4096	00000EEE  8E 91	0000037Er		 mov	 ss,[ecx+pm_ss]
1  4097	00000EF4  1E 53				 push	 ds ebx
1  4098	00000EF6  9C				 pushfd		 ; procedure will return with IRETD
1  4099	00000EF7  FF 9C	01 00000D02r		 call	 fword ptr [ecx+eax+callback_data.pm_proc_to_call]
1  4100
1  4101						 ; ES:EDI -> real mode call structure to restore
1  4102	00000EFE  5B 1F				 pop	 ebx ds
1  4103						 ; preparamos CS,IP,SS,SP y FLAGS de la	estructura para	modo real
1  4104						 ASSUME	 DS:txcode
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 73
DarkX.ASM



1  4105	00000F00  26: 8B 47 2A			 mov	 eax,dword ptr es:[edi.rm_ip]
1  4106	00000F04  89 83	00000686r		 mov	 [ebx+new_code],eax
1  4107	00000F0A  26: 8B 47 2E			 mov	 eax,dword ptr es:[edi.rm_sp]
1  4108	00000F0E  89 83	0000068Ar		 mov	 [ebx+new_stack],eax
1  4109	00000F14  66| 26: 8B 47	20		 mov	 ax,es:[edi.rm_flags]
1  4110	00000F19  66| 89 83 0000068Er		 mov	 [ebx+new_flags],ax
1  4111
1  4112						 ; saltamos a modo real	de nuevo
1  4113	00000F20  66| C7 83 00000019r +		 mov	 word ptr [ebx+saltito+1],offset cback16_return
   4114		  0645r
1  4115	00000F29  66| C7 83 0000001Br +		 mov	 word ptr [ebx+saltito+3],txcode
   4116		  0000s
1  4117						 ASSUME	 DS:txdata
1  4118	00000F32  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  4119	00000F39  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4120	00000F40  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
1  4121	00000F47  67| FF 36 0538r		 push	 dword ptr ret_real_address
1  4122	00000F4C  CB				 retf
1  4123
   4124					 INCLUDE		 int21oem.inc
1  4125					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4126					 ; INT 21h Standard DOS	Services
1  4127					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4128	00000F4D			 tx_int21h:
1  4129	00000F4D  80 FC	3F				 cmp	 ah,3Fh			 ; read	from file
1  4130	00000F50  0F 84	00000188			 jz	 read_file
1  4131	00000F56  80 FC	40				 cmp	 ah,40h			 ; write to file
1  4132	00000F59  0F 84	00000222			 jz	 write_file
1  4133	00000F5F  80 FC	3D				 cmp	 ah,3Dh			 ; open	existing file
1  4134	00000F62  0F 84	0000014B			 jz	 generic_file_service
1  4135	00000F68  80 FC	3C				 cmp	 ah,3Ch			 ; create file
1  4136	00000F6B  0F 84	00000142			 jz	 generic_file_service
1  4137	00000F71  80 FC	39				 cmp	 ah,39h			 ; create subdirectory
1  4138	00000F74  0F 84	00000139			 jz	 generic_file_service
1  4139	00000F7A  80 FC	3A				 cmp	 ah,3Ah			 ; remove subdirectory
1  4140	00000F7D  0F 84	00000130			 jz	 generic_file_service
1  4141	00000F83  80 FC	3B				 cmp	 ah,3Bh			 ; change subdirectory
1  4142	00000F86  0F 84	00000127			 jz	 generic_file_service
1  4143	00000F8C  80 FC	41				 cmp	 ah,41h			 ; delete file
1  4144	00000F8F  0F 84	0000011E			 jz	 generic_file_service
1  4145	00000F95  66| 3D 4300				 cmp	 ax,4300h		 ; get file attributes
1  4146	00000F99  0F 84	00000114			 jz	 generic_file_service
1  4147	00000F9F  66| 3D 4301				 cmp	 ax,4301h		 ; set file attributes
1  4148	00000FA3  0F 84	0000010A			 jz	 generic_file_service
1  4149	00000FA9  80 FC	4E				 cmp	 ah,4Eh			 ; find	first matching file
1  4150	00000FAC  0F 84	00000101			 jz	 generic_file_service
1  4151	00000FB2  80 FC	5B				 cmp	 ah,5Bh			 ; create new file
1  4152	00000FB5  0F 84	000000F8			 jz	 generic_file_service
1  4153
1  4154	00000FBB  80 FC	09				 cmp	 ah,9			 ; write to standard output
1  4155	00000FBE  0F 84	00000098			 je	 print_string
1  4156	00000FC4  80 FC	62				 cmp	 ah,62h			 ; get PSP selector
1  4157	00000FC7  0F 84	0000024E			 jz	 get_psp_sel
1  4158	00000FCD  80 FC	4C				 cmp	 ah,4Ch			 ; end program
1  4159	00000FD0  74 22					 je	 fin_programa
1  4160	00000FD2  1E					 push	 ds
1  4161	00000FD3  2E: 8E 1D 0000000Cr			 mov	 ds,cs:D16_SEL
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 74
DarkX.ASM



1  4162							 ASSUME	 DS:txdata
1  4163	00000FDA  67| F6 06 0341r 02			 test	 system_type,2
1  4164	00000FE0  1F					 pop	 ds
1  4165	00000FE1  75 08					 jnz	 dpmi_int21_pass
1  4166	00000FE3  50					 push	 eax	    ; si no, la	tratamos con el	handler	normal
1  4167	00000FE4  B0 21					 mov	 al,21h
1  4168	00000FE6  E9 FFFFF9B0				 jmp	 real_int
1  4169
1  4170	00000FEB					 dpmi_int21_pass:
1  4171	00000FEB  9C					 pushfd
1  4172	00000FEC  2E: FF 1D 00001FDEr			 call	 fword ptr cs:[idt+21h*6]
1  4173	00000FF3  CF					 iretd
1  4174
1  4175					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4176					 ; DOS Program Termination Service
1  4177					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4178	00000FF4			 fin_programa:
1  4179	00000FF4  83 C4	0C				 add	 esp,3*4
1  4180	00000FF7  9C					 pushfd
1  4181	00000FF8  2E: FF 35 00000000r			 push	 dword ptr cs:C32_sel
1  4182							 pushd	 salida
2  4183	00000FFF  68				 db 68h
2  4184	00001000  1E45r	0000			 dw offset salida,0
1  4185	00001004  CF					 iretd
1  4186
1  4187					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4188					 ; Common DOS RM Call
1  4189					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4190	00001005			 dos_int	 proc
1  4191					 ; INPUT -> BP = DS/ES value ; Registers as needed by INT 21H
1  4192	00001005  06				 push	 es
1  4193	00001006  16				 push	 ss
1  4194	00001007  07				 pop	 es
1  4195	00001008  33 FF				 xor	 edi,edi
1  4196	0000100A  57				 push	 edi
1  4197	0000100B  57				 push	 edi
1  4198	0000100C  57				 push	 edi
1  4199	0000100D  66| 55			 push	 bp
1  4200	0000100F  66| 55			 push	 bp
1  4201	00001011  66				 db	 66h		 ; <----- para WORD en segmento	de 32 bits
1  4202	00001012  66| 9C			 pushf
1  4203	00001014  60				 pushad
1  4204	00001015  8B FC				 mov	 edi,esp
1  4205	00001017  66| B8 0300			 mov	 ax,300h
1  4206	0000101B  B3 21				 mov	 bl,21h
1  4207	0000101D  33 C9				 xor	 ecx,ecx
1  4208	0000101F  CD 31				 int	 31h
1  4209	00001021  61				 popad
1  4210	00001022  66| 9D			 popf
1  4211	00001024  8D 64	24 10			 lea	 esp,[esp+4*4]	 ; as¡ no modificamos los flags
1  4212	00001028  07				 pop	 es
1  4213	00001029  C3				 ret
1  4214	0000102A			 dos_int	 endp
1  4215
1  4216	0000102A			 copy_file_name	 proc
1  4217					 ; INPUT -> DS:EDX -> ASCIIZ string
1  4218	0000102A  52 06	57 51 50		 push	 edx es	edi ecx	eax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 75
DarkX.ASM



1  4219						 ; copiamos el nombre del archivo a 'print_buffer'
1  4220	0000102F  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4221	00001036  BF 00000000s			 mov	 edi,txcode32
1  4222	0000103B  C1 E7	04			 shl	 edi,4
1  4223	0000103E  81 C7	0000388Ar		 add	 edi,offset print_buffer
1  4224	00001044  B9 00000080			 mov	 ecx,128
1  4225	00001049				 copy_name:
1  4226	00001049  8A 02					 mov	 al,[edx]
1  4227	0000104B  26: 88 07				 mov	 es:[edi],al
1  4228	0000104E  0A C0					 or	 al,al
1  4229	00001050  74 04					 jz	 end_of_name
1  4230	00001052  47					 inc	 edi
1  4231	00001053  42					 inc	 edx
1  4232	00001054  E2 F3				 loop	 copy_name
1  4233	00001056				 end_of_name:
1  4234	00001056  58 59	5F 07 5A		 pop	 eax ecx edi es	edx
1  4235	0000105B  C3				 ret
1  4236	0000105C			 copy_file_name	 endp
1  4237
1  4238					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4239					 ; DOS Write to	Standard Device	Service
1  4240					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4241	0000105C			 print_string:
1  4242	0000105C  60					 pushad
1  4243	0000105D  06					 push	 es
1  4244	0000105E  8B F2					 mov	 esi,edx
1  4245	00001060					 print_another_piece:
1  4246	00001060  2E: 8E 05 00000004r			 mov	 es,cs:D32_SEL
1  4247	00001067  BF 00000000s				 mov	 edi,txcode32
1  4248	0000106C  C1 E7	04				 shl	 edi,4
1  4249	0000106F  81 C7	0000388Ar			 add	 edi,offset print_buffer
1  4250	00001075  B9 000007D1				 mov	 ecx,80*25+1
1  4251	0000107A					 copy_string:
1  4252	0000107A  80 3E	24					 cmp	 byte ptr [esi],'$'
1  4253	0000107D  74 1C						 je	 string_copied
1  4254	0000107F  A4						 movsb
1  4255	00001080  E2 F8					 loop	 copy_string
1  4256	00001082  26: C6 07 24				 mov	 byte ptr es:[edi],'$'
1  4257	00001086  57					 push	 edi
1  4258	00001087  B4 09					 mov	 ah,9
1  4259	00001089  BA 0000388Ar				 mov	 edx,offset print_buffer
1  4260	0000108E  BD 00000000s				 mov	 ebp,txcode32
1  4261	00001093  E8 FFFFFF6D				 call	 dos_int
1  4262	00001098  5F					 pop	 edi
1  4263	00001099  EB C5					 jmp	 print_another_piece
1  4264	0000109B					 string_copied:
1  4265	0000109B  26: C6 07 24				 mov	 byte ptr es:[edi],'$'
1  4266	0000109F  B4 09					 mov	 ah,9
1  4267	000010A1  BA 0000388Ar				 mov	 edx,offset print_buffer
1  4268	000010A6  BD 00000000s				 mov	 ebp,txcode32
1  4269	000010AB  E8 FFFFFF55				 call	 dos_int
1  4270	000010B0  07					 pop	 es
1  4271	000010B1  61					 popad
1  4272	000010B2  CF					 iretd
1  4273
1  4274					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4275					 ; Disk	Services
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 76
DarkX.ASM



1  4276					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4277	000010B3			 generic_file_service:
1  4278					 ; Translates DS:EDX to	DS:DX in DOS memory passing/returning all registers
1  4279					 ; to/from DOS
1  4280	000010B3  60				 pushad
1  4281	000010B4  06				 push	 es
1  4282	000010B5  E8 FFFFFF70			 call	 copy_file_name
1  4283	000010BA  BA 0000388Ar			 mov	 edx,offset print_buffer
1  4284	000010BF  BD 00000000s			 mov	 ebp,txcode32
1  4285	000010C4  E8 FFFFFF3C			 call	 dos_int
1  4286	000010C9  9C				 pushfd
1  4287	000010CA  59				 pop	 ecx
1  4288	000010CB  80 E1	01			 and	 cl,1
1  4289	000010CE  80 64	24 2C FE		 and	 byte ptr ss:[esp+11*4],0FEh
1  4290	000010D3  08 4C	24 2C			 or	 byte ptr ss:[esp+11*4],cl
1  4291	000010D7  89 44	24 20			 mov	 ss:[esp+8*4],eax
1  4292	000010DB  07				 pop	 es
1  4293	000010DC  61				 popad
1  4294	000010DD  CF				 iretd
1  4295
1  4296	000010DE			 read_file:
1  4297	000010DE  80 64	24 08 FE		 and	 byte ptr ss:[esp+2*4],0FEh
1  4298	000010E3  60				 pushad
1  4299	000010E4  06 1E				 push	 es ds
1  4300	000010E6  1E				 push	 ds
1  4301	000010E7  07				 pop	 es
1  4302	000010E8  51				 push	 ecx
1  4303	000010E9  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  4304	000010F0  8B FA				 mov	 edi,edx
1  4305	000010F2  33 C0				 xor	 eax,eax	 ; INICIO -> 0 bytes le¡dos
1  4306	000010F4  C1 E9	0F			 shr	 ecx,15		 ; 32Kb
1  4307	000010F7  0B C9				 or	 ecx,ecx
1  4308	000010F9  74 1D				 jz	 dont_read_blocks
1  4309	000010FB				 read_32K_blocks:
1  4310	000010FB  50 51					 push	 eax ecx
1  4311	000010FD  66| B9 8000				 mov	 cx,8000h
1  4312	00001101  E8 0000003F				 call	 read_block
1  4313	00001106  59					 pop	 ecx
1  4314	00001107  72 34					 jc	 read_error
1  4315	00001109  3D 00008000				 cmp	 eax,8000h
1  4316	0000110E  75 28					 jnz	 no_resto3
1  4317	00001110  58					 pop	 eax
1  4318	00001111  05 00008000				 add	 eax,8000h
1  4319	00001116  E2 E3				 loop	 read_32K_blocks
1  4320	00001118				 dont_read_blocks:
1  4321	00001118  59				 pop	 ecx
1  4322	00001119  51				 push	 ecx
1  4323	0000111A  81 E1	00007FFF		 and	 ecx,7FFFh
1  4324	00001120  0B C9				 or	 ecx,ecx
1  4325	00001122  74 0B				 jz	 no_resto2
1  4326	00001124  50				 push	 eax
1  4327	00001125  E8 0000001B			 call	 read_block
1  4328	0000112A  72 11				 jc	 read_error
1  4329	0000112C  5B				 pop	 ebx
1  4330	0000112D  03 C3				 add	 eax,ebx
1  4331	0000112F				 no_resto2:
1  4332	0000112F  59				 pop	 ecx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 77
DarkX.ASM



1  4333	00001130  1F 07				 pop	 ds es
1  4334	00001132  89 44	24 1C			 mov	 ss:[esp+7*4],eax
1  4335	00001136  61				 popad
1  4336	00001137  CF				 iretd
1  4337
1  4338	00001138				 no_resto3:
1  4339	00001138  5A				 pop	 edx
1  4340	00001139  03 C2				 add	 eax,edx
1  4341					 ;	  pop	  ecx
1  4342	0000113B  EB F2				 jmp	 no_resto2
1  4343
1  4344	0000113D				 read_error:
1  4345	0000113D  5B				 pop	 ebx
1  4346	0000113E  80 4C	24 34 01		 or	 byte ptr ss:[esp+13*4],1
1  4347	00001143  EB EA				 jmp	 no_resto2
1  4348
1  4349	00001145			 read_block	 proc
1  4350	00001145  BA 00000000r			 mov	 edx,offset disk_buffer
1  4351	0000114A  BD 00000000s			 mov	 ebp,disk
1  4352	0000114F  66| B8 3F00			 mov	 ax,3F00h
1  4353	00001153  57				 push	 edi
1  4354	00001154  E8 FFFFFEAC			 call	 dos_int
1  4355	00001159  5F				 pop	 edi
1  4356	0000115A  72 24				 jc	 no_resto
1  4357	0000115C  0F B7	C0			 movzx	 eax,ax
1  4358	0000115F  BE 00000000s			 mov	 esi,disk
1  4359	00001164  C1 E6	04			 shl	 esi,4
1  4360	00001167  81 C6	00000000r		 add	 esi,offset disk_buffer
1  4361	0000116D  8B C8				 mov	 ecx,eax
1  4362	0000116F  C1 E9	02			 shr	 ecx,2
1  4363	00001172  FC				 cld
1  4364	00001173  F3> A5			 rep	 movsd
1  4365	00001175  8B C8				 mov	 ecx,eax
1  4366	00001177  83 E1	03			 and	 ecx,3
1  4367	0000117A  0B C9				 or	 ecx,ecx
1  4368	0000117C  74 02				 jz	 no_resto
1  4369	0000117E  F3> A4			 rep	 movsb
1  4370	00001180				 no_resto:
1  4371	00001180  C3				 ret
1  4372	00001181			 read_block	 endp
1  4373
1  4374	00001181			 write_file:
1  4375	00001181  80 64	24 08 FE		 and	 byte ptr ss:[esp+2*4],0FEh
1  4376	00001186  60				 pushad
1  4377	00001187  06 1E				 push	 es ds
1  4378	00001189  51				 push	 ecx
1  4379	0000118A  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
1  4380	00001191  8B F2				 mov	 esi,edx
1  4381	00001193  33 C0				 xor	 eax,eax	 ; INICIO -> 0 bytes le¡dos
1  4382	00001195  C1 E9	0F			 shr	 ecx,15		 ; 32Kb
1  4383	00001198  0B C9				 or	 ecx,ecx
1  4384	0000119A  74 1E				 jz	 dont_write_blocks
1  4385	0000119C				 write_32K_blocks:
1  4386	0000119C  50 51					 push	 eax ecx
1  4387	0000119E  B9 00008000				 mov	 ecx,8000h
1  4388	000011A3  E8 0000003F				 call	 write_block
1  4389	000011A8  59					 pop	 ecx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 78
DarkX.ASM



1  4390	000011A9  72 34					 jc	 write_error
1  4391	000011AB  3D 00008000				 cmp	 eax,8000h
1  4392	000011B0  75 28					 jnz	 no_resto5
1  4393	000011B2  58					 pop	 eax
1  4394	000011B3  05 00008000				 add	 eax,8000h
1  4395	000011B8  E2 E2				 loop	 write_32K_blocks
1  4396	000011BA				 dont_write_blocks:
1  4397	000011BA  59				 pop	 ecx
1  4398	000011BB  51				 push	 ecx
1  4399	000011BC  81 E1	00007FFF		 and	 ecx,7FFFh
1  4400	000011C2  0B C9				 or	 ecx,ecx
1  4401	000011C4  74 0B				 jz	 no_resto4
1  4402	000011C6  50				 push	 eax
1  4403	000011C7  E8 0000001B			 call	 write_block
1  4404	000011CC  72 11				 jc	 write_error
1  4405	000011CE  5B				 pop	 ebx
1  4406	000011CF  03 C3				 add	 eax,ebx
1  4407	000011D1				 no_resto4:
1  4408	000011D1  59				 pop	 ecx
1  4409	000011D2  1F 07				 pop	 ds es
1  4410	000011D4  89 44	24 1C			 mov	 ss:[esp+7*4],eax
1  4411	000011D8  61				 popad
1  4412	000011D9  CF				 iretd
1  4413
1  4414	000011DA				 no_resto5:
1  4415	000011DA  5A				 pop	 edx
1  4416	000011DB  03 C2				 add	 eax,edx
1  4417	000011DD  EB F2				 jmp	 no_resto4
1  4418
1  4419	000011DF				 write_error:
1  4420	000011DF  5B				 pop	 ebx
1  4421	000011E0  80 4C	24 34 01		 or	 byte ptr ss:[esp+13*4],1
1  4422	000011E5  EB EA				 jmp	 no_resto4
1  4423
1  4424	000011E7			 write_block	  proc
1  4425	000011E7  BF 00000000s			 mov	 edi,disk
1  4426	000011EC  C1 E7	04			 shl	 edi,4
1  4427	000011EF  81 C7	00000000r		 add	 edi,offset disk_buffer
1  4428	000011F5  51				 push	 ecx
1  4429	000011F6  C1 E9	02			 shr	 ecx,2
1  4430	000011F9  FC				 cld
1  4431	000011FA  F3> A5			 rep	 movsd
1  4432	000011FC  58				 pop	 eax
1  4433	000011FD  8B C8				 mov	 ecx,eax
1  4434	000011FF  83 E1	03			 and	 ecx,3
1  4435	00001202  F3> A4			 rep	 movsb
1  4436	00001204  BA 00000000r			 mov	 edx,offset disk_buffer
1  4437	00001209  8B C8				 mov	 ecx,eax
1  4438	0000120B  BD 00000000s			 mov	 ebp,disk
1  4439	00001210  B4 40				 mov	 ah,40h
1  4440	00001212  E8 FFFFFDEE			 call	 dos_int
1  4441	00001217  0F B7	C0			 movzx	 eax,ax
1  4442	0000121A  C3				 ret
1  4443	0000121B			 write_block	  endp
1  4444
1  4445	0000121B			 get_psp_sel:
1  4446	0000121B  1E				 push	 ds
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 79
DarkX.ASM



1  4447	0000121C  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
1  4448	00001223  66| 67| 8B 1E	0335r		 mov	 bx,psp_selector
1  4449	00001229  1F				 pop	 ds
1  4450	0000122A  CF				 iretd
1  4451
   4452
   4453					 INCLUDE		 memmgr.inc	 ; Memory Manager by Teknik
1  4454					 ; NOTE: All procedures	are called with	DS = 4Gb data segment
1  4455
1  4456					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4457					 ; file: memmgr.asm
1  4458					 ;
1  4459					 ;  Memory manager for Trouble's DOS extender.
1  4460					 ;
1  4461					 ;	 by Teknik/Trouble, November of	1997
1  4462					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4463
1  4464					 ;  All	block lengths are a multiple of	4.
1  4465
1  4466	0000122B			 THEAP	 struc
1  4467
1  4468	00000000  01*(????????)		 start	 dd	 ?		 ; ptr to first	block of heap
1  4469	00000004  01*(????????)		 hlen	 dd	 ?		 ; length of heap
1  4470
1  4471	00000008				 ends
1  4472
1  4473	0000122B			 TBLOCK	 struc
1  4474
1  4475	00000000  01*(????????)		 blen	 dd	 ?		 ; block length, without this header
1  4476	00000004  01*(??)		 status	 db	 ?		 ; 'A' allocated, 'F' free
1  4477	00000005  01*(??)		 more	 db	 ?		 ; 'M' more blocks, 'E'	end of heap
1  4478	00000006  01*(????)		 sign	 dw	 ?		 ; block signature "TX", not reversed as TASM does
1  4479	00000008  01*(????????)		 prev	 dd	 ?		 ; offset of previous block header, origin DS
1  4480	0000000C  01*(????????)		 next	 dd	 ?		 ; offset of next block	header,	origin DS
1  4481
1  4482	00000010				 ends
1  4483
1  4484					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4485					 ; Initializes heap. All other procedures assume that this is the first	proc
1  4486					 ; called, just	before doing something.
1  4487					 ;
1  4488					 ;  parameters:
1  4489					 ;    eax - ptr	to heap	info (8	bytes required)
1  4490					 ;    ebx - address of memory (first block)
1  4491					 ;    ecx - length of heap (including headers) (=length	of first block)
1  4492					 ;
1  4493					 ;  modifies:
1  4494					 ;    ecx, eax,	ebx, edx
1  4495					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4496
1  4497	0000122B			 initheap	 proc
1  4498
1  4499	0000122B  8B D3				 mov	 edx, ebx		 ; align heap start...
1  4500	0000122D  83 C3	03			 add	 ebx, 3
1  4501	00001230  80 E3	FC			 and	 bl, 0fch
1  4502	00001233  2B D3				 sub	 edx, ebx		 ; ...and adjust the length too
1  4503	00001235  2B CA				 sub	 ecx, edx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 80
DarkX.ASM



1  4504	00001237  83 C1	03			 add	 ecx, 3
1  4505	0000123A  80 E1	FC			 and	 cl, 0fch
1  4506
1  4507	0000123D  89 48	04			 mov	 [eax.hlen], ecx
1  4508	00001240  83 E9	10			 sub	 ecx, 16
1  4509	00001243  89 0B				 mov	 [ebx.blen], ecx
1  4510	00001245  C7 43	04 58544546		 mov	 dword ptr [ebx.status], 'XTEF'	 ; free, end, signature...
1  4511	0000124C  33 C9				 xor	 ecx, ecx		 ; ... (TASM reverses this strings :( )
1  4512	0000124E  89 4B	08			 mov	 [ebx.prev], ecx
1  4513	00001251  89 4B	0C			 mov	 [ebx.next], ecx
1  4514
1  4515	00001254  89 18				 mov	 [eax.start], ebx	 ; saves ptr to	the first block
1  4516
1  4517	00001256  C3				 ret
1  4518
1  4519	00001257			 initheap	 endp
1  4520
1  4521					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4522					 ; Adds	another	block of heap, as heap may not be continuous. This can be
1  4523					 ; done	at any time.
1  4524					 ;
1  4525					 ;  parameters:
1  4526					 ;    eax - ptr	to heap	info
1  4527					 ;    ebx - address of the new block
1  4528					 ;    ecx - length of new block	(including headers)
1  4529					 ;
1  4530					 ;  modifies:
1  4531					 ;    eax, ebx,	ecx, edx
1  4532					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4533
1  4534	00001257			 addheap proc
1  4535
1  4536	00001257  8B D3				 mov	 edx, ebx		 ; align new block start...
1  4537	00001259  83 C3	03			 add	 ebx, 3
1  4538	0000125C  80 E3	FC			 and	 bl, 0fch
1  4539	0000125F  2B D3				 sub	 edx, ebx		 ; ...and adjust the length too
1  4540	00001261  2B CA				 sub	 ecx, edx
1  4541	00001263  83 C1	03			 add	 ecx, 3
1  4542	00001266  80 E1	FC			 and	 cl, 0fch
1  4543
1  4544	00001269  8B 10				 mov	 edx, [eax.start]
1  4545	0000126B  01 48	04			 add	 [eax.hlen], ecx	 ; calc	new heap length
1  4546	0000126E  80 7A	05 45		 ah_lp:	 cmp	 [edx.more], 'E'	 ; searchs last	block
1  4547	00001272  74 05				 je	 ah_add
1  4548	00001274  8B 52	0C			 mov	 edx, [edx.next]
1  4549	00001277  EB F5				 jmp	 short ah_lp
1  4550
1  4551	00001279  C6 42	05 4D		 ah_add: mov	 [edx.more], 'M'	 ; add the new free block
1  4552	0000127D  89 5A	0C			 mov	 [edx.next], ebx
1  4553	00001280  83 E9	10			 sub	 ecx, 16
1  4554	00001283  89 0B				 mov	 [ebx.blen], ecx
1  4555	00001285  C7 43	04 58544546		 mov	 dword ptr [ebx.status], 'XTEF'
1  4556	0000128C  89 53	08			 mov	 [ebx.prev], edx
1  4557	0000128F  C7 43	0C 00000000		 mov	 [ebx.next], 0
1  4558
1  4559	00001296  83 C3	10			 add	 ebx, 16		 ; ebx -> ptr to *data area*
1  4560	00001299  E8 0000005A			 call	 free			 ; quick way to	possibly collide blocks
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 81
DarkX.ASM



1  4561
1  4562	0000129E  C3				 ret
1  4563
1  4564	0000129F			 addheap endp
1  4565
1  4566					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4567					 ; Allocates a memory block.
1  4568					 ;
1  4569					 ;  parameters:
1  4570					 ;    eax - ptr	to heap	info
1  4571					 ;    ecx - length of block to allocate	in bytes
1  4572					 ;
1  4573					 ;  returns:
1  4574					 ;    ebx - ptr	to memory or NULL if not enought memory
1  4575					 ;    ecx - real length	of block (rounded up to	a four multiple)
1  4576					 ;
1  4577					 ;  modifies:
1  4578					 ;    eax
1  4579					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4580
1  4581	0000129F			 malloc	 proc
1  4582
1  4583	0000129F  8B 18				 mov	 ebx, [eax.start]	 ; search a free block
1  4584	000012A1  83 C1	03			 add	 ecx, 3			 ; round up to multiple	of 4
1  4585	000012A4  80 E1	FC			 and	 cl, 0fch
1  4586	000012A7  80 7B	04 46		 m_lp:	 cmp	 byte ptr [ebx.status],	'F'
1  4587	000012AB  75 3D				 jne	 m_next
1  4588	000012AD  39 0B				 cmp	 dword ptr [ebx.blen], ecx
1  4589	000012AF  72 39				 jb	 m_next
1  4590
1  4591	000012B1  83 C1	10			 add	 ecx, 16		 ; allocates block
1  4592	000012B4  39 0B				 cmp	 dword ptr [ebx.blen], ecx    ;	if the remainder is less than
1  4593	000012B6  72 28				 jb	 dont_split		 ; ... 16 don't	split the block
1  4594
1  4595	000012B8  8B 03				 mov	 eax, [ebx.blen]	 ; ebx + ecx ->	ptr to new block
1  4596	000012BA  2B C1				 sub	 eax, ecx		 ; ecx = len of	allocated block	+ 16
1  4597	000012BC  89 04	0B			 mov	 [ebx +	ecx.blen], eax
1  4598	000012BF  8B 43	04			 mov	 eax, dword ptr	[ebx.status]	 ; move	status,	more and sign
1  4599	000012C2  89 44	0B 04			 mov	 dword ptr [ebx	+ ecx.status], eax
1  4600	000012C6  89 5C	0B 08			 mov	 [ebx +	ecx.prev], ebx
1  4601	000012CA  8B 43	0C			 mov	 eax, [ebx.next]
1  4602	000012CD  89 44	0B 0C			 mov	 [ebx +	ecx.next], eax
1  4603
1  4604	000012D1  C6 43	05 4D			 mov	 [ebx.more], 'M'	 ; more	blocks
1  4605	000012D5  89 5B	0C			 mov	 [ebx.next], ebx	 ; adjust ptr to next block
1  4606	000012D8  01 4B	0C			 add	 [ebx.next], ecx
1  4607
1  4608	000012DB  83 E9	10			 sub	 ecx, 16
1  4609	000012DE  89 0B				 mov	 [ebx.blen], ecx
1  4610
1  4611	000012E0			 dont_split:
1  4612
1  4613	000012E0  C6 43	04 41			 mov	 [ebx.status], 'A'	 ; allocated block
1  4614
1  4615	000012E4  8B 0B				 mov	 ecx, [ebx.blen]	 ; ecx -> length of block
1  4616	000012E6  83 C3	10			 add	 ebx, 16		 ; ebx -> data area of block
1  4617
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 82
DarkX.ASM



1  4618	000012E9  C3				 ret
1  4619
1  4620	000012EA  80 7B	05 4D		 m_next: cmp	 byte ptr [ebx.more], 'M'
1  4621	000012EE  75 05				 jne	 m_end
1  4622	000012F0  8B 5B	0C			 mov	 ebx, [ebx.next]
1  4623	000012F3  EB B2				 jmp	 short m_lp
1  4624
1  4625	000012F5  33 DB			 m_end:	 xor	 ebx, ebx		 ; not enought memory
1  4626
1  4627	000012F7  C3				 ret
1  4628
1  4629	000012F8			 malloc	 endp
1  4630
1  4631					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4632					 ; Coalesces two memory	blocks.
1  4633					 ;
1  4634					 ;  parameters:
1  4635					 ;    eax - ptr	to lower block
1  4636					 ;    ebx - ptr	to upper block
1  4637					 ;
1  4638					 ;  modifies:
1  4639					 ;    ecx
1  4640					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4641
1  4642					 coalesce macro	label
1  4643
1  4644						 mov	 ecx, eax		 ; are two blocks adjacent?
1  4645						 add	 ecx, [eax.blen]
1  4646						 add	 ecx, 16
1  4647						 cmp	 ecx, ebx
1  4648						 jne	 label
1  4649
1  4650						 mov	 cl, [ebx.more]		 ; copy	more flag
1  4651						 mov	 [eax.more], cl
1  4652						 mov	 ecx, [ebx.next]	 ; relink blocks
1  4653						 mov	 [eax.next], ecx
1  4654						 mov	 [ecx.prev], eax
1  4655						 mov	 ecx, [ebx.blen]	 ; readjust length
1  4656						 add	 ecx, 16
1  4657						 add	 [eax.blen], ecx
1  4658
1  4659						 endm
1  4660
1  4661					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4662					 ; Frees a memory block.
1  4663					 ;
1  4664					 ;  parameters:
1  4665					 ;    ebx - ptr	to data	area of	block
1  4666					 ;
1  4667					 ;  modifies:
1  4668					 ;    eax, ecx,	ebx
1  4669					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4670
1  4671	000012F8			 free	 proc
1  4672
1  4673	000012F8  83 EB	10			 sub	 ebx, 16		 ; ebx -> ptr to block header
1  4674
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 83
DarkX.ASM



1  4675	000012FB  C6 43	04 46			 mov	 [ebx.status], 'F'	 ; free	it
1  4676
1  4677	000012FF  8B 43	08			 mov	 eax, [ebx.prev]	 ; coalesce with previous block
1  4678	00001302  0B C0				 or	 eax, eax
1  4679	00001304  74 29				 jz	 f_next
1  4680	00001306  80 78	04 46			 cmp	 [eax.status], 'F'	 ; is free? ...
1  4681	0000130A  75 23				 jne	 f_next
1  4682						 coalesce f_next		 ; ... yes, coalesce it
2  4683	0000130C  8B C8				 mov	 ecx, eax		 ; are two blocks adjacent?
2  4684	0000130E  03 08				 add	 ecx, [eax.blen]
2  4685	00001310  83 C1	10			 add	 ecx, 16
2  4686	00001313  3B CB				 cmp	 ecx, ebx
2  4687	00001315  75 18				 jne	 f_next
2  4688	00001317  8A 4B	05			 mov	 cl, [ebx.more]		 ; copy	more flag
2  4689	0000131A  88 48	05			 mov	 [eax.more], cl
2  4690	0000131D  8B 4B	0C			 mov	 ecx, [ebx.next]	 ; relink blocks
2  4691	00001320  89 48	0C			 mov	 [eax.next], ecx
2  4692	00001323  89 41	08			 mov	 [ecx.prev], eax
2  4693	00001326  8B 0B				 mov	 ecx, [ebx.blen]	 ; readjust length
2  4694	00001328  83 C1	10			 add	 ecx, 16
2  4695	0000132B  01 08				 add	 [eax.blen], ecx
1  4696	0000132D  8B D8				 mov	 ebx, eax		 ; now we have only first free block
1  4697
1  4698	0000132F  8B 43	0C		 f_next: mov	 eax, [ebx.next]	 ; coalesce with next block
1  4699	00001332  0B C0				 or	 eax, eax
1  4700	00001334  74 28				 jz	 f_end
1  4701	00001336  80 78	04 46			 cmp	 [eax.status], 'F'	 ; is free? ...
1  4702	0000133A  75 22				 jne	 f_end
1  4703	0000133C  93				 xchg	 eax, ebx
1  4704						 coalesce f_end			 ; ... yes, coalesce it
2  4705	0000133D  8B C8				 mov	 ecx, eax		 ; are two blocks adjacent?
2  4706	0000133F  03 08				 add	 ecx, [eax.blen]
2  4707	00001341  83 C1	10			 add	 ecx, 16
2  4708	00001344  3B CB				 cmp	 ecx, ebx
2  4709	00001346  75 16				 jne	 f_end
2  4710	00001348  8A 4B	05			 mov	 cl, [ebx.more]		 ; copy	more flag
2  4711	0000134B  88 48	05			 mov	 [eax.more], cl
2  4712	0000134E  8B 4B	0C			 mov	 ecx, [ebx.next]	 ; relink blocks
2  4713	00001351  89 48	0C			 mov	 [eax.next], ecx
2  4714	00001354  89 41	08			 mov	 [ecx.prev], eax
2  4715	00001357  8B 0B				 mov	 ecx, [ebx.blen]	 ; readjust length
2  4716	00001359  83 C1	10			 add	 ecx, 16
2  4717	0000135C  01 08				 add	 [eax.blen], ecx
1  4718
1  4719	0000135E			 f_end:
1  4720	0000135E  C3				 ret
1  4721
1  4722	0000135F			 free	 endp
1  4723
1  4724					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4725					 ; Resizes a memory block.
1  4726					 ;
1  4727					 ;  parameters:
1  4728					 ;    eax - ptr	to heap	info (needen for possible mallocs)
1  4729					 ;    ebx - ptr	to data	area of	block
1  4730					 ;    ecx - new	block size
1  4731					 ;
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 84
DarkX.ASM



1  4732					 ;  returns:
1  4733					 ;    ebx - new	block ptr, zero	if not enought memory
1  4734					 ;    ecx - new	block size, rounded up to a multiple of	four
1  4735					 ;
1  4736					 ;  modifies:
1  4737					 ;    eax, edx,	esi, edi
1  4738					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4739
1  4740	0000135F			 realloc proc
1  4741
1  4742	0000135F  83 EB	10			 sub	 ebx, 16		 ; ebx -> ptr to block header
1  4743
1  4744	00001362  83 C1	03			 add	 ecx, 3			 ; round size up
1  4745	00001365  80 E1	FC			 and	 cl, 0fch
1  4746	00001368  3B 0B				 cmp	 ecx, [ebx.blen]	 ; is new block	bigger or smaller?
1  4747	0000136A  0F 87	0000008B		 ja	 r_big
1  4748
1  4749						 ; ÍÍÍÍÍ new block size	<= old block size ÍÍÍÍÍ
1  4750
1  4751	00001370  53				 push	 ebx			 ; block won't change, so save ebx
1  4752
1  4753	00001371  8B 43	0C			 mov	 eax, [ebx.next]	 ; have	we a free block	after?
1  4754	00001374  0B C0				 or	 eax, eax
1  4755	00001376  74 38				 jz	 r_newf
1  4756	00001378  80 78	04 46			 cmp	 [eax.status], 'F'
1  4757	0000137C  75 32				 jne	 r_newf			 ; no, make a new free block (if we can)
1  4758
1  4759						 ; we have a free block	after the resized block, so we move it
1  4760
1  4761	0000137E  8B D3				 mov	 edx, ebx		 ; move	start of free block
1  4762	00001380  03 D1				 add	 edx, ecx
1  4763	00001382  83 C2	10			 add	 edx, 16
1  4764	00001385  89 53	0C			 mov	 [ebx.next], edx
1  4765	00001388  FF 33				 push	 [ebx.blen]
1  4766	0000138A  89 0B				 mov	 [ebx.blen], ecx
1  4767	0000138C  8B DA				 mov	 ebx, edx		 ; ebx -> ptr to free block
1  4768	0000138E  5A				 pop	 edx
1  4769	0000138F  03 10				 add	 edx, [eax.blen]
1  4770	00001391  2B D1				 sub	 edx, ecx		 ; edx = new length of block
1  4771	00001393  89 13				 mov	 [ebx.blen], edx
1  4772	00001395  8B 50	04			 mov	 edx, dword ptr	[eax.status]
1  4773	00001398  89 53	04			 mov	 dword ptr [ebx.status], edx
1  4774	0000139B  8B 50	08			 mov	 edx, [eax.prev]
1  4775	0000139E  89 53	08			 mov	 [ebx.prev], edx
1  4776	000013A1  8B 50	0C			 mov	 edx, [eax.next]
1  4777	000013A4  89 53	0C			 mov	 [ebx.next], edx
1  4778	000013A7  0B D2				 or	 edx, edx
1  4779	000013A9  74 47				 jz	 r_s_end
1  4780	000013AB  89 5A	08			 mov	 [edx.prev], ebx
1  4781	000013AE  EB 42				 jmp	 short r_s_end
1  4782
1  4783						 ; we create a new free	block if we can	(i.e. free space >= 16)
1  4784
1  4785	000013B0  8B 13			 r_newf: mov	 edx, [ebx.blen]	 ; calc	the difference
1  4786	000013B2  2B D1				 sub	 edx, ecx
1  4787	000013B4  83 EA	10			 sub	 edx, 16		 ; we can't resize the block 'cos free
1  4788	000013B7  72 39				 jc	 r_s_end		 ;  space is less than 16 bytes...
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 85
DarkX.ASM



1  4789	000013B9  89 54	0B 10			 mov	 [16 + ebx + ecx.blen],	edx	 ; make	a new block
1  4790	000013BD  8B 43	04			 mov	 eax, dword ptr	[ebx.status]
1  4791	000013C0  89 44	0B 14			 mov	 dword ptr [16 + ebx + ecx.status], eax
1  4792	000013C4  C6 44	0B 14 46		 mov	 [16 + ebx + ecx.status], 'F'
1  4793
1  4794	000013C9  C6 43	05 4D			 mov	 [ebx.more], 'M'	 ; update the resized block
1  4795	000013CD  89 0B				 mov	 [ebx.blen], ecx
1  4796
1  4797	000013CF  8B 43	0C			 mov	 eax, [ebx.next]	 ; relink the heap
1  4798	000013D2  89 44	0B 1C			 mov	 [16 + ebx + ecx.next],	eax
1  4799	000013D6  89 5B	0C			 mov	 [ebx.next], ebx
1  4800	000013D9  01 4B	0C			 add	 [ebx.next], ecx
1  4801	000013DC  83 43	0C 10			 add	 [ebx.next], 16
1  4802	000013E0  89 5C	0B 18			 mov	 [16 + ebx + ecx.prev],	ebx
1  4803	000013E4  0B C0				 or	 eax, eax
1  4804	000013E6  74 0A				 jz	 r_s_end
1  4805	000013E8  89 58	08			 mov	 [eax.prev], ebx
1  4806	000013EB  01 48	08			 add	 [eax.prev], ecx
1  4807	000013EE  83 40	08 10			 add	 [eax.prev], 16
1  4808
1  4809	000013F2			 r_s_end:
1  4810	000013F2  5B				 pop	 ebx			 ; ebx -> ptr to data area of resized
1  4811	000013F3  83 C3	10			 add	 ebx, 16		 ;  block
1  4812	000013F6  E9 00000091			 jmp	 r_end
1  4813
1  4814						 ; ÍÍÍÍÍ new block size	> old block size ÍÍÍÍÍ
1  4815
1  4816	000013FB  50			 r_big:	 push	 eax			 ; save	ptr to heap info
1  4817	000013FC  8B 43	0C			 mov	 eax, [ebx.next]	 ; check next block to see if is a free
1  4818	000013FF  80 78	04 46			 cmp	 [eax.status], 'F'	 ;  one	and if it's big	enought
1  4819	00001403  75 5E				 jne	 r_malloc
1  4820
1  4821	00001405  8B D1				 mov	 edx, ecx
1  4822	00001407  2B 13				 sub	 edx, [ebx.blen]
1  4823	00001409  83 EA	10			 sub	 edx, 16		 ; we can use the block	header too
1  4824	0000140C  39 10				 cmp	 [eax.blen], edx
1  4825	0000140E  72 53				 jb	 r_malloc
1  4826
1  4827	00001410  83 C4	04			 add	 esp, 4			 ; discard ptr to heap info
1  4828
1  4829						 ; we have a free block	just after the resized block and it's big
1  4830						 ;  enought, so	we use it
1  4831
1  4832	00001413  83 C2	10			 add	 edx, 16		 ; use all the block or	only a little
1  4833	00001416  39 10				 cmp	 [eax.blen], edx
1  4834	00001418  76 2D				 jbe	 r_kill
1  4835
1  4836	0000141A  89 0B				 mov	 [ebx.blen], ecx	  ; update lengths
1  4837	0000141C  2B 10				 sub	 edx, [eax.blen]
1  4838	0000141E  F7 DA				 neg	 edx			 ; eax -> ptr old, ebx -> ptr reloc.
1  4839	00001420  03 CB				 add	 ecx, ebx		 ; ecx -> ptr to new block location
1  4840	00001422  83 C1	10			 add	 ecx, 16
1  4841	00001425  89 11				 mov	 [ecx.blen], edx
1  4842
1  4843	00001427  8B 50	04			 mov	 edx, dword ptr	[eax.status]	 ; copy	old block to new block
1  4844	0000142A  89 51	04			 mov	 dword ptr [ecx.status], edx
1  4845
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 86
DarkX.ASM



1  4846	0000142D  89 4B	0C			 mov	 [ebx.next], ecx	 ; relink lists
1  4847	00001430  8B 50	08			 mov	 edx, [eax.prev]
1  4848	00001433  89 51	08			 mov	 [ecx.prev], edx
1  4849	00001436  8B 50	0C			 mov	 edx, [eax.next]
1  4850	00001439  89 51	0C			 mov	 [ecx.next], edx
1  4851	0000143C  8B 0B				 mov	 ecx, [ebx.blen]	 ; restore size
1  4852	0000143E  0B D2				 or	 edx, edx
1  4853	00001440  74 4A				 jz	 r_end
1  4854	00001442  89 42	08			 mov	 [edx.prev], eax
1  4855	00001445  EB 45				 jmp	 short r_end
1  4856
1  4857	00001447  8B 10			 r_kill: mov	 edx, [eax.blen]	 ; use all the block
1  4858	00001449  83 C2	10			 add	 edx, 16
1  4859	0000144C  01 13				 add	 [ebx.blen], edx
1  4860	0000144E  8B 50	0C			 mov	 edx, [eax.next]	 ; relink blocks
1  4861	00001451  89 53	0C			 mov	 [ebx.next], edx
1  4862	00001454  0B D2				 or	 edx, edx
1  4863	00001456  74 03				 jz	 r_nonext
1  4864	00001458  89 5A	08			 mov	 [edx.prev], ebx
1  4865	0000145B			 r_nonext:
1  4866	0000145B  8A 50	05			 mov	 dl, [eax.more]
1  4867	0000145E  88 53	05			 mov	 [ebx.more], dl
1  4868
1  4869	00001461  EB 29				 jmp	 short r_end
1  4870
1  4871						 ; we haven't a	free block after the resized block, or it's not	big
1  4872						 ;  enought, so	we call	malloc to get memory if	we can,	copy old
1  4873						 ;  block to new block and free	old block
1  4874
1  4875	00001463			 r_malloc:
1  4876	00001463  58				 pop	 eax			 ; restore ptr to heap info
1  4877	00001464  53				 push	 ebx			 ; we have to allocate another block
1  4878	00001465  E8 FFFFFE35			 call	 malloc			 ;  and	copy data to it
1  4879	0000146A  0B DB				 or	 ebx, ebx		 ; not enought memory, return zero ptr
1  4880	0000146C  74 1B				 jz	 r_notenought
1  4881	0000146E  8B FB				 mov	 edi, ebx		 ; copy	block
1  4882	00001470  5A				 pop	 edx			 ; don't destroy ebx ->	ptr to new block
1  4883	00001471  83 C2	10			 add	 edx, 16		 ; edx must point to data area
1  4884	00001474  8B F2				 mov	 esi, edx
1  4885	00001476  FC				 cld
1  4886	00001477  51				 push	 ecx
1  4887	00001478  C1 E9	02			 shr	 ecx, 2			 ; ecx is allways a multiple of	four
1  4888	0000147B  F3> A5			 rep	 movsd
1  4889	0000147D  87 D3				 xchg	 edx, ebx		 ; free	old block
1  4890	0000147F  E8 FFFFFE74			 call	 free
1  4891	00001484  8B DA				 mov	 ebx, edx
1  4892	00001486  59				 pop	 ecx			 ; end with ebx	-> ptr,	ecx -> length
1  4893	00001487  EB 03				 jmp	 short r_end
1  4894
1  4895	00001489			 r_notenought:
1  4896	00001489  83 C4	04			 add	 esp, 4			 ; just	exit with ebx =	0
1  4897
1  4898	0000148C			 r_end:
1  4899	0000148C  C3				 ret
1  4900
1  4901	0000148D			 realloc endp
1  4902
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 87
DarkX.ASM



1  4903					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4904					 ; Gets	memory info.
1  4905					 ;
1  4906					 ;  parameters:
1  4907					 ;    eax - ptr	to heap	info
1  4908					 ;
1  4909					 ;  returns:
1  4910					 ;    eax - maximum available block
1  4911					 ;    ecx - total available memory
1  4912					 ;
1  4913					 ;  modifies:
1  4914					 ;    ebx
1  4915					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4916
1  4917	0000148D			 getmeminfo	 proc
1  4918
1  4919	0000148D  8B 18				 mov	 ebx, [eax.start]	 ; walk	thought	the heap
1  4920	0000148F  33 C0				 xor	 eax, eax
1  4921	00001491  33 C9				 xor	 ecx, ecx
1  4922	00001493  80 7B	04 46		 gmi_lp: cmp	 [ebx.status], 'F'	 ; is free?
1  4923	00001497  75 08				 jne	 gmi_nxt
1  4924	00001499  39 03				 cmp	 [ebx.blen], eax	 ; get maximum available block
1  4925	0000149B  72 02				 jb	 gmi_c
1  4926	0000149D  8B 03				 mov	 eax, [ebx.blen]
1  4927	0000149F  03 0B			 gmi_c:	 add	 ecx, [ebx.blen]
1  4928	000014A1			 gmi_nxt:
1  4929	000014A1  80 7B	05 45			 cmp	 [ebx.more], 'E'
1  4930	000014A5  74 05				 je	 gmi_end
1  4931	000014A7  8B 5B	0C			 mov	 ebx, [ebx.next]
1  4932	000014AA  EB E7				 jmp	 short gmi_lp
1  4933
1  4934	000014AC			 gmi_end:
1  4935
1  4936	000014AC  C3				 ret
1  4937
1  4938	000014AD			 getmeminfo	 endp
1  4939					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4940
   4941
   4942					 INCLUDE		 initmem.inc
1  4943					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4944	000014AD			 init_dos_heap	 proc
1  4945					 ; DS =	D32_SEL
1  4946	000014AD  B8 00000000s			 mov	 eax,txcode32
1  4947	000014B2  C1 E0	04			 shl	 eax,4
1  4948	000014B5  BE 00002F20r			 mov	 esi,offset dos_pointers
1  4949	000014BA  03 F0				 add	 esi,eax
1  4950	000014BC  80 3E	00			 cmp	 byte ptr [esi],0
1  4951	000014BF  74 38				 jz	 no_more_heaps	 ; con 0 bloques, salimos
1  4952	000014C1  05 00002F18r			 add	 eax,offset dos_heap_info
1  4953	000014C6  8B 5E	01			 mov	 ebx,[esi+1]
1  4954	000014C9  8B 4E	05			 mov	 ecx,[esi+5]
1  4955	000014CC  E8 FFFFFD5A			 call	 initheap
1  4956	000014D1  33 C9				 xor	 ecx,ecx
1  4957	000014D3  8A 0E				 mov	 cl,[esi]
1  4958	000014D5  49				 dec	 ecx
1  4959	000014D6  74 21				 jz	 no_more_heaps
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 88
DarkX.ASM



1  4960	000014D8  83 C6	09			 add	 esi,9
1  4961	000014DB				 add_heaps:
1  4962	000014DB  51					 push	 ecx
1  4963	000014DC  B8 00000000s				 mov	 eax,txcode32
1  4964	000014E1  C1 E0	04				 shl	 eax,4
1  4965	000014E4  05 00002F18r				 add	 eax,offset dos_heap_info
1  4966	000014E9  8B 1E					 mov	 ebx,[esi]
1  4967	000014EB  8B 4E	04				 mov	 ecx,[esi+4]
1  4968	000014EE  E8 FFFFFD64				 call	 addheap
1  4969	000014F3  59					 pop	 ecx
1  4970	000014F4  83 C6	08				 add	 esi,8
1  4971	000014F7  E2 E2				 loop	 add_heaps
1  4972	000014F9				 no_more_heaps:
1  4973	000014F9  C3				 ret
1  4974	000014FA			 init_dos_heap	 endp
1  4975					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  4976	000014FA			 init_extended_heap	   proc
1  4977					 ; DS =	D32_SEL
1  4978						 ASSUME	 DS:txcode32
1  4979	000014FA  BE 00000000s			 mov	 esi,txcode32
1  4980	000014FF  C1 E6	04			 shl	 esi,4
1  4981	00001502  0F B6	8E 00003249r		 movzx	 ecx,byte ptr [esi+extended_pointers]
1  4982	00001509  0B C9				 or	 ecx,ecx
1  4983	0000150B  74 42				 jz	 extended_init_done	 ; si hay 0 bloques, salimos
1  4984	0000150D  51				 push	 ecx
1  4985	0000150E  B8 00003241r			 mov	 eax,offset extended_heap_info
1  4986	00001513  03 C6				 add	 eax,esi
1  4987	00001515  8B 9E	0000324Ar		 mov	 ebx,dword ptr [esi+extended_pointers+1]
1  4988	0000151B  8B 8E	0000324Er		 mov	 ecx,dword ptr [esi+extended_pointers+5]
1  4989	00001521  E8 FFFFFD05			 call	 initheap
1  4990	00001526  59				 pop	 ecx
1  4991	00001527  49				 dec	 ecx
1  4992	00001528  74 25				 jz	 extended_init_done
1  4993	0000152A					 make_xms_heap:
1  4994	0000152A  51						 push	 ecx
1  4995	0000152B  B8 00000000s					 mov	 eax,txcode32
1  4996	00001530  C1 E0	04					 shl	 eax,4
1  4997	00001533  05 00003241r					 add	 eax,offset extended_heap_info
1  4998	00001538  8B 9E	00003252r				 mov	 ebx,dword ptr [esi+9+extended_pointers]
1  4999	0000153E  8B 8E	00003256r				 mov	 ecx,dword ptr [esi+13+extended_pointers]
1  5000	00001544  E8 FFFFFD0E					 call	 addheap
1  5001	00001549  83 C6	08					 add	 esi,8
1  5002	0000154C  59						 pop	 ecx
1  5003	0000154D  E2 DB					 loop	 make_xms_heap
1  5004							 ASSUME	 DS:txdata
1  5005	0000154F				 extended_init_done:
1  5006	0000154F  C3				 ret
1  5007	00001550			 init_extended_heap	   endp
1  5008					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5009
   5010
   5011					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5012					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5013					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5014
   5015						 include filesys.inc		 ; Rutines per carregar	LEs
1  5016					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 89
DarkX.ASM



1  5017					 ; file: filesys.inc
1  5018					 ;
1  5019					 ;  TX32's file	system.
1  5020					 ;
1  5021					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1  5022					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5023
1  5024		  =0000			 READ_ONLY	 equ	 0		 ; access rights
1  5025		  =0001			 WRITE_ONLY	 equ	 1
1  5026		  =0002			 READ_WRITE	 equ	 2
1  5027
1  5028		  =0000			 SEEK_SET	 equ	 0		 ; start of file
1  5029		  =0001			 SEEK_CUR	 equ	 1		 ; current file	position
1  5030		  =0002			 SEEK_END	 equ	 2		 ; end of file
1  5031
1  5032					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5033					 ; Opens a file	with the desired access.
1  5034					 ;
1  5035					 ;  parameters:
1  5036					 ;    edx - pointer to file name to open
1  5037					 ;    al - access rights
1  5038					 ;
1  5039					 ;  returns:
1  5040					 ;    cf - set if error
1  5041					 ;    eax - handle of file
1  5042					 ;
1  5043					 ;  modifies:
1  5044					 ;    eax
1  5045					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5046
1  5047	00001550			 openfile	 proc
1  5048
1  5049	00001550  B4 3D				 mov	 ah, 3dh
1  5050	00001552  CD 21				 int	 21h
1  5051	00001554  C3				 ret
1  5052
1  5053	00001555			 openfile	 endp
1  5054
1  5055					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5056					 ; Reads from a	file.
1  5057					 ;
1  5058					 ;  parameters:
1  5059					 ;    edx - pointer to buffer
1  5060					 ;    ebx - file handle
1  5061					 ;    ecx - number of bytes to read
1  5062					 ;
1  5063					 ;  returns:
1  5064					 ;    cf - set if error
1  5065					 ;    eax - number of bytes readed
1  5066					 ;
1  5067					 ;  modifies:
1  5068					 ;    eax
1  5069					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5070
1  5071	00001555			 read		 proc
1  5072
1  5073	00001555  B4 3F				 mov	 ah, 3fh
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 90
DarkX.ASM



1  5074	00001557  CD 21				 int	 21h
1  5075	00001559  72 06				 jc	 r_exit
1  5076	0000155B  3B C1				 cmp	 eax, ecx		 ; Check if ecx	bytes have been	readed
1  5077	0000155D  F8				 clc				 ; Don't touch zero flag!
1  5078	0000155E  74 01				 je	 r_exit
1  5079	00001560  F9				 stc
1  5080	00001561			 r_exit:
1  5081	00001561  C3				 ret
1  5082
1  5083	00001562			 read		 endp
1  5084
1  5085					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5086					 ; Sets	current	file position
1  5087					 ;
1  5088					 ;  parameters:
1  5089					 ;    al - origin of move
1  5090					 ;    ebx - file handle
1  5091					 ;    edx - file position
1  5092					 ;
1  5093					 ;  returns:
1  5094					 ;    cf - set if error
1  5095					 ;    eax - new	file position
1  5096					 ;
1  5097					 ;  modifies:
1  5098					 ;    eax
1  5099					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5100
1  5101	00001562			 seek		 proc
1  5102
1  5103	00001562  B4 42				 mov	 ah, 42h
1  5104	00001564  51				 push	 ecx
1  5105	00001565  52				 push	 edx
1  5106	00001566  0F A4	D1 10			 shld	 ecx, edx, 16		 ; cx:dx <- file position
1  5107	0000156A  CD 21				 int	 21h
1  5108	0000156C  0F A4	C2 10			 shld	 edx, eax, 16
1  5109	00001570  8B C2				 mov	 eax, edx
1  5110	00001572  5A				 pop	 edx
1  5111	00001573  59				 pop	 ecx
1  5112	00001574  C3				 ret
1  5113
1  5114	00001575			 seek		 endp
1  5115
1  5116
   5117						 include loadle.inc
1  5118					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5119					 ; file: loadle.inc
1  5120					 ;
1  5121					 ;  Loads LE executable	files. Used by TX32 extender.
1  5122					 ;
1  5123					 ;	 by Xavier Rubio Jansana, a.k.a. Teknik	/ #Trouble# Team, July 1998
1  5124					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5125
1  5126		  =0001			 DOS_MEMORY	     equ     1		 ; Memory types
1  5127		  =0002			 XMS_MEMORY	     equ     2
1  5128
1  5129		  =0000			 E_FILE_ERROR	     equ     0		 ; Error codes
1  5130		  =0001			 E_NOT_LE	     equ     1
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 91
DarkX.ASM



1  5131		  =0002			 E_NOT_ENOUGH_MEM    equ     2
1  5132		  =0003			 E_UNSUPORTED_FEATURE equ    3
1  5133
1  5134					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5135					 ; Loads an LE file. First of all it skips the stub, and then loads it.
1  5136					 ;
1  5137					 ;  parameters:
1  5138					 ;    edx - pointer to file name to load
1  5139					 ;    ds - selector with zero base
1  5140					 ;    es - selector of 16-bit data segment
1  5141					 ;
1  5142					 ;  returns:
1  5143					 ;    cf - set on error
1  5144					 ;    eax - offset of entry point
1  5145					 ;
1  5146					 ;  modifies:
1  5147					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5148
1  5149	00001575			 LoadLE		 proc
1  5150
1  5151	00001575  FC				 cld
1  5152
1  5153	00001576  B0 00				 mov	 al, READ_ONLY
1  5154	00001578  E8 FFFFFFD3			 call	 openfile		 ; Opens the file and seeks LE header
1  5155	0000157D  0F 82	00000435		 jc	 of_error_loading
1  5156
1  5157						 ; ds, es -> 16-bit data segment
1  5158
1  5159	00001583  2E: 8E 1D 0000000Cr		 mov	 ds, [cs:D16_SEL]
1  5160	0000158A  67| A3 0ABFr			 mov	 [handle], eax
1  5161	0000158E  8B D8				 mov	 ebx, eax
1  5162	00001590  B9 00000002			 mov	 ecx, 2
1  5163	00001595  BA 00000AC7r			 mov	 edx, offset le_hdr
1  5164	0000159A  E8 FFFFFFB6			 call	 read
1  5165	0000159F  0F 82	00000419		 jc	 error_loading
1  5166
1  5167	000015A5  67| C7 06 0AC3r     +		 mov	 [le_offset], 0		 ; Default offset
   5168		  00000000
1  5169
1  5170	000015AE  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "ZM"; Let's see if	it has an stub
   5171		  5A4D
1  5172	000015B6  74 0A				 je	 it_has_stub
1  5173	000015B8  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "MZ"
   5174		  4D5A
1  5175	000015C0  75 4E				 jne	 check_le
1  5176
1  5177	000015C2			     it_has_stub:
1  5178	000015C2  B0 00				 mov	 al, SEEK_SET		 ; Get LE's possible offset
1  5179	000015C4  BA 0000003C			 mov	 edx, 3ch
1  5180	000015C9  E8 FFFFFF94			 call	 seek
1  5181	000015CE  0F 82	000003EA		 jc	 error_loading
1  5182
1  5183	000015D4  BA 00000AC3r			 mov	 edx, offset le_offset
1  5184	000015D9  B9 00000002			 mov	 ecx, 2
1  5185	000015DE  E8 FFFFFF72			 call	 read
1  5186	000015E3  0F 82	000003D5		 jc	 error_loading
1  5187
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 92
DarkX.ASM



1  5188	000015E9  B0 00				 mov	 al, SEEK_SET		 ; Skip	stub
1  5189	000015EB  67| 8B 16 0AC3r		 mov	 edx, [le_offset]
1  5190	000015F0  E8 FFFFFF6D			 call	 seek
1  5191	000015F5  0F 82	000003C3		 jc	 error_loading
1  5192
1  5193	000015FB  B9 00000002			 mov	 ecx, 2			 ; Get new header's signature
1  5194	00001600  BA 00000AC7r			 mov	 edx, offset le_hdr
1  5195	00001605  E8 FFFFFF4B			 call	 read
1  5196	0000160A  0F 82	000003AE		 jc	 error_loading
1  5197
1  5198	00001610			     check_le:
1  5199	00001610  66| 67| 81 3E	0AC7r +		 cmp	 [le_hdr.signature], "EL"; Check if it's an LE header
   5200		  454C
1  5201	00001618  0F 85	000003A7		 jne	 not_LE
1  5202
1  5203	0000161E  B9 000000C2			 mov	 ecx, size le_hdr - 2	 ; Ok. It's an LE header
1  5204	00001623  BA 00000AC9r			 mov	 edx, offset le_hdr + 2
1  5205	00001628  E8 FFFFFF28			 call	 read
1  5206	0000162D  0F 82	0000038B		 jc	 error_loading
1  5207
1  5208					     ; Up to here we have LE's header and starting offset. We continue
1  5209					     ; loading it.
1  5210
1  5211	00001633  B0 00				 mov	 al, SEEK_SET		 ; Load	object table
1  5212	00001635  67| 8B 16 0B07r		 mov	 edx, [le_hdr.off_object_tbl]
1  5213	0000163A  67| 03 16 0AC3r		 add	 edx, [le_offset]
1  5214	0000163F  E8 FFFFFF1E			 call	 seek
1  5215	00001644  0F 82	00000374		 jc	 error_loading
1  5216
1  5217	0000164A  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5218	0000164E  6B C0	18			 imul	 eax, size OBJECT
1  5219	00001651  8B C8				 mov	 ecx, eax
1  5220	00001653  BA 00000B8Br			 mov	 edx, offset object_tbl
1  5221	00001658  E8 FFFFFEF8			 call	 read
1  5222	0000165D  0F 82	0000035B		 jc	 error_loading
1  5223
1  5224					     ; Get memory for all the objects. This must be done BEFORE	the fixup.
1  5225
1  5226	00001663  BE 00000B8Br			 mov	 esi, offset object_tbl	 ; Start walking object	table
1  5227	00001668  67| C7 06 0CD5r     +		 mov	 [obj_handles_ptr], 0
   5228		  00000000
1  5229	00001671  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5230	00001675  67| A3 0CDDr			 mov	 [obj_count], eax
1  5231	00001679  67| C7 06 0CD9r     +		 mov	 [num_obj_handles], 0
   5232		  00000000
1  5233
1  5234						 ; ds -> 16-bit	data segment
1  5235						 ; es -> flat data segment (to do mem zeroing)
1  5236
1  5237	00001682  2E: 8E 05 00000014r		 mov	 es, [cs:DATA_SEL]
1  5238
1  5239	00001689			     get_memory:
1  5240
1  5241	00001689  8B 1E				     mov     ebx, [esi.virtual_size]	 ; Get memory (first try ext mem)
1  5242
1  5243					 ;  Allocates a	block of extended memory.
1  5244					 ;
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 93
DarkX.ASM



1  5245					 ;In:
1  5246					 ;  AX	   = 0501h
1  5247					 ;  BX:CX  = size of block in bytes (must be non-zero)
1  5248					 ;
1  5249					 ;Out:
1  5250					 ;  if successful:
1  5251					 ;    carry flag clear
1  5252					 ;    BX:CX  = linear address of allocated memory block
1  5253					 ;    SI:DI  = memory block handle (used to resize and free block)
1  5254					 ;
1  5255					 ;  if failed:
1  5256					 ;    carry flag set
1  5257
1  5258	0000168B  56				     push    esi
1  5259	0000168C  66| 8B CB			     mov     cx, bx			 ; bx:cx = size	in bytes
1  5260	0000168F  C1 EB	10			     shr     ebx, 16
1  5261	00001692  66| B8 0501			     mov     ax, 501h
1  5262	00001696  CD 31				     int     31h
1  5263	00001698  58				     pop     eax
1  5264	00001699  72 32				     jc	     not_enough_ext_mem
1  5265
1  5266	0000169B  67| 8B 16 0CD5r		     mov     edx, [obj_handles_ptr]	 ; Save	the handle
1  5267	000016A0  C1 E6	10			     shl     esi, 16
1  5268	000016A3  66| 8B F7			     mov     si, di
1  5269	000016A6  89 B4	D2 00000C7Br		     mov     [object_nfo.obj_handles + edx * 8 + edx], esi
1  5270	000016AD  C6 84	D2 00000C7Fr  +		     mov     [object_nfo.mem_type + edx	* 8 + edx], XMS_MEMORY
   5271		  02
1  5272	000016B5  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5273
1  5274	000016BA  8B F0				     mov     esi, eax			 ; Restore ptr to object table!
1  5275
1  5276	000016BC  8B FB				     mov     edi, ebx			 ; Get the real	address	@@
1  5277	000016BE  C1 E7	10			     shl     edi, 16
1  5278	000016C1  66| 8B F9			     mov     di, cx			 ; edi = ptr to	memory block
1  5279	000016C4  89 BC	D2 00000C80r		     mov     [object_nfo.obj_offset + edx * 8 +	edx], edi
1  5280
1  5281	000016CB  EB 3B				     jmp     we_have_it
1  5282
1  5283	000016CD				 not_enough_ext_mem:
1  5284
1  5285					 ;  Allocates low memory through DOS function 48h and allocates	it a descriptor.
1  5286					 ;
1  5287					 ;In:
1  5288					 ;  AX	   = 0100h
1  5289					 ;  BX	   = paragraphs	to allocate
1  5290					 ;
1  5291					 ;Out:
1  5292					 ;  if successful:
1  5293					 ;    carry flag clear
1  5294					 ;    AX     = real mode segment address
1  5295					 ;    DX     = protected mode selector for memory block
1  5296					 ;
1  5297					 ;  if failed:
1  5298					 ;    carry flag set
1  5299					 ;    AX     = DOS error code
1  5300					 ;    BX     = size of largest available block
1  5301
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 94
DarkX.ASM



1  5302	000016CD  53				     push    ebx			 ; bx =	# paragraphs
1  5303	000016CE  83 C3	0F			     add     ebx, 15
1  5304	000016D1  C1 EB	04			     shr     ebx, 4
1  5305	000016D4  66| B8 0100			     mov     ax, 100h
1  5306	000016D8  CD 31				     int     31h
1  5307	000016DA  5B				     pop     ebx
1  5308	000016DB  0F 82	000002EB		     jc	     not_enough_memory
1  5309
1  5310	000016E1  67| 8B 1E 0CD5r		     mov     ebx, [obj_handles_ptr]	 ; Save	the "handle"
1  5311	000016E6  66| 89 94 DB	      +		     mov     word ptr [object_nfo.obj_handles +	ebx * 8	+ ebx],	dx
   5312		  00000C7Br
1  5313	000016EE  C6 84	DB 00000C7Fr  +		     mov     [object_nfo.mem_type + ebx	* 8 + ebx], DOS_MEMORY
   5314		  01
1  5315	000016F6  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5316
1  5317	000016FB  0F B7	F8			     movzx   edi, ax			 ; Get the real	address	@@
1  5318	000016FE  C1 E7	04			     shl     edi, 4			 ; edi = ptr to	memory block
1  5319	00001701  89 BC	DB 00000C80r		     mov     [object_nfo.obj_offset + ebx * 8 +	ebx], edi
1  5320
1  5321	00001708				 we_have_it:
1  5322
1  5323	00001708  8B 0E				     mov     ecx, [esi.virtual_size]	 ; Zero-fill the memory
1  5324	0000170A  51				     push    ecx
1  5325	0000170B  C1 E9	02			     shr     ecx, 2
1  5326	0000170E  33 C0				     xor     eax, eax
1  5327	00001710  F3> AB			     rep     stosd
1  5328	00001712  59				     pop     ecx
1  5329	00001713  83 E1	03			     and     ecx, 3
1  5330	00001716  74 02				     jz	     end_of_fill
1  5331	00001718  F3> AA			     rep     stosb
1  5332
1  5333	0000171A				 end_of_fill:
1  5334
1  5335	0000171A  67| FF 06 0CD9r		     inc     [num_obj_handles]
1  5336	0000171F  83 C6	18			     add     esi, size OBJECT
1  5337
1  5338	00001722  67| FF 0E 0CDDr		 dec	 [obj_count]
1  5339	00001727  0F 85	FFFFFF5C		 jnz	 get_memory
1  5340
1  5341					     ; We have memory to load the pages. Load them!
1  5342
1  5343	0000172D  BE 00000B8Br			 mov	 esi, offset object_tbl	 ; Start walking object	table
1  5344	00001732  67| C7 06 0CD5r     +		 mov	 [obj_handles_ptr], 0
   5345		  00000000
1  5346	0000173B  67| A1 0B0Br			 mov	 eax, [le_hdr.obj_tbl_entries]
1  5347	0000173F  67| A3 0CDDr			 mov	 [obj_count], eax
1  5348
1  5349	00001743			     walk_object_table:
1  5350
1  5351						     ; ds -> 16-bit data segment
1  5352						     ; es -> who cares?
1  5353
1  5354	00001743  8B 46	0C			     mov     eax, [esi.page_map_index]
1  5355	00001746  48				     dec     eax			 ; It's	1-based
1  5356	00001747  67| A3 0CE1r			     mov     [curr_page], eax
1  5357	0000174B  67| F7 26 0AEFr		     mul     [le_hdr.page_size]
1  5358	00001750  8B D0				     mov     edx, eax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 95
DarkX.ASM



1  5359	00001752  67| 03 16 0B47r		     add     edx, [le_hdr.off_data_pages]; Offset from begin of	file
1  5360	00001757  B0 00				     mov     al, SEEK_SET
1  5361	00001759  67| 8B 1E 0ABFr		     mov     ebx, [handle]
1  5362	0000175E  E8 FFFFFDFF			     call    seek
1  5363	00001763  0F 82	00000255		     jc	     error_loading
1  5364
1  5365	00001769  67| A1 0CD5r			     mov     eax, [obj_handles_ptr]
1  5366	0000176D  8B 94	C0 00000C80r		     mov     edx, [object_nfo.obj_offset + eax * 8 + eax]
1  5367	00001774  8B 7E	10			     mov     edi, [esi.num_pages]
1  5368	00001777  67| FF 06 0CD5r		     inc     [obj_handles_ptr]
1  5369
1  5370						     ; ds -> flat data segment
1  5371						     ; es -> 16-bit data segment
1  5372
1  5373	0000177C  2E: 8E 1D 00000014r		     mov     ds, [cs:DATA_SEL]
1  5374	00001783  2E: 8E 05 0000000Cr		     mov     es, [cs:D16_SEL]
1  5375
1  5376	0000178A  0B FF				     or	     edi, edi
1  5377	0000178C  74 44				     jz	     no_pages
1  5378
1  5379	0000178E				 next_page:
1  5380
1  5381	0000178E  26: 67| 8B 0E	0AEFr			 mov	 ecx, [es:le_hdr.page_size]
1  5382	00001794  26: 67| FF 06	0CE1r			 inc	 [es:curr_page]			 ; Increment beforehand!
1  5383
1  5384	0000179A  26: 67| A1 0CE1r			 mov	 eax, [es:curr_page]
1  5385	0000179F  26: 67| 3B 06	0ADBr			 cmp	 eax, [es:le_hdr.memory_pages]	 ; File's last page?
1  5386	000017A5  75 08					 jne	 last_object_page?
1  5387
1  5388	000017A7  26: 67| 8B 0E	0AF3r			 mov	 ecx, [es:le_hdr.bytes_last_page]
1  5389
1  5390	000017AD  EB 0F					 jmp	 continue_loading
1  5391
1  5392	000017AF				     last_object_page?:
1  5393
1  5394	000017AF  83 FF	01				 cmp	 edi, 1				 ; Object's last page?
1  5395	000017B2  75 0A					 jne	 continue_loading
1  5396
1  5397	000017B4  26: 67| 8B 0E	0AEFr			 mov	 ecx, [es:le_hdr.page_size]
1  5398	000017BA  49					 dec	 ecx
1  5399	000017BB  26: 23 0E				 and	 ecx, [es:esi.virtual_size]
1  5400
1  5401	000017BE				     continue_loading:
1  5402
1  5403	000017BE  E8 FFFFFD92				 call	 read
1  5404	000017C3  0F 82	000001F5			 jc	 error_loading
1  5405
1  5406	000017C9  26: 67| 03 16	0AEFr			 add	 edx, [es:le_hdr.page_size]
1  5407
1  5408	000017CF  4F				     dec     edi
1  5409	000017D0  75 BC				     jnz     next_page
1  5410
1  5411	000017D2				 no_pages:
1  5412
1  5413					     ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5414					     ; TODO: create descriptors	for each object	(???)
1  5415					     ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 96
DarkX.ASM



1  5416
1  5417						 ; Now we will fixup each page
1  5418
1  5419						     ; ds -> 16-bit data segment   (ds,	es inverted!)
1  5420						     ; es -> flat data segment
1  5421
1  5422	000017D2  2E: 8E 1D 0000000Cr		     mov     ds, [cs:D16_SEL]
1  5423	000017D9  2E: 8E 05 00000014r		     mov     es, [cs:DATA_SEL]
1  5424
1  5425	000017E0  67| 8B 16 0CD5r		     mov     edx, [obj_handles_ptr]	 ; Get current object ptr
1  5426	000017E5  4A				     dec     edx
1  5427
1  5428	000017E6  8B 84	D2 00000C80r		     mov     eax, [object_nfo.obj_offset + edx * 8 + edx]
1  5429	000017ED  67| A3 0CF1r			     mov     [curr_page_off], eax	 ; Offset of current page
1  5430
1  5431	000017F1  8B 56	0C			     mov     edx, [esi.page_map_index]
1  5432	000017F4  4A				     dec     edx			 ; It's	1-based
1  5433
1  5434	000017F5  C1 E2	02			     shl     edx, 2			 ; File	ptr to current fixup
1  5435	000017F8  67| 03 16 0AC3r		     add     edx, [le_offset]		 ;  page table entry
1  5436	000017FD  67| 03 16 0B2Fr		     add     edx, [le_hdr.off_fixup_pag]
1  5437	00001802  67| 89 16 0CE5r		     mov     [curr_fixup_pag], edx
1  5438
1  5439	00001807  8B 7E	10			     mov     edi, [esi.num_pages]
1  5440	0000180A  67| 8B 1E 0ABFr		     mov     ebx, [handle]
1  5441
1  5442	0000180F  0B FF				     or	     edi, edi
1  5443	00001811  0F 84	00000176		     jz	     no_pages_to_fixup
1  5444
1  5445	00001817				 fixup_next_page:
1  5446
1  5447	00001817  67| 8B 16 0CE5r			 mov	 edx, [curr_fixup_pag]		 ; Fixup a page
1  5448	0000181C  B0 00					 mov	 al, SEEK_SET
1  5449	0000181E  E8 FFFFFD3F				 call	 seek
1  5450	00001823  0F 82	00000195			 jc	 error_loading
1  5451
1  5452	00001829  BA 00000CE9r				 mov	 edx, offset off_1st_fixup_rec
1  5453	0000182E  B9 00000004				 mov	 ecx, 4
1  5454	00001833  E8 FFFFFD1D				 call	 read
1  5455	00001838  0F 82	00000180			 jc	 error_loading
1  5456
1  5457	0000183E  BA 00000CEDr				 mov	 edx, offset off_1st_fixup_rec_next_page
1  5458	00001843  B9 00000004				 mov	 ecx, 4
1  5459	00001848  E8 FFFFFD08				 call	 read
1  5460	0000184D  0F 82	0000016B			 jc	 error_loading
1  5461
1  5462	00001853  67| 8B 16 0CE9r			 mov	 edx, [off_1st_fixup_rec]
1  5463	00001858  67| 03 16 0B33r			 add	 edx, [le_hdr.off_fixup_rec]
1  5464	0000185D  67| 03 16 0AC3r			 add	 edx, [le_offset]
1  5465	00001862  B0 00					 mov	 al, SEEK_SET
1  5466	00001864  E8 FFFFFCF9				 call	 seek
1  5467	00001869  0F 82	0000014F			 jc	 error_loading
1  5468
1  5469	0000186F				     next_fixup_entry:
1  5470
1  5471	0000186F  67| A1 0CEDr				     mov     eax, [off_1st_fixup_rec_next_page]
1  5472	00001873  67| 39 06 0CE9r			     cmp     [off_1st_fixup_rec], eax
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 97
DarkX.ASM



1  5473	00001878  0F 83	000000F9			     jae     end_fixup
1  5474
1  5475	0000187E  BA 00000CF5r				     mov     edx, offset source_type
1  5476	00001883  B9 00000004				     mov     ecx, 4
1  5477	00001888  E8 FFFFFCC8				     call    read
1  5478	0000188D  0F 82	0000012B			     jc	     error_loading
1  5479
1  5480	00001893  67| 83 06 0CE9r 04			     add     [off_1st_fixup_rec], 4	 ; "Loop counter" :(
1  5481
1  5482	00001899  67| F6 06 0CF6r 03			     test    [target_flags], 3		 ; Only	internal reference
1  5483	0000189F  0F 85	0000012E			     jnz     unsuported_feature
1  5484
1  5485	000018A5  66| 67| C7 06	0CF9r +			     mov     [object_num], 0
   5486		  0000
1  5487	000018AD  B9 00000001				     mov     ecx, 1
1  5488	000018B2  67| F6 06 0CF6r 40			     test    [target_flags], 40h	 ; Object number size
1  5489	000018B8  74 01					     jz	     load_obj_num
1  5490	000018BA  41					     inc     ecx
1  5491
1  5492	000018BB					 load_obj_num:
1  5493	000018BB  BA 00000CF9r				     mov     edx, offset object_num
1  5494	000018C0  E8 FFFFFC90				     call    read
1  5495	000018C5  0F 82	000000F3			     jc	     error_loading
1  5496
1  5497	000018CB  67| 01 06 0CE9r			     add     [off_1st_fixup_rec], eax	 ; "Loop counter" :(
1  5498
1  5499	000018D0  67| 80 3E 0CF5r 07			     cmp     [source_type], 7		 ; Only	32-bit offset &
1  5500	000018D6  75 58					     jne     maybe_16bit_sel		 ;  16-bit selectors
1  5501
1  5502							 ; ÄÄÄÄÄ 32-bit	offset ÄÄÄÄÄ
1  5503
1  5504	000018D8  B9 00000002				     mov     ecx, 2
1  5505	000018DD  67| F6 06 0CF6r 10			     test    [target_flags], 10h	 ; Target offset size
1  5506	000018E3  74 05					     jz	     load_target_off
1  5507	000018E5  B9 00000004				     mov     ecx, 4
1  5508
1  5509	000018EA					 load_target_off:
1  5510	000018EA  BA 00000CFBr				     mov     edx, offset target_off
1  5511	000018EF  E8 FFFFFC61				     call    read
1  5512	000018F4  0F 82	000000C4			     jc	     error_loading
1  5513
1  5514	000018FA  67| 01 06 0CE9r			     add     [off_1st_fixup_rec], eax	 ; "Loop counter" :(
1  5515
1  5516	000018FF  67| 8B 0E 0CFBr			     mov     ecx, [target_off]
1  5517	00001904  67| F6 06 0CF6r 10			     test    [target_flags], 10h	 ; Target offset size
1  5518	0000190A  75 06					     jnz     dont_do_zero_extent
1  5519	0000190C  67| 0F B7 0E 0CFBr			     movzx   ecx, word ptr [target_off]	 ; Zero	extent,	not sign
1  5520												 ;  extent !!!!
1  5521	00001912					 dont_do_zero_extent:
1  5522
1  5523	00001912  67| 0F B7 06 0CF9r			     movzx   eax, [object_num]		 ; Do the fixup
1  5524	00001918  48					     dec     eax			 ; It's	1-based
1  5525	00001919  03 8C	C0 00000C80r			     add     ecx, [object_nfo.obj_offset + eax * 8 + eax]
1  5526	00001920  67| 0F BF 06 0CF7r			     movsx   eax, [source_off]
1  5527	00001926  67| 03 06 0CF1r			     add     eax, [curr_page_off]
1  5528
1  5529	0000192B  26: 89 08				     mov     [es:eax], ecx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 98
DarkX.ASM



1  5530
1  5531	0000192E  EB 42					     jmp     fixed_up
1  5532
1  5533							 ; ÄÄÄÄÄ 16-bit	selector ÄÄÄÄÄ
1  5534
1  5535	00001930					 maybe_16bit_sel:
1  5536
1  5537	00001930  67| 80 3E 0CF5r 02			     cmp     [source_type], 2		 ; 16-bit selector?
1  5538	00001936  0F 85	00000097			     jne     unsuported_feature
1  5539
1  5540	0000193C  67| 0F B7 06 0CF9r			     movzx   eax, [object_num]		 ; Code	or data?
1  5541	00001942  48					     dec     eax			 ; It's	1-based
1  5542	00001943  8B 84	C0 00000C83r			     mov     eax, [object_nfo.object_flags + eax * 8 + eax]
1  5543	0000194A  A9 00000004				     test    eax, 4			 ; Executable segment
1  5544	0000194F  74 0A					     jz	     it_is_data
1  5545	00001951  66| 2E: 8B 0D	      +			     mov     cx, [cs:CODE_SEL]		 ; a little hack :) @@
   5546		  00000010r
1  5547	00001959  EB 08					     jmp     we_have_sel_type
1  5548	0000195B					 it_is_data:
1  5549	0000195B  66| 2E: 8B 0D	      +			     mov     cx, [cs:DATA_SEL]
   5550		  00000014r
1  5551	00001963					 we_have_sel_type:
1  5552
1  5553	00001963  67| 0F BF 06 0CF7r			     movsx   eax, [source_off]
1  5554	00001969  67| 03 06 0CF1r			     add     eax, [curr_page_off]
1  5555
1  5556	0000196E  66| 26: 89 08				     mov     word ptr [es:eax],	cx
1  5557
1  5558	00001972					 fixed_up:
1  5559
1  5560	00001972  E9 FFFFFEF8				 jmp	 next_fixup_entry
1  5561
1  5562	00001977				     end_fixup:
1  5563
1  5564	00001977  67| A1 0AEFr				 mov	 eax, [le_hdr.page_size]
1  5565	0000197B  67| 01 06 0CF1r			 add	 [curr_page_off], eax
1  5566	00001980  67| 83 06 0CE5r 04			 add	 [curr_fixup_pag], 4
1  5567
1  5568	00001986  4F				     dec     edi
1  5569	00001987  0F 85	FFFFFE8A		     jnz     fixup_next_page
1  5570
1  5571	0000198D				 no_pages_to_fixup:
1  5572
1  5573	0000198D  83 C6	18			     add     esi, size OBJECT
1  5574
1  5575	00001990  67| FF 0E 0CDDr		 dec	 [obj_count]		 ; Iterate for all entries
1  5576	00001995  0F 85	FFFFFDA8		 jnz	 walk_object_table
1  5577
1  5578	0000199B  67| 8B 1E 0ABFr		 mov	 ebx, [handle]		 ; Close file
1  5579	000019A0  B4 3E				 mov	 ah, 3eh
1  5580	000019A2  CD 21				 int	 21h
1  5581
1  5582	000019A4  67| 8B 1E 0ADFr		 mov	 ebx, [le_hdr.object_cs] ; Calculate entry point
1  5583	000019A9  4B				 dec	 ebx			 ; It's	1-based!
1  5584	000019AA  8B 84	DB 00000C80r		 mov	 eax, [object_nfo.obj_offset + ebx * 8 + ebx]
1  5585	000019B1  67| 03 06 0AE3r		 add	 eax, [le_hdr.offset_eip]
1  5586
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 99
DarkX.ASM



1  5587	000019B6  F8				 clc
1  5588	000019B7  C3				 ret
1  5589
1  5590					     ; Return error codes
1  5591
1  5592	000019B8			     of_error_loading:			 ; Special case: error opening file
1  5593	000019B8  B8 00000000			 mov	 eax, E_FILE_ERROR
1  5594	000019BD  C3				 ret
1  5595
1  5596	000019BE			     error_loading:
1  5597	000019BE  B8 00000000			 mov	 eax, E_FILE_ERROR
1  5598	000019C3  EB 15				 jmp	 do_cleanup
1  5599
1  5600	000019C5			     not_LE:
1  5601	000019C5  B8 00000001			 mov	 eax, E_NOT_LE
1  5602	000019CA  EB 0E				 jmp	 do_cleanup
1  5603
1  5604	000019CC			     not_enough_memory:
1  5605	000019CC  B8 00000002			 mov	 eax, E_NOT_ENOUGH_MEM
1  5606	000019D1  EB 07				 jmp	 do_cleanup
1  5607
1  5608	000019D3			     unsuported_feature:
1  5609	000019D3  B8 00000003			 mov	 eax, E_UNSUPORTED_FEATURE
1  5610	000019D8  EB 00				 jmp	 do_cleanup
1  5611
1  5612					     ; Close files & free memory
1  5613
1  5614	000019DA			     do_cleanup:
1  5615
1  5616	000019DA  50				 push	 eax
1  5617
1  5618	000019DB  2E: 8E 1D 0000000Cr		 mov	 ds, [cs:D16_SEL]
1  5619
1  5620	000019E2  67| 8B 1E 0ABFr		 mov	 ebx, [handle]		 ; Close file
1  5621	000019E7  B4 3E				 mov	 ah, 3eh
1  5622	000019E9  CD 21				 int	 21h
1  5623
1  5624	000019EB  67| 8B 0E 0CD9r		 mov	 ecx, [num_obj_handles]
1  5625	000019F0  33 DB				 xor	 ebx, ebx
1  5626
1  5627	000019F2			     lle_free_memory:			 ; Free	all memory blocs
1  5628
1  5629	000019F2  0B C9				     or	     ecx, ecx
1  5630	000019F4  74 30				     jz	     lle_end_freeing
1  5631
1  5632	000019F6  80 BB	00000C7Fr 01		     cmp     [object_nfo.mem_type + ebx], DOS_MEMORY
1  5633	000019FD  75 0F				     jne     lle_free_xms_mem
1  5634
1  5635	000019FF  66| 8B 93 00000C7Br		     mov     dx, word ptr [object_nfo.obj_handles + ebx]
1  5636	00001A06  66| B8 0101			     mov     ax, 101h
1  5637	00001A0A  CD 31				     int     31h
1  5638
1  5639	00001A0C  EB 12				     jmp     lle_continue_freeing
1  5640
1  5641	00001A0E				 lle_free_xms_mem:
1  5642
1  5643	00001A0E  8B B3	00000C7Br		     mov     esi, [object_nfo.obj_handles + ebx]
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 100
DarkX.ASM



1  5644
1  5645	00001A14  66| 8B FE			     mov     di, si
1  5646	00001A17  C1 EE	10			     shr     esi, 16
1  5647	00001A1A  66| B8 0502			     mov     ax, 502h
1  5648	00001A1E  CD 31				     int     31h
1  5649
1  5650	00001A20				 lle_continue_freeing:
1  5651
1  5652	00001A20  83 C3	09			     add     ebx, size OBJNFO
1  5653
1  5654	00001A23  49				 dec	 ecx
1  5655	00001A24  EB CC				 jmp	 lle_free_memory
1  5656
1  5657	00001A26			     lle_end_freeing:
1  5658
1  5659	00001A26  58				 pop	 eax
1  5660	00001A27  F9				 stc
1  5661	00001A28  C3				 ret
1  5662
1  5663	00001A29			 LoadLE		 endp
1  5664
1  5665
   5666
   5667					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5668					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5669					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5670
   5671					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5672	00001A29			 bin_to_dec	 proc
   5673					 ; INPUT  -> EAX = number to convert ; DS:EDI -> buffer	where to copy string
   5674					 ; OUTPUT -> DS:EDI -> number string in	decimal	(skipping initial zeros)
   5675	00001A29  BB 0000000A			 mov	 ebx,10
   5676	00001A2E  BD 0000000A			 mov	 ebp,10
   5677	00001A33  32 C9				 xor	 cl,cl
   5678	00001A35				 pass_to_decimal:
   5679	00001A35  33 D2					 xor	 edx,edx
   5680	00001A37  F7 F3					 div	 ebx
   5681	00001A39  0B D2					 or	 edx,edx
   5682	00001A3B  75 04					 jnz	 make_ascii
   5683	00001A3D  0B C0					 or	 eax,eax
   5684	00001A3F  74 0B					 jz	 decide_space_from_now
   5685	00001A41					 make_ascii:
   5686	00001A41  80 C2	30				 add	 dl,30h
   5687	00001A44					 put_the_char:
   5688	00001A44  88 54	3D FF				 mov	 [ebp+edi-1],dl
   5689	00001A48  4D					 dec	 ebp
   5690	00001A49  75 EA				 jnz	 pass_to_decimal
   5691	00001A4B  C3				 ret
   5692
   5693	00001A4C				 decide_space_from_now:
   5694	00001A4C  83 FD	0A			 cmp	 ebp,10
   5695	00001A4F  75 05				 jnz	 no_first_zero
   5696	00001A51  C6 47	09 30				 mov	 byte ptr [edi+9],'0'
   5697	00001A55  4D					 dec	 ebp
   5698	00001A56				 no_first_zero:
   5699	00001A56  55				 push	 ebp
   5700	00001A57				 put_spaces:
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 101
DarkX.ASM



   5701	00001A57  C6 44	3D FF 20			 mov	 byte ptr [ebp+edi-1],'	'
   5702	00001A5C  4D				 dec	 ebp
   5703	00001A5D  75 F8				 jnz	 put_spaces
   5704	00001A5F  5D				 pop	 ebp
   5705	00001A60  03 FD				 add	 edi,ebp
   5706	00001A62  C3				 ret
   5707
   5708	00001A63			 bin_to_dec	 endp
   5709					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5710
   5711	00001A63			 c32_init:
   5712
   5713	00001A63  FA				 cli
   5714
   5715	00001A64  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_sel
   5716						 ASSUME	 DS:txdata
   5717						 ; ajustamos pila para modo protegido
   5718	00001A6B  BC 00000000s			 mov	 esp,txpila
   5719	00001A70  C1 E4	04			 shl	 esp,4
   5720	00001A73  81 C4	00004000		 add	 esp,size tx_pila
   5721
   5722						 ; ponemos el punto de retorno a PM para interrupciones	reales
   5723						 ASSUME	 DS:txcode32
   5724	00001A79  B8 00000A0Br			 mov	 eax,offset pm_ret_point
   5725						 ASSUME	 DS:txdata
   5726	00001A7E  67| A3 0532r			 mov	 prot_code_address,eax
   5727
   5728	00001A82  66| 2E: A1 00000004r		 mov	 ax,cs:D32_SEL
   5729	00001A89  8E D8				 mov	 ds,ax		; selector del segmento	de datos
   5730	00001A8B  8E E0				 mov	 fs,ax
   5731	00001A8D  8E C0				 mov	 es,ax
   5732	00001A8F  8E E8				 mov	 gs,ax
   5733	00001A91  8E D0				 mov	 ss,ax
   5734
   5735	00001A93  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5736	00001A9A  BA 000000E7r			 mov	 edx,offset sys_type_msg
   5737	00001A9F  B4 09				 mov	 ah,9
   5738	00001AA1  CD 21				 int	 21h
   5739
   5740	00001AA3  33 D2				 xor	 edx,edx
   5741	00001AA5  67| 8A 16 0341r		 mov	 dl,system_type
   5742	00001AAA  D1 E2				 shl	 edx,1
   5743	00001AAC  0A D2				 or	 dl,dl
   5744	00001AAE  75 0D				 jnz	 no_mires_si_xms
   5745	00001AB0  67| 83 3E 0347r 00		 cmp	 dword ptr xms_entry_point,0
   5746	00001AB6  74 05				 jz	 no_mires_si_xms
   5747	00001AB8  BA 00000006			 mov	 edx,3*2
   5748	00001ABD				 no_mires_si_xms:
   5749	00001ABD  66| 8B 92 000000FAr		 mov	 dx,word ptr [edx+sys_types]
   5750	00001AC4  CD 21				 int	 21h
   5751
   5752	00001AC6  BA 00000114r			 mov	 edx,offset dos_mem_msg
   5753	00001ACB  CD 21				 int	 21h
   5754
   5755	00001ACD  67| F6 06 0341r 02		 test	 system_type,2
   5756	00001AD3  74 0E				 jz	 normal_init_mem
   5757	00001AD5  67| 8B 0E 031Dr			 mov	 ecx,dos_mem_size
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 102
DarkX.ASM



   5758	00001ADA  2E: 8E 1D 00000004r			 mov	 ds,cs:D32_SEL
   5759	00001AE1  EB 23					 jmp	 print_dos_mem
   5760
   5761	00001AE3				 normal_init_mem:
   5762	00001AE3  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL	 ; selector del	segmento de datos
   5763						 ; alojamos memoria DOS
   5764	00001AEA  E8 FFFFF9BE			 call	 init_dos_heap
   5765
   5766						 ; alojamos extendida
   5767	00001AEF  E8 FFFFFA06			 call	 init_extended_heap
   5768
   5769	00001AF4  B8 00000000s			 mov	 eax,txcode32
   5770	00001AF9  C1 E0	04			 shl	 eax,4
   5771	00001AFC  05 00002F18r			 add	 eax,offset dos_heap_info
   5772	00001B01  E8 FFFFF987			 call	 getmeminfo
   5773
   5774	00001B06				 print_dos_mem:
   5775	00001B06  BF 00000000s			 mov	 edi,txcode32
   5776	00001B0B  C1 E7	04			 shl	 edi,4
   5777	00001B0E  8B C1				 mov	 eax,ecx
   5778						 ASSUME	 DS:txcode32
   5779	00001B10  C6 87	00004065r 24		 mov	 byte ptr [edi+number_string+10],"$"
   5780						 ASSUME	 DS:txdata
   5781	00001B17  C1 E8	0A			 shr	 eax,10
   5782	00001B1A  81 C7	0000405Br		 add	 edi,offset number_string
   5783	00001B20  E8 FFFFFF04			 call	 bin_to_dec
   5784	00001B25  8B D7				 mov	 edx,edi
   5785	00001B27  B4 09				 mov	 ah,9
   5786	00001B29  CD 21				 int	 21h
   5787	00001B2B  1E				 push	 ds
   5788	00001B2C  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5789	00001B33  BA 00000127r			 mov	 edx,offset extended_mem_msg
   5790	00001B38  CD 21				 int	 21h
   5791	00001B3A  67| A0 0341r			 mov	 al,system_type
   5792	00001B3E  1F				 pop	 ds
   5793	00001B3F  A8 02				 test	 al,2
   5794	00001B41  74 1C				 jz	 no_dpmi_mem_info
   5795	00001B43  B8 00000500				 mov	 eax,500h
   5796	00001B48  1E					 push	 ds
   5797	00001B49  07					 pop	 es
   5798	00001B4A  BF 00000000s				 mov	 edi,txcode32
   5799	00001B4F  C1 E7	04				 shl	 edi,4
   5800	00001B52  57					 push	 edi
   5801	00001B53  81 C7	0000388Ar			 add	 edi,offset print_buffer
   5802	00001B59  CD 31					 int	 31h
   5803	00001B5B  8B 07					 mov	 eax,[edi]
   5804	00001B5D  EB 15					 jmp	 have_dpmi_mem
   5805	00001B5F				 no_dpmi_mem_info:
   5806	00001B5F  B8 00000000s			 mov	 eax,txcode32
   5807	00001B64  C1 E0	04			 shl	 eax,4
   5808	00001B67  50				 push	 eax
   5809	00001B68  05 00003241r			 add	 eax,offset extended_heap_info
   5810	00001B6D  E8 FFFFF91B			 call	 getmeminfo
   5811	00001B72  8B C1				 mov	 eax,ecx
   5812	00001B74				 have_dpmi_mem:
   5813	00001B74  5F				 pop	 edi
   5814	00001B75  C1 E8	0A			 shr	 eax,10
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 103
DarkX.ASM



   5815	00001B78  81 C7	0000405Br		 add	 edi,offset number_string
   5816	00001B7E  E8 FFFFFEA6			 call	 bin_to_dec
   5817	00001B83  8B D7				 mov	 edx,edi
   5818	00001B85  B4 09				 mov	 ah,9
   5819	00001B87  CD 21				 int	 21h
   5820	00001B89  1E				 push	 ds
   5821	00001B8A  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   5822	00001B91  BA 0000013Dr			 mov	 edx,offset kb_msg
   5823	00001B96  CD 21				 int	 21h
   5824	00001B98  1F				 pop	 ds
   5825
   5826	00001B99  FB				 sti
   5827
   5828						 ; ///////////////////////////////
   5829						 ; CARGAMOS EL PROGRAMA	EN MEMORIA
   5830						 ; ///////////////////////////////
   5831
   5832					 ; primero, intentamos cargarlo	como LE	y, si no lo es,	como DLINK executable
   5833
   5834					 ; loader de LE's
   5835					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5836					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5837					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5838
   5839	00001B9A  2E: 8E 1D 00000014r		 mov	 ds, cs:DATA_SEL
   5840	00001BA1  2E: 8E 05 0000000Cr		 mov	 es, cs:D16_SEL
   5841						 ASSUME	 ES:txdata
   5842	00001BA8  26: 67| 8B 16	032Dr		 mov	 edx, es:program_name_ptr
   5843
   5844	00001BAE  E8 FFFFF9C2			 call	 LoadLE
   5845	00001BB3  72 2C				 jc	 LEError
   5846
   5847	00001BB5  2E: 8E 1D 00000014r		 mov	 ds, cs:DATA_SEL
   5848	00001BBC  2E: 8E 05 0000000Cr		 mov	 es, cs:D16_SEL
   5849						 ASSUME	 ES:txdata
   5850	00001BC3  26: 67| 8E 06	0335r		 mov	 es, es:psp_selector
   5851
   5852						 ; Ponemos en el PSP el	selector del segmento de vars. de entorno
   5853	00001BC9  66| 2E: 8B 1D	      +		 mov	 bx,cs:ENVRN_SEL
   5854		  00000018r
   5855	00001BD1  66| 26: 67| 89 1E   +		 mov	 es:[2Ch],bx
   5856		  002C
   5857
   5858	00001BD8  2E: FF 35 00000010r		 push	 dword ptr cs:CODE_SEL
   5859	00001BDF  50				 push	 eax
   5860	00001BE0  CB				 retf
   5861
   5862	00001BE1			 LEError:
   5863					 ; E_FILE_ERROR
   5864					 ; E_NOT_LE
   5865					 ; E_NOT_ENOUGH_MEM
   5866					 ; E_UNSUPORTED_FEATURE
   5867
   5868	00001BE1  83 F8	01			 cmp	 eax, E_NOT_LE			 ; Si no ‚s un LE carrega el DLINK
   5869	00001BE4  74 26				 je	 load_dlink_file
   5870
   5871	00001BE6  BA 00000213r			 mov	 edx, offset load_error_msg	 ; error_loading_LE
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 104
DarkX.ASM



   5872	00001BEB  83 F8	00			 cmp	 eax, E_FILE_ERROR
   5873	00001BEE  0F 84	00000240		 je	 pm_error
   5874
   5875	00001BF4  BA 00000257r			 mov	 edx,offset unsuported_feature_msg
   5876	00001BF9  83 F8	03			 cmp	 eax, E_UNSUPORTED_FEATURE
   5877	00001BFC  0F 84	00000232		 je	 pm_error
   5878
   5879	00001C02  BA 000001EAr			 mov	 edx, offset exe_size_error_msg
   5880	00001C07  E9 00000228			 jmp	 pm_error
   5881
   5882	00001C0C			 load_dlink_file:
   5883
   5884					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5885					 ; Teknik Teknik Teknik	Teknik Teknik Teknik Teknik Teknik Teknik Teknik
   5886					 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   5887
   5888
   5889					 ; loader de DLINK executables
   5890						 INCLUDE dlnkload.inc
1  5891					 ASSUME	 DS:txdata
1  5892					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5893					 ; DLINK Executable Loader
1  5894					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1  5895					 ASSUME	 ES:txdata
1  5896	00001C0C  2E: 8E 05 0000000Cr		 mov	 es,cs:D16_SEL
1  5897	00001C13  26: 67| 8B 16	032Dr		 mov	 edx,es:program_name_ptr
1  5898	00001C19  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_SEL
1  5899	00001C20  66| B8 3D00			 mov	 ax,3D00h	 ; open	for reading
1  5900	00001C24  CD 21				 int	 21h
1  5901	00001C26  0F 82	00000201		 jc	 load_error
1  5902
1  5903	00001C2C  8B D8				 mov	 ebx,eax
1  5904	00001C2E  B9 00000000s			 mov	 ecx,txcode32
1  5905	00001C33  81 E9	00000000s		 sub	 ecx,txdata
1  5906	00001C39  C1 E1	04			 shl	 ecx,4
1  5907	00001C3C  81 C1	00002118r		 add	 ecx,offset code_end+512  ; ECX	= stub size (+512 for EXE header)
1  5908	00001C42  8B D1				 mov	 edx,ecx
1  5909	00001C44  C1 E9	10			 shr	 ecx,16
1  5910	00001C47  B4 42				 mov	 ah,42h		 ; like	this it's smaller than AX,4200h	;)
1  5911	00001C49  32 C0				 xor	 al,al		 ; <---
1  5912	00001C4B  CD 21				 int	 21h
1  5913	00001C4D  0F 82	000001DA		 jc	 load_error
1  5914
1  5915	00001C53  B4 3F				 mov	 ah,3Fh
1  5916	00001C55  BA 00000000s			 mov	 edx,txcode32
1  5917	00001C5A  C1 E2	04			 shl	 edx,4
1  5918	00001C5D  81 C2	0000388Ar		 add	 edx,offset print_buffer
1  5919	00001C63  B9 00000028			 mov	 ecx,28h	 ; DLINK exe header size
1  5920	00001C68  CD 21				 int	 21h
1  5921	00001C6A  0F 82	000001BD		 jc	 load_error
1  5922
1  5923	00001C70  2E: 81 3D 0000388Ar +		 cmp	 dword ptr cs:print_buffer,'madA'
   5924		  6D616441
1  5925	00001C7B  BA 000002C4r			 mov	 edx,offset bad_exec_error_msg
1  5926	00001C80  0F 85	000001AE		 jnz	 pm_error
1  5927	00001C86  2E: F6 05 000038AEr +		 test	 byte ptr cs:print_buffer+24h,1
   5928		  01
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 105
DarkX.ASM



1  5929	00001C8E  BA 000002F7r			 mov	 edx,offset comp_exe_error_msg
1  5930	00001C93  0F 85	0000019B		 jnz	 pm_error
1  5931	00001C99  53				 push	 ebx
1  5932	00001C9A  2E: 8B 1D 0000389Er		 mov	 ebx,dword ptr cs:print_buffer+14h
1  5933	00001CA1  2E: A1 000038AAr		 mov	 eax,dword ptr cs:print_buffer+20h
1  5934	00001CA7  C1 E0	02			 shl	 eax,2
1  5935	00001CAA  03 D8				 add	 ebx,eax	 ; size	of mem.	needed + size of reloc.	table
1  5936	00001CAC  66| 8B CB			 mov	 cx,bx
1  5937	00001CAF  C1 EB	10			 shr	 ebx,16
1  5938
1  5939						 ; alojamos memoria para el programa
1  5940	00001CB2  66| B8 0501			 mov	 ax,501h
1  5941	00001CB6  CD 31				 int	 31h
1  5942	00001CB8  BA 000001EAr			 mov	 edx,offset exe_size_error_msg
1  5943	00001CBD  73 30				 jnc	 have_mem_for_exe
1  5944						 ; si no hay extendida,	usamos memoria DOS
1  5945	00001CBF  66| B8 0100			 mov	 ax,100h
1  5946	00001CC3  C1 E3	10			 shl	 ebx,16
1  5947	00001CC6  66| 8B D9			 mov	 bx,cx
1  5948	00001CC9  81 FB	000A0000		 cmp	 ebx,655360	 ; 640 Kb
1  5949	00001CCF  0F 83	0000014A		 jae	 exe_size_error
1  5950	00001CD5  C1 EB	04			 shr	 ebx,4
1  5951	00001CD8  CD 31				 int	 31h
1  5952	00001CDA  0F 82	0000013F		 jc	 exe_size_error
1  5953	00001CE0  0F B7	C0			 movzx	 eax,ax
1  5954	00001CE3  C1 E0	04			 shl	 eax,4
1  5955	00001CE6  66| 8B C8			 mov	 cx,ax
1  5956	00001CE9  C1 E8	10			 shr	 eax,16
1  5957	00001CEC  66| 8B D8			 mov	 bx,ax
1  5958	00001CEF				 have_mem_for_exe:
1  5959	00001CEF  C1 E3	10			 shl	 ebx,16
1  5960	00001CF2  66| 8B D9			 mov	 bx,cx
1  5961	00001CF5  8B D3				 mov	 edx,ebx	 ; EDX = linear	address	of buffer
1  5962
1  5963	00001CF7  5B				 pop	 ebx
1  5964	00001CF8  52				 push	 edx
1  5965	00001CF9  66| B8 4201			 mov	 ax,4201h
1  5966	00001CFD  2E: 8B 0D 00003896r		 mov	 ecx,dword ptr cs:print_buffer+0Ch
1  5967	00001D04  83 E9	28			 sub	 ecx,28h
1  5968	00001D07  66| 8B D1			 mov	 dx,cx
1  5969	00001D0A  C1 E9	10			 shr	 ecx,16
1  5970	00001D0D  CD 21				 int	 21h
1  5971	00001D0F  0F 82	00000118		 jc	 load_error
1  5972
1  5973	00001D15  5A				 pop	 edx
1  5974	00001D16  2E: 8B 0D 0000389Ar		 mov	 ecx,dword ptr cs:print_buffer+10h
1  5975	00001D1D  2E: A1 000038AAr		 mov	 eax,dword ptr cs:print_buffer+20h
1  5976	00001D23  C1 E0	02			 shl	 eax,2
1  5977	00001D26  03 C8				 add	 ecx,eax	 ; exec. size +	relocation table
1  5978	00001D28  B4 3F				 mov	 ah,3Fh
1  5979	00001D2A  CD 21				 int	 21h
1  5980	00001D2C  0F 82	000000FB		 jc	 load_error
1  5981
1  5982						 ; closing archive...
1  5983	00001D32  B4 3E				 mov	 ah,3Eh
1  5984	00001D34  32 C0				 xor	 al,al
1  5985	00001D36  CD 21				 int	 21h
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 106
DarkX.ASM



1  5986
1  5987						 ; arreglamos selectores de c¢digo y datos del programa
1  5988	00001D38  26: 67| 89 16	0321r		 mov	 dword ptr es:program_offset,edx
1  5989	00001D3E  66| 26: 67| 89 16   +		 mov	 word ptr es:code_desc+2,dx
   5990		  058Er
1  5991	00001D45  66| 26: 67| 89 16   +		 mov	 word ptr es:data_desc+2,dx
   5992		  0596r
1  5993	00001D4C  C1 EA	10			 shr	 edx,16
1  5994	00001D4F  26: 67| 88 16	0590r		 mov	 byte ptr es:code_desc+4,dl
1  5995	00001D55  26: 67| 88 36	0593r		 mov	 byte ptr es:code_desc+7,dh
1  5996	00001D5B  26: 67| 88 16	0598r		 mov	 byte ptr es:data_desc+4,dl
1  5997	00001D61  26: 67| 88 36	059Br		 mov	 byte ptr es:data_desc+7,dh
1  5998
1  5999	00001D67  26: 67| F6 06	0341r +		 test	 es:system_type,2
   6000		  02
1  6001	00001D6E  74 2E				 jz	 no_dpmi_sel_fixup
1  6002	00001D70  66| B8 000C				 mov	 ax,0Ch
1  6003	00001D74  66| 2E: 8B 1D	      +			 mov	 bx,cs:CODE_SEL
   6004		  00000010r
1  6005	00001D7C  BF 0000058Cr				 mov	 edi,offset code_desc
1  6006	00001D81  CD 31					 int	 31h
1  6007	00001D83  0F 82	0000009D			 jc	 desc_alloc_error
1  6008	00001D89  66| 2E: 8B 1D	      +			 mov	 bx,cs:DATA_SEL
   6009		  00000014r
1  6010	00001D91  BF 00000594r				 mov	 edi,offset data_desc
1  6011	00001D96  CD 31					 int	 31h
1  6012	00001D98  0F 82	00000088			 jc	 desc_alloc_error
1  6013
1  6014	00001D9E				 no_dpmi_sel_fixup:
1  6015						 ; rellenamos info sobre el EXE
1  6016						 ; tama¤o
1  6017	00001D9E  B8 00000000s			 mov	 eax,txcode32
1  6018	00001DA3  2D 00000000s			 sub	 eax,txdata
1  6019	00001DA8  C1 E0	04			 shl	 eax,4
1  6020	00001DAB  05 00002118r			 add	 eax,offset code_end+512  ; EAX	= stub size
1  6021	00001DB0  2E: 03 05 00003892r		 add	 eax,dword ptr cs:print_buffer+8
1  6022	00001DB7  26: 67| A3 033Br		 mov	 es:exe_size,eax
1  6023						 ; offset PSP
1  6024	00001DBC  26: 67| 8B 1E	0321r		 mov	 ebx,es:program_offset
1  6025	00001DC2  26: 67| 29 1E	0325r		 sub	 es:psp_offset,ebx
1  6026						 ; offset ENV
1  6027	00001DC8  26: 67| 29 1E	0329r		 sub	 es:env_offset,ebx
1  6028						 ; offset nombre
1  6029	00001DCE  26: 67| 29 1E	032Dr		 sub	 es:program_name_ptr,ebx
1  6030
1  6031	00001DD4  66| 2E: A1 00000014r		 mov	 ax,cs:DATA_SEL
1  6032	00001DDB  8E D8				 mov	 ds,ax
1  6033	00001DDD  8E C0				 mov	 es,ax
1  6034	00001DDF  8E E0				 mov	 fs,ax
1  6035	00001DE1  8E E8				 mov	 gs,ax
1  6036	00001DE3  FA				 cli
1  6037	00001DE4  8E D0				 mov	 ss,ax
1  6038	00001DE6  2E: 8B 25 000038A6r		 mov	 esp,dword ptr cs:print_buffer+1Ch	 ; INITIAL ESP
1  6039	00001DED  FB				 sti
1  6040
1  6041	00001DEE  2E: 8B 0D 000038AAr		 mov	 ecx,dword ptr cs:print_buffer+20h
1  6042	00001DF5  0B C9				 or	 ecx,ecx
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 107
DarkX.ASM



1  6043	00001DF7  74 17				 jz	 no_fixup_needed
1  6044	00001DF9  2E: 8B 35 0000389Ar		 mov	 esi,dword ptr cs:print_buffer+10h
1  6045	00001E00  2E: A1 00000014r		 mov	 eax,dword ptr cs:DATA_SEL
1  6046	00001E06				 selector_fixup:
1  6047	00001E06  8B 3E					 mov	 edi,[esi]
1  6048	00001E08  66| 89 07				 mov	 [edi],ax
1  6049	00001E0B  83 C6	04				 add	 esi,4
1  6050	00001E0E  E2 F6				 loop	 selector_fixup
1  6051
1  6052	00001E10				 no_fixup_needed:
1  6053	00001E10  2E: FF 35 00000010r		 push	 dword ptr cs:CODE_SEL
1  6054	00001E17  2E: FF 35 000038A2r		 push	 dword ptr cs:print_buffer+18h		 ; INITIAL EIP
1  6055	00001E1E  CB				 retf
1  6056
1  6057	00001E1F			 exe_size_error:
1  6058	00001E1F  BA 000001EAr			 mov	 edx,offset exe_size_error_msg
1  6059	00001E24  EB 0E				 jmp	 pm_error
1  6060	00001E26			 desc_alloc_error:
1  6061	00001E26  BA 0000029Er			 mov	 edx,offset desc_alloc_error_msg
1  6062	00001E2B  EB 07				 jmp	 pm_error
1  6063	00001E2D			 load_error:
1  6064	00001E2D  BA 00000213r			 mov	 edx,offset load_error_msg
1  6065	00001E32  EB 00				 jmp	 pm_error
1  6066
1  6067
1  6068
1  6069
   6070
   6071					 ; salida de error en la carga de ejecutable com£n a LE	y DLINK	loaders
   6072	00001E34			 pm_error:
   6073	00001E34  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   6074	00001E3B  B4 09				 mov	 ah,9
   6075	00001E3D  CD 21				 int	 21h
   6076	00001E3F  66| B8 4C01			 mov	 ax,4C01h
   6077	00001E43  CD 21				 int	 21h
   6078
   6079	00001E45				 salida:
   6080						 ASSUME	DS:txdata
   6081	00001E45  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL
   6082	00001E4C  67| F6 06 0341r 02		 test	 system_type,2
   6083	00001E52  75 35				 jnz	 salida_dpmi
   6084
   6085						 ; iniciamos la	reentrada
   6086	00001E54  2E: 8E 1D 00000004r		 mov	 ds,cs:D32_sel
   6087	00001E5B  BB 00000000s			 mov	 ebx,txcode
   6088	00001E60  C1 E3	04			 shl	 ebx,4
   6089						 ASSUME	 DS:txcode
   6090	00001E63  81 C3	00000019r		 add	 ebx,offset saltito+1
   6091	00001E69  66| C7 03 09F5r		 mov	 word ptr [ebx],offset s16
   6092	00001E6E  2E: 8E 1D 0000000Cr		 mov	 ds,cs:D16_SEL	 ; hay que cargarlos antes de llamar a RET_REAL
   6093	00001E75  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
   6094	00001E7C  2E: FF 35 00000008r		 push	 dword ptr cs:C16_sel
   6095						 pushd	 ret_real
1  6096	00001E83  68				 db 68h
1  6097	00001E84  09BEr	0000			 dw offset ret_real,0
   6098	00001E88  CB				 retf
   6099
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 108
DarkX.ASM



   6100					 ; Punto de salida bajo	DPMI
   6101	00001E89				 salida_dpmi:
   6102						 ASSUME	 DS:txdata
   6103						 ; recuperamos excepciones
   6104	00001E89  32 DB				 xor	 bl,bl
   6105	00001E8B  BF 00000443r			 mov	 edi,offset dpmi_exc_handlers
   6106	00001E90				 restore_ints:
   6107	00001E90  8B 17					 mov	 edx,[edi]
   6108	00001E92  66| 8B 4F 04				 mov	 cx,[edi+4]
   6109	00001E96  66| B8 0203				 mov	 ax,203h
   6110	00001E9A  CD 31					 int	 31h
   6111	00001E9C  83 C7	06				 add	 edi,6
   6112	00001E9F  FE C3					 inc	 bl
   6113	00001EA1  80 FB	0F			 cmp	 bl,15
   6114	00001EA4  75 EA				 jnz restore_ints
   6115
   6116						 ; recuperamos las interrupciones
   6117						 ASSUME	 ES:txcode32
   6118	00001EA6  2E: 8E 05 00000004r		 mov	 es,cs:D32_SEL
   6119	00001EAD  32 DB				 xor	 bl,bl
   6120	00001EAF  BF 00000000s			 mov	 edi,txcode32
   6121	00001EB4  C1 E7	04			 shl	 edi,4
   6122	00001EB7				 recupera_ints:
   6123							 ASSUME	 ES:txcode32
   6124	00001EB7  26: 8B 97 00001F18r			 mov	 edx,dword ptr es:[edi+idt]
   6125	00001EBE  66| 26: 8B 8F	      +			 mov	 cx,word ptr es:[edi+idt+4]
   6126		  00001F1Cr
   6127							 ASSUME	 ES:txdata
   6128	00001EC6  66| B8 0205				 mov	 ax,205h
   6129	00001ECA  CD 31					 int	 31h
   6130	00001ECC  83 C7	06				 add	 edi,6
   6131	00001ECF  FE C3				 inc bl
   6132	00001ED1  75 E4				 jnz recupera_ints
   6133
   6134						 ; si se produjo una excepci¢n,	salimos	con info de debugging
   6135	00001ED3  67| 80 3E 04A9r 00		 cmp	 dpmi_exception_flag,0
   6136	00001ED9  74 30				 jz	 any_exception
   6137	00001EDB  66| B8 0003			 mov	 ax,3
   6138	00001EDF  CD 10				 int	 10h
   6139	00001EE1  33 C0				 xor	 eax,eax
   6140	00001EE3  50				 push	 eax
   6141	00001EE4  83 EC	08			 sub	 esp,4*2
   6142	00001EE7  66| B8 0000s			 mov	 ax,txdata
   6143	00001EEB  66| 50			 push	 ax
   6144	00001EED  83 EC	02			 sub	 esp,2
   6145	00001EF0  FC				 cld
   6146	00001EF1  66				 db	 66h		 ; push	de un WORD en segmento de 32 bits
   6147	00001EF2  66| 9C			 pushf
   6148	00001EF4  66| BA 06CEr			 mov	 dx,offset debug_info_msg
   6149	00001EF8  B4 09				 mov	 ah,9
   6150	00001EFA  60				 pushad
   6151	00001EFB  8B FC				 mov	 edi,esp
   6152	00001EFD  16				 push	 ss
   6153	00001EFE  07				 pop	 es
   6154	00001EFF  66| BB 0021			 mov	 bx,21h
   6155	00001F03  33 C9				 xor	 ecx,ecx
   6156	00001F05  66| B8 0300			 mov	 ax,300h
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 109
DarkX.ASM



   6157	00001F09  CD 31				 int	 31h
   6158
   6159	00001F0B				 any_exception:
   6160						 ; restauramos la base de las irq's y salimos al OS
   6161	00001F0B  2E: FF 35 00000008r		 push	 dword ptr cs:C16_SEL
   6162						 pushd	 exit_redirless
1  6163	00001F12  68				 db 68h
1  6164	00001F13  0A2Cr	0000			 dw offset exit_redirless,0
   6165	00001F17  CB				 retf
   6166
   6167					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   6168	00001F18			 code_end:
   6169					 ; Interrupt Descriptor	Table
   6170	00001F18  0200*(????????)	 idt		 dd 256*2 dup(?)
   6171
   6172					 ; tabla de redireccionamientos	de interrupciones
   6173	00002718  0200*(????????)	 interrup_redir	 dd 256*2 dup(?)
   6174
   6175	00002F18  ???????? ????????	 dos_heap_info		 dd ?,?
   6176	00002F20  0321*(??)		 dos_pointers		 db 8*100+1 dup(?)
   6177
   6178	00003241  ???????? ????????	 extended_heap_info	 dd ?,?
   6179	00003249  0321*(??)		 extended_pointers	 db 8*100+1 dup(?)
   6180
   6181	0000356A  0320*(??)		 xms_handles		 db 8*100 dup(?)
   6182
   6183	0000388A  07D1*(??)		 print_buffer		 db 80*25+1 dup(?)
   6184
   6185	0000405B  0B*(??)		 number_string		 db 11 dup(?)
   6186	00004066			 TXCODE32  ENDS
   6187
   6188					 ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
   6189
   6190	    0000			 TXPILA		 SEGMENT PARA STACK USE16 'STACK'
   6191	    0000  1000*(????????)	 tx_pila	 dd	 PM_STACKSIZE dup(?)
   6192	    4000			 TXPILA		 ENDS
   6193
   6194					 ; pila	auxiliar para procedimientos reales
   6195	    0000			 TXPILA_REAL	 SEGMENT PARA USE16 'STACK'
   6196	    0000  1000*(????????)	 txpr		 dd	 RM_STACKSIZE dup(?)	  ; 30 words es	el m¡nimo
   6197	    4000			 TXPILA_REAL	 ENDS
   6198
   6199	00000000			 DISK		 SEGMENT PARA
   6200	00000000  8000*(??)		 disk_buffer	 db	 8000h dup(?)	 ; 32Kb	would be ok ;)
   6201	00008000			 DISK		 ENDS
   6202
   6203					 END init_pm
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 110
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "11/19/20"
??FILENAME			  Text	 "DarkX	  "
??TIME				  Text	 "08:48:32"
??VERSION			  Number 030A
@CPU				  Text	 0F8FH
@CURSEG				  Text	 DISK
@FILENAME			  Text	 DARKX
@WORDSIZE			  Text	 4
A20_BUCLE1			  Near	 TXCODE:0C8D
A20_BUCLE2			  Near	 TXCODE:0C98
A20_CHECK_STATE			  Near	 TXCODE:0C4C
A20_ENABLED			  Near	 TXCODE:0C4B
A20_ERROR_MSG			  Byte	 TXDATA:0165
A20_OK				  Near	 TXCODE:07F7
ADDHEAP				  Near	 TXCODE32:1257
ADDRESS_FOUND			  Near	 TXCODE32:0875
ADD_HEAPS			  Near	 TXCODE32:14DB
AH_ADD				  Near	 TXCODE32:1279
AH_LP				  Near	 TXCODE32:126E
ALLOCATED_CB			  Number 0001
ALLOC_DESC			  Near	 TXCODE32:04F3
ALLOC_DOS_MEM			  Near	 TXCODE:0A89
ALLOC_EM			  Near	 TXCODE32:0536
ALLOC_ERROR			  Near	 TXCODE32:044D
ANY_EXCEPTION			  Near	 TXCODE32:1F0B
AVOID_V86_TEST			  Near	 TXCODE:07CB
BACK_FROM_DPMI_INT		  Near	 TXCODE32:0212
BACK_FROM_IRQ16			  Near	 TXCODE32:0AD4
BAD_EXEC_ERROR_MSG		  Byte	 TXDATA:02C4
BIN_TO_DEC			  Near	 TXCODE32:1A29
BIN_TO_HEX			  Near	 TXCODE32:0E66
BYTES_IN_STACK			  Word	 TXCODE:04B8
C16_DESC			  Word	 TXDATA:057C
C16_SEL				  Word	 TXCODE32:0008
C32_INIT			  Near	 TXCODE32:1A63
C32_SEL				  Word	 TXCODE32:0000
CALLBACK_ADDRESS_TABLE		  Near	 TXCODE:04D7
CALLBACK_ALLOC			  Near	 TXCODE32:07D2
CALLBACK_CODE			  Word	 TXCODE:0690
CALLBACK_DATA			  Word	 TXDATA:0CFF
CALLBACK_FREE			  Near	 TXCODE32:0847
CALLBACK_MANAGER		  Near	 TXCODE:05F5
CALLBACK_PM			  Near	 TXCODE32:0E82
CBACK16_RETURN			  Near	 TXCODE:0645
CBSLOT				  Number 01E0
CB_FOUND			  Near	 TXCODE32:07FF
CB_NOT_FOUND			  Near	 TXCODE32:086B
CHECK_LE			  Near	 TXCODE32:1610
CIFRA0				  Near	 TXCODE32:0E73
CIFRA1				  Near	 TXCODE32:0E7F
CODE_DESC			  Word	 TXDATA:058C
CODE_DESCRIPTOR			  Word	 TXDATA:056C
CODE_END			  Near	 TXCODE32:1F18
CODE_SEL			  Word	 TXCODE32:0010
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 111
Symbol Table



COMP_EXE_ERROR_MSG		  Byte	 TXDATA:02F7
CONTINUA_VOLCADO		  Near	 TXCODE32:0BC9
CONTINUE_LOADING		  Near	 TXCODE32:17BE
CONT_ADDING			  Near	 TXCODE:0A99
CONT_ADDING_XMS			  Near	 TXCODE:0807
CONT_SEARCHING			  Near	 TXCODE:06B6
CONVERT				  Near	 TXCODE32:0E4A
COPIA_SELS			  Near	 TXCODE:02BC
COPYRIGHT_MSG			  Byte	 TXDATA:0000
COPY_FILE_NAME			  Near	 TXCODE32:102A
COPY_NAME			  Near	 TXCODE32:1049
COPY_STRING			  Near	 TXCODE32:107A
COULDNT_FIND_EM			  Near	 TXCODE32:052B
CPU386				  Byte	 TXDATA:00B2
CPU486				  Byte	 TXDATA:00B6
CPUID				  Near	 TXCODE:0CA8
CPU_INFO			  Word	 TXDATA:033F
CPU_STRINGS			  Word	 TXDATA:00AC
CPU_TYPE_MSG			  Byte	 TXDATA:009B
CRASH_CODE			  Byte	 TXDATA:079A
CURRENT_STACKFRAME		  Dword	 TXCODE:0682
CURR_FIXUP_PAG			  Dword	 TXDATA:0CE5
CURR_PAGE			  Dword	 TXDATA:0CE1
CURR_PAGE_OFF			  Dword	 TXDATA:0CF1
D16_DESC			  Word	 TXDATA:0584
D16_SEL				  Word	 TXCODE32:000C
D32_SEL				  Word	 TXCODE32:0004
DATA_DESC			  Word	 TXDATA:0594
DATA_DESCRIPTOR			  Word	 TXDATA:0574
DATA_SEL			  Word	 TXCODE32:0014
DEBUG_CS			  Byte	 TXDATA:0786
DEBUG_CS1			  Byte	 TXDATA:0965
DEBUG_DS			  Byte	 TXDATA:0992
DEBUG_EAX			  Byte	 TXDATA:0852
DEBUG_EBP			  Byte	 TXDATA:08BD
DEBUG_EBX			  Byte	 TXDATA:0864
DEBUG_ECX			  Byte	 TXDATA:0876
DEBUG_EDI			  Byte	 TXDATA:08AB
DEBUG_EDX			  Byte	 TXDATA:0888
DEBUG_EIP			  Byte	 TXDATA:078B
DEBUG_ES			  Byte	 TXDATA:09BF
DEBUG_ESI			  Byte	 TXDATA:0899
DEBUG_ESP			  Byte	 TXDATA:08CF
DEBUG_ESP0			  Byte	 TXDATA:07D1
DEBUG_FLAGS			  Byte	 TXDATA:08E3
DEBUG_FS			  Byte	 TXDATA:09EC
DEBUG_GS			  Byte	 TXDATA:0A19
DEBUG_INFO			  Near	 TXCODE:0A69
DEBUG_INFO_MSG			  Byte	 TXDATA:06CE
DEBUG_SS			  Byte	 TXDATA:0A46
DEBUG_SS0			  Byte	 TXDATA:07CC
DECIDE_SPACE_FROM_NOW		  Near	 TXCODE32:1A4C
DESC_ALLOC_ERROR		  Near	 TXCODE32:1E26
DESC_ALLOC_ERROR_MSG		  Byte	 TXDATA:029E
DESC_CS				  Byte	 TXDATA:0974
DESC_DS				  Byte	 TXDATA:09A1
DESC_ES				  Byte	 TXDATA:09CE
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 112
Symbol Table



DESC_FS				  Byte	 TXDATA:09FB
DESC_GS				  Byte	 TXDATA:0A28
DESC_SS				  Byte	 TXDATA:0A55
DETERMINE_SYS			  Near	 TXCODE32:090B
DIR_BASE			  Dword	 TXDATA:0351
DISK_BUFFER			  Byte	 DISK:0000
DISK_SEG			  Word	 TXDATA:0339
DONT_DO_ZERO_EXTENT		  Near	 TXCODE32:1912
DONT_READ_BLOCKS		  Near	 TXCODE32:1118
DONT_SPLIT			  Near	 TXCODE32:12E0
DONT_WRITE_BLOCKS		  Near	 TXCODE32:11BA
DOS32_INFO			  Near	 TXCODE32:098B
DOS32_SYS_INFO			  Near	 TXCODE32:0964
DOS_ALLOC_ERROR			  Near	 TXCODE32:0301
DOS_HEAP_DONE			  Near	 TXCODE:0AD7
DOS_HEAP_INFO			  Dword	 TXCODE32:2F18
DOS_INT				  Near	 TXCODE32:1005
DOS_MEMORY			  Number 0001
DOS_MEM_ALLOC			  Near	 TXCODE32:02BB
DOS_MEM_FREE			  Near	 TXCODE32:031F
DOS_MEM_MSG			  Byte	 TXDATA:0114
DOS_MEM_RESIZE			  Near	 TXCODE32:035E
DOS_MEM_SIZE			  Dword	 TXDATA:031D
DOS_POINTERS			  Byte	 TXCODE32:2F20
DOS_VERSION_ERROR_MSG		  Byte	 TXDATA:0144
DO_CLEANUP			  Near	 TXCODE32:19DA
DPMI_32B_ERROR			  Byte	 TXDATA:0380
DPMI_ERROR			  Near	 TXCODE:01DF
DPMI_EXCEPTION_EXIT		  Near	 TXCODE32:0D99
DPMI_EXCEPTION_FLAG		  Byte	 TXDATA:04A9
DPMI_EXC_HANDLERS		  Byte	 TXDATA:0443
DPMI_HANDLES_STANDARD_FUNCS	  Near	 TXCODE32:0136
DPMI_INIT			  Near	 TXCODE:0227
DPMI_INIT_ERROR			  Byte	 TXDATA:03A6
DPMI_INT21_PASS			  Near	 TXCODE32:0FEB
DPMI_MODE_SWITCH		  Dword	 TXCODE:0234
DPMI_MSG			  Byte	 TXDATA:010B
DPMI_OLD_INT21H			  Word	 TXDATA:049D
DPMI_OLD_INT31H			  Word	 TXDATA:04A3
DPMI_PM_TO_REAL			  Word	 TXDATA:0401
DPMI_PRIVATE_BUFFER		  Word	 TXDATA:03F1
DPMI_REAL_TO_PM			  Dword	 TXDATA:03FD
DPMI_RM_CALL			  Byte	 TXDATA:0407
DPMI_RM_CALL_STRUC		  Word	 TXDATA:03BF
DPMI_RM_INT			  Near	 TXCODE:039A
DPMI_SAVE_RESTORE_PM		  Word	 TXDATA:03F7
DPMI_SAVE_RESTORE_REAL		  Dword	 TXDATA:03F3
DPMI_SELS			  Dword	 TXDATA:0427
DPMI_SET_EXCS			  Near	 TXCODE:0300
ENABLE_A20			  Near	 TXCODE:0C17
END_FIXUP			  Near	 TXCODE32:1977
END_OF_CB_ADDRESS		  Near	 TXCODE:04DE
END_OF_FILL			  Near	 TXCODE32:171A
END_OF_NAME			  Near	 TXCODE32:1056
END_PUT				  Near	 TXCODE32:0D37
ENVRN_SEL			  Word	 TXCODE32:0018
ENV_DESC			  Word	 TXDATA:059C
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 113
Symbol Table



ENV_OFFSET			  Dword	 TXDATA:0329
ENV_SEL				  Number 0038
ENV_SELECTOR			  Word	 TXDATA:0337
ERROR_HANDLE			  Near	 TXCODE:0D93
ERROR_HANDLE1			  Near	 TXCODE:0D99
ERROR_LOADING			  Near	 TXCODE32:19BE
ERROR_STRING			  Byte	 TXDATA:06D5
ERROR_STRING_TABLE		  Word	 TXDATA:0626
ES_AL				  Near	 TXCODE32:0E34
ES_AX				  Near	 TXCODE32:0E3A
ES_EAX				  Near	 TXCODE32:0E43
EXCEPTIONS			  Near	 TXCODE32:0B0D
EXCEPTION_NUMBER		  Byte	 TXDATA:0719
EXC_0				  Byte	 TXDATA:0646
EXC_1				  Byte	 TXDATA:0656
EXC_13				  Byte	 TXDATA:0687
EXC_14				  Byte	 TXDATA:06A2
EXC_6				  Byte	 TXDATA:0666
EXC_7				  Byte	 TXDATA:0675
EXC_DEFAULT			  Byte	 TXDATA:06AD
EXE_INFO_STRUC			  Word	 TXDATA:0321
EXE_SIZE			  Dword	 TXDATA:033B
EXE_SIZE_ERROR			  Near	 TXCODE32:1E1F
EXE_SIZE_ERROR_MSG		  Byte	 TXDATA:01EA
EXIT_REDIRLESS			  Near	 TXCODE:0A2C
EXTENDED_HEAP_INFO		  Dword	 TXCODE32:3241
EXTENDED_HEAP_SIZE		  Dword	 TXDATA:0343
EXTENDED_INIT_DONE		  Near	 TXCODE32:154F
EXTENDED_INIT_FOUND		  Near	 TXCODE:090E
EXTENDED_MEM_MSG		  Byte	 TXDATA:0127
EXTENDED_POINTERS		  Byte	 TXCODE32:3249
EXT_FREE_ERROR			  Near	 TXCODE32:048A
EXT_MEM_ALLOC			  Near	 TXCODE32:0404
EXT_MEM_FREE			  Near	 TXCODE32:0457
EXT_MEM_INFO			  Near	 TXCODE32:03BB
EXT_MEM_RESIZE			  Near	 TXCODE32:048F
E_FILE_ERROR			  Number 0000
E_NOT_ENOUGH_MEM		  Number 0002
E_NOT_LE			  Number 0001
E_UNSUPORTED_FEATURE		  Number 0003
FIN				  Near	 TXCODE:0A05
FIND_THE_REST			  Near	 TXCODE32:051C
FIN_PROGRAMA			  Near	 TXCODE32:0FF4
FIXED_UP			  Near	 TXCODE32:1972
FIXUP_NEXT_PAGE			  Near	 TXCODE32:1817
FIX_IRQS			  Near	 TXCODE:0B70
FOUND_DESCS			  Near	 TXCODE32:0531
FOUND_ONE_SLOT			  Near	 TXCODE32:051A
FOUND_SPACE_FOR_PAGING		  Near	 TXCODE32:0775
FPU287				  Byte	 TXDATA:00D5
FPU387				  Byte	 TXDATA:00DB
FPU487				  Byte	 TXDATA:00E1
FPUID				  Near	 TXCODE:0D37
FPU_FOUND			  Near	 TXCODE:0D90
FPU_INFO			  Byte	 TXDATA:0342
FPU_STATUS			  Word	 TXCODE:0D91
FPU_STRINGS			  Word	 TXDATA:00C3
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 114
Symbol Table



FREE				  Near	 TXCODE32:12F8
FREE_CB				  Number 0000
FREE_DESC			  Near	 TXCODE32:0570
FREE_DESCS			  Number 000A
FREE_DESCS_HANDLES		  Byte	 TXDATA:061C
FREE_DESCS_START		  Byte	 TXDATA:05CC
FREE_DESC_ERROR			  Near	 TXCODE32:059B
FREE_XMS_BLOCKS			  Near	 TXCODE:0A4D
F_END				  Near	 TXCODE32:135E
F_NEXT				  Near	 TXCODE32:132F
GDT				  Word	 TXDATA:0564
GDT_BASE			  Dword	 TXDATA:053E
GDT_LIMIT			  Word	 TXDATA:053C
GDT_REG				  Pword	 TXDATA:053C
GENERIC_FILE_SERVICE		  Near	 TXCODE32:10B3
GEN_IDT				  Near	 TXCODE:0B04
GEN_INTS			  Near	 TXCODE:0B51
GETMEMINFO			  Near	 TXCODE32:148D
GET_ALL_MEM			  Near	 TXCODE:096D
GET_DOS_MEM			  Near	 TXCODE:0DD2
GET_INT_VECTOR			  Near	 TXCODE32:0635
GET_MEMORY			  Near	 TXCODE32:1689
GET_PROGRAM_INFO		  Near	 TXCODE32:0934
GET_PSP_SEL			  Near	 TXCODE32:121B
GET_RM_INT_VEC			  Near	 TXCODE32:088F
GET_SEG_BASE			  Near	 TXCODE32:05ED
GET_SEG_BASE_ERROR		  Near	 TXCODE32:0632
GET_SYS_INFO			  Near	 TXCODE32:08EF
GET_THIS_BASE			  Near	 TXCODE32:0617
GMI_C				  Near	 TXCODE32:149F
GMI_END				  Near	 TXCODE32:14AC
GMI_LP				  Near	 TXCODE32:1493
GMI_NXT				  Near	 TXCODE32:14A1
GUARDA_EXCS			  Near	 TXCODE:02DE
GUARDA_INTS			  Near	 TXCODE:0334
HANDLE				  Dword	 TXDATA:0ABF
HAVE_CPU_NAME			  Near	 TXCODE:072F
HAVE_DPMI_MEM			  Near	 TXCODE32:1B74
HAVE_MEM_FOR_EXE		  Near	 TXCODE32:1CEF
HEAP_ERROR			  Near	 TXCODE:0AD9
IDT				  Dword	 TXCODE32:1F18
IDT_BASE			  Dword	 TXDATA:0544
IDT_LIMIT			  Word	 TXDATA:0542
IDT_REAL			  Pword	 TXDATA:0548
IDT_REG				  Pword	 TXDATA:0542
ID_DONE				  Near	 TXCODE:0D2F
INITHEAP			  Near	 TXCODE32:122B
INIT_DATA			  Near	 TXCODE:0ADB
INIT_DOS_HEAP			  Near	 TXCODE32:14AD
INIT_EXTENDED_HEAP		  Near	 TXCODE32:14FA
INIT_MEM			  Near	 TXCODE:0DA9
INIT_PM				  Near	 TXCODE:0696
INTERRUP_REDIR			  Dword	 TXCODE32:2718
INT_NUM				  Byte	 TXCODE:04B1
INT_OR_CALL			  Word	 TXCODE:0452
INVALID_CODE_SELECTOR		  Near	 TXCODE32:0C06
INVALID_SEL_MSG			  Byte	 TXDATA:06B7
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 115
Symbol Table



IRQ16				  Near	 TXCODE:04BE
IRQ_BASE			  Byte	 TXCODE:0A68
IRQ_REDIR			  Near	 TXCODE:0DDC
IT_HAS_STUB			  Near	 TXCODE32:15C2
IT_IS_DATA			  Near	 TXCODE32:195B
KB_MSG				  Byte	 TXDATA:013D
LAST_OBJECT_PAGE?		  Near	 TXCODE32:17AF
LEERROR				  Near	 TXCODE32:1BE1
LENGTH_OK			  Near	 TXCODE32:0947
LE_HDR				  Struct TXDATA:0AC7 LEHEADER
LE_OFFSET			  Dword	 TXDATA:0AC3
LLE_CONTINUE_FREEING		  Near	 TXCODE32:1A20
LLE_END_FREEING			  Near	 TXCODE32:1A26
LLE_FREE_MEMORY			  Near	 TXCODE32:19F2
LLE_FREE_XMS_MEM		  Near	 TXCODE32:1A0E
LOADLE				  Near	 TXCODE32:1575
LOAD_DLINK_FILE			  Near	 TXCODE32:1C0C
LOAD_ERROR			  Near	 TXCODE32:1E2D
LOAD_ERROR_MSG			  Byte	 TXDATA:0213
LOAD_OBJ_NUM			  Near	 TXCODE32:18BB
LOAD_TARGET_OFF			  Near	 TXCODE32:18EA
LOOK_FOR_ENOUGH_SPACE		  Near	 TXCODE32:075E
MAKE_ASCII			  Near	 TXCODE32:1A41
MAKE_RM_INT			  Near	 TXCODE32:0144
MAKE_XMS_HEAP			  Near	 TXCODE32:152A
MALLOC				  Near	 TXCODE32:129F
MAP_MEMORY			  Near	 TXCODE32:06C3
MAP_THE_REGION			  Near	 TXCODE32:07A0
MAYBE_16BIT_SEL			  Near	 TXCODE32:1930
MEM_ALLOC_DONE			  Near	 TXCODE:0940
METHOD_2			  Near	 TXCODE:08E1
M_END				  Near	 TXCODE32:12F5
M_LP				  Near	 TXCODE32:12A7
M_NEXT				  Near	 TXCODE32:12EA
NEED_A_STACK			  Near	 TXCODE:03CE
NEED_REAL_SEGS			  Near	 TXCODE32:09EF
NEW_CODE			  Dword	 TXCODE:0686
NEW_FLAGS			  Word	 TXCODE:068E
NEW_STACK			  Dword	 TXCODE:068A
NEXT_DESC			  Near	 TXCODE32:059E
NEXT_FIXUP_ENTRY		  Near	 TXCODE32:186F
NEXT_LABEL			  Near	 TXCODE:0033
NEXT_PAGE			  Near	 TXCODE32:178E
NO386_ERROR_MSG			  Byte	 TXDATA:01C2
NOFPU				  Byte	 TXDATA:00CD
NORMAL_ESP			  Near	 TXCODE32:0CBC
NORMAL_GDT			  Near	 TXCODE32:0BC3
NORMAL_INIT_MEM			  Near	 TXCODE32:1AE3
NORMAL_SEL			  Near	 TXCODE32:0DED
NOT_ENOUGH_DESCS		  Near	 TXCODE32:0567
NOT_ENOUGH_EXT_MEM		  Near	 TXCODE32:16CD
NOT_ENOUGH_MEM			  Byte	 TXDATA:04AA
NOT_ENOUGH_MEMORY		  Near	 TXCODE32:19CC
NOT_LE				  Near	 TXCODE32:19C5
NO_386				  Near	 TXCODE:0D33
NO_487				  Near	 TXCODE:0D73
NO_DEFAULT_STACK		  Near	 TXCODE32:018B
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 116
Symbol Table



NO_DOS_HEAP_ERROR		  Near	 TXCODE32:0315
NO_DOS_HEAP_ERROR1		  Near	 TXCODE32:0350
NO_DOS_HEAP_ERROR2		  Near	 TXCODE32:03AD
NO_DPMI				  Near	 TXCODE:0775
NO_DPMI_INIT			  Near	 TXCODE:0966
NO_DPMI_MEM_INFO		  Near	 TXCODE32:1B5F
NO_DPMI_SEL_FIXUP		  Near	 TXCODE32:1D9E
NO_ERROR_CODE			  Near	 TXCODE32:0B9D
NO_EXT_HEAP_ERROR		  Near	 TXCODE32:03FF
NO_FIRST_ZERO			  Near	 TXCODE32:1A56
NO_FIXUP_NEEDED			  Near	 TXCODE32:1E10
NO_FLAG_SAVE			  Near	 TXCODE:0427
NO_FPU_DET_NEEDED		  Near	 TXCODE:075E
NO_GEN_IDT			  Near	 TXCODE:0B40
NO_IRQ_FIXUP1			  Near	 TXCODE32:0657
NO_IRQ_FIXUP2			  Near	 TXCODE32:069E
NO_IRQ_FIXUP_RM1		  Near	 TXCODE32:08A5
NO_IRQ_FIXUP_RM2		  Near	 TXCODE32:08CE
NO_MAPPING_NEEDED		  Near	 TXCODE32:07C7
NO_MIRES_SI_XMS			  Near	 TXCODE32:1ABD
NO_MORE_HEAPS			  Near	 TXCODE32:14F9
NO_PAGEABLE			  Near	 TXCODE32:07C9
NO_PAGES			  Near	 TXCODE32:17D2
NO_PAGES_TO_FIXUP		  Near	 TXCODE32:198D
NO_RESTO			  Near	 TXCODE32:1180
NO_RESTO2			  Near	 TXCODE32:112F
NO_RESTO3			  Near	 TXCODE32:1138
NO_RESTO4			  Near	 TXCODE32:11D1
NO_RESTO5			  Near	 TXCODE32:11DA
NO_RETURN_VALS			  Near	 TXCODE32:027B
NO_SS_DE_PILA			  Near	 TXCODE32:0C7A
NO_STACK_PARAMETERS		  Near	 TXCODE32:01BC
NO_TENEMOS_EL_GUSTO		  Near	 TXCODE32:0B92
NO_VCPI_END			  Near	 TXCODE:0A24
NO_VOLCADO_DESC			  Near	 TXCODE32:0E23
NO_XMS				  Near	 TXCODE:086B
NO_XMS_ALLOCATED		  Near	 TXCODE:0A62
NUMBER_STRING			  Byte	 TXCODE32:405B
NUM_DESCS			  Number 000C
NUM_OBJ_HANDLES			  Dword	 TXDATA:0CD9
NUM_RM_CALLBACKS		  Number 0020
OBJECT_NFO			  Struct TXDATA:0C7B OBJNFO
OBJECT_NUM			  Word	 TXDATA:0CF9
OBJECT_TBL			  Struct TXDATA:0B8B OBJECT
OBJ_COUNT			  Dword	 TXDATA:0CDD
OBJ_HANDLES_PTR			  Dword	 TXDATA:0CD5
OFF_1ST_FIXUP_REC		  Dword	 TXDATA:0CE9
OFF_1ST_FIXUP_REC_NEXT_PAGE	  Dword	 TXDATA:0CED
OF_ERROR_LOADING		  Near	 TXCODE32:19B8
OPENFILE			  Near	 TXCODE32:1550
PAGE_DIR_BASE			  Dword	 TXDATA:0355
PAGE_DIR_ENTRIES		  Dword	 TXDATA:0359
PAGE_IS_LOCKED			  Near	 TXCODE:0843
PASS_TO_DECIMAL			  Near	 TXCODE32:1A35
PENTIUM_CPU			  Byte	 TXDATA:00BA
PILA_REAL			  Dword	 TXCODE:0692
PM_DS				  Word	 TXDATA:0376
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 117
Symbol Table



PM_EAX				  Dword	 TXDATA:0504
PM_EBP				  Dword	 TXDATA:051C
PM_EBX				  Dword	 TXDATA:0508
PM_ECX				  Dword	 TXDATA:050C
PM_EDI				  Dword	 TXDATA:0518
PM_EDX				  Dword	 TXDATA:0510
PM_EFLAGS			  Dword	 TXDATA:0524
PM_ERROR			  Near	 TXCODE32:1E34
PM_ES				  Word	 TXDATA:0378
PM_ESI				  Dword	 TXDATA:0514
PM_ESP				  Dword	 TXDATA:0520
PM_FS				  Word	 TXDATA:037A
PM_GS				  Word	 TXDATA:037C
PM_RET_POINT			  Near	 TXCODE32:0A0B
PM_SS				  Word	 TXDATA:037E
PM_STACKSIZE			  Number 1000
PON_DPL				  Near	 TXCODE:0285
PON_REGISTROS			  Near	 TXCODE32:0B2E
PRESENT_ENTRY			  Near	 TXCODE32:076C
PRE_RM_CALL			  Near	 TXCODE:0403
PRINTF				  Near	 TXCODE:0D9F
PRINT_ANOTHER_PIECE		  Near	 TXCODE32:1060
PRINT_BUFFER			  Byte	 TXCODE32:388A
PRINT_DESC			  Near	 TXCODE32:0DB4
PRINT_DOS_MEM			  Near	 TXCODE32:1B06
PRINT_STRING			  Near	 TXCODE32:105C
PROGRAM_INFO_DONE		  Near	 TXCODE32:095A
PROGRAM_NAME_PTR		  Dword	 TXDATA:032D
PROGRAM_OFFSET			  Dword	 TXDATA:0321
PROG_SEL			  Word	 TXDATA:0333
PROT_CODE_ADDRESS		  Dword	 TXDATA:0532
PSP_DESC			  Word	 TXDATA:05A4
PSP_OFFSET			  Dword	 TXDATA:0325
PSP_SEG				  Word	 TXDATA:04D0
PSP_SEL				  Number 0040
PSP_SELECTOR			  Word	 TXDATA:0335
PUT_ERR_STRN			  Near	 TXCODE32:0D2A
PUT_SPACES			  Near	 TXCODE32:1A57
PUT_THE_CHAR			  Near	 TXCODE32:1A44
RAW_MSG				  Byte	 TXDATA:0102
READ				  Near	 TXCODE32:1555
READ_32K_BLOCKS			  Near	 TXCODE32:10FB
READ_BLOCK			  Near	 TXCODE32:1145
READ_ERROR			  Near	 TXCODE32:113D
READ_FILE			  Near	 TXCODE32:10DE
READ_ONLY			  Number 0000
READ_WRITE			  Number 0002
REALLOC				  Near	 TXCODE32:135F
REALLOC_ERROR			  Near	 TXCODE32:04E6
REAL_DS				  Word	 TXDATA:04F6
REAL_EAX			  Dword	 TXDATA:04EE
REAL_EBP			  Dword	 TXDATA:04DA
REAL_EBX			  Dword	 TXDATA:04E2
REAL_ECX			  Dword	 TXDATA:04EA
REAL_EDI			  Dword	 TXDATA:04D2
REAL_EDX			  Dword	 TXDATA:04E6
REAL_ES				  Word	 TXDATA:04F4
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 118
Symbol Table



REAL_ESI			  Dword	 TXDATA:04D6
REAL_FLAGS			  Word	 TXDATA:04F2
REAL_FS				  Word	 TXDATA:04F8
REAL_GS				  Word	 TXDATA:04FA
REAL_INT			  Near	 TXCODE32:099B
REAL_IRQ			  Near	 TXCODE32:0A5E
RECUPERA_INTS			  Near	 TXCODE32:1EB7
REG_OFFSETS			  Dword	 TXCODE32:0D81
REG_TO_HEX			  Near	 TXCODE32:0E24
REPARA_EXCS			  Near	 TXCODE:0B90
RESTORE_INTS			  Near	 TXCODE32:1E90
RET_INFO			  Dword	 TXDATA:0528
RET_REAL			  Near	 TXCODE:09BE
RET_REAL_ADDRESS		  Word	 TXDATA:0538
RET_REAL_RAW			  Near	 TXCODE:0000
RET_REAL_VCPI			  Near	 TXCODE:0038
RM_ENTRY			  Number OFFSET	TXCODE:05B7
RM_ENTRY_SIZE			  Number OFFSET	0007
RM_INT				  Near	 TXCODE:0454
RM_PROC_ADDRESS			  Dword	 TXCODE:04BA
RM_REGS_STRUC			  Word	 TXDATA:04D2
RM_STACKSIZE			  Number 1000
R_BIG				  Near	 TXCODE32:13FB
R_END				  Near	 TXCODE32:148C
R_EXIT				  Near	 TXCODE32:1561
R_KILL				  Near	 TXCODE32:1447
R_MALLOC			  Near	 TXCODE32:1463
R_NEWF				  Near	 TXCODE32:13B0
R_NONEXT			  Near	 TXCODE32:145B
R_NOTENOUGHT			  Near	 TXCODE32:1489
R_S_END				  Near	 TXCODE32:13F2
S16				  Near	 TXCODE:09F5
SALIDA				  Near	 TXCODE32:1E45
SALIDA_DPMI			  Near	 TXCODE32:1E89
SALTITO				  Byte	 TXCODE:0018
SAVE_DPMI_DATA			  Near	 TXCODE:0205
SEARCH_ADDRESS			  Near	 TXCODE32:085D
SEARCH_A_FREE_CALLBACK		  Near	 TXCODE32:07E7
SEARCH_FREE_DESCS		  Near	 TXCODE32:0507
SEARCH_NOPRESENT_ENTRIES	  Near	 TXCODE32:0757
SEEK				  Near	 TXCODE32:1562
SEEK_CUR			  Number 0001
SEEK_END			  Number 0002
SEEK_SET			  Number 0000
SELECTORS			  Number 0007
SELECTOR_FIXUP			  Near	 TXCODE32:1E06
SEL_OK				  Near	 TXCODE32:0DEB
SET_DESC			  Near	 TXCODE32:05A8
SET_DESC_ERROR			  Near	 TXCODE32:05EA
SET_DIR_ENTRIES			  Near	 TXCODE32:078F
SET_INT_VECTOR			  Near	 TXCODE32:067B
SET_PAGE_DIR_ENTRIES		  Near	 TXCODE:0115
SET_PAGE_TABLE_ENTRIES		  Near	 TXCODE:011C
SET_PM				  Near	 TXCODE:098E
SET_PM_ADDRESS			  Word	 TXDATA:0530
SET_PM_RAW			  Near	 TXCODE:001D
SET_PM_VCPI			  Near	 TXCODE:0090
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 119
Symbol Table



SET_RM_INT_VEC			  Near	 TXCODE32:08C0
SOURCE_OFF			  Word	 TXDATA:0CF7
SOURCE_TYPE			  Byte	 TXDATA:0CF5
SS_DE_PILA			  Near	 TXCODE32:0C7D
STACK_CONT1			  Byte	 TXDATA:07E0
STACK_CONT2			  Byte	 TXDATA:07E9
STACK_CONT3			  Byte	 TXDATA:07F2
STACK_FRAME			  Word	 TXCODE:04B4
STRING_COPIED			  Near	 TXCODE32:109B
SUMA_SELS			  Near	 TXCODE:0264
SYSTEM_TYPE			  Byte	 TXDATA:0341
SYS_DETERMINED			  Near	 TXCODE32:092F
SYS_TYPES			  Word	 TXDATA:00FA
SYS_TYPE_MSG			  Byte	 TXDATA:00E7
SYS_TYPE_VALS			  Byte	 TXCODE32:0931
TARGET_FLAGS			  Byte	 TXDATA:0CF6
TARGET_OFF			  Dword	 TXDATA:0CFB
TEST_A20			  Near	 TXCODE:0C5F
TRASH				  Word	 TXCODE:04B2
TSS_DESC			  Word	 TXDATA:05AC
TSS_SEL				  Number 0048
TX32_VERSION			  Number 0062
TXPR				  Dword	 TXPILA_REAL:0000
TX_INT21H			  Near	 TXCODE32:0F4D
TX_INT31H			  Near	 TXCODE32:001C
TX_PILA				  Dword	 TXPILA:0000
UNSUPORTED_FEATURE		  Near	 TXCODE32:19D3
UNSUPORTED_FEATURE_MSG		  Byte	 TXDATA:0257
V86_ERROR_MSG			  Byte	 TXDATA:0186
VCPI_CODE_SEL			  Number 0050
VCPI_CR3			  Dword	 TXDATA:054E
VCPI_CS_EIP			  Dword	 TXDATA:055E
VCPI_DESCS			  Byte	 TXDATA:05B4
VCPI_ENTRY_POINT		  Dword	 TXDATA:034B
VCPI_GDTR			  Dword	 TXDATA:0552
VCPI_IDTR			  Dword	 TXDATA:0556
VCPI_INIT			  Near	 TXCODE:00AE
VCPI_INIT_ERROR			  Near	 TXCODE:01D6
VCPI_INIT_ERR_MSG		  Byte	 TXDATA:035D
VCPI_LDTR			  Word	 TXDATA:055A
VCPI_MSG			  Byte	 TXDATA:0106
VCPI_NOT_PRESENT		  Near	 TXCODE:07B8
VCPI_SYS_REGS			  Word	 TXDATA:054E
VCPI_TR				  Word	 TXDATA:055C
VOLCADO_DESC			  Near	 TXCODE32:0E08
VUELCA_CODE			  Near	 TXCODE32:0BF5
VUELCA_DESC			  Near	 TXCODE32:0E0D
VUELCA_PILA			  Near	 TXCODE32:0D01
WAIT_FOR_A20			  Near	 TXCODE:0C80
WAIT_THAT_STATE			  Near	 TXCODE:0C52
WALK_OBJECT_TABLE		  Near	 TXCODE32:1743
WE_HAVE_IT			  Near	 TXCODE32:1708
WE_HAVE_SEL_TYPE		  Near	 TXCODE32:1963
WRITE_32K_BLOCKS		  Near	 TXCODE32:119C
WRITE_BLOCK			  Near	 TXCODE32:11E7
WRITE_ERROR			  Near	 TXCODE32:11DF
WRITE_FILE			  Near	 TXCODE32:1181
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 120
Symbol Table



WRITE_ONLY			  Number 0001
XMS_ALLOC_DONE			  Near	 TXCODE:0868
XMS_ENTRY_POINT			  Dword	 TXDATA:0347
XMS_HANDLES			  Byte	 TXCODE32:356A
XMS_MEMORY			  Number 0002
XMS_MEM_FREED			  Near	 TXCODE:0A62
XMS_MSG				  Byte	 TXDATA:0110
ZERO_DESCRIPTOR			  Byte	 TXDATA:0564
ZERO_SEL			  Word	 TXDATA:0331

Macro Name

ALLOC_XMS_MEM
COALESCE
FREE_XMS_MEM
LOOK_FOR_EXTENDED_BEGINNING
PUSHD
SAVE_VCPI_DATA

Structure Name			  Type	Offset

LEHEADER
 SIGNATURE			  Word	 0000
 BYTE_ORDER			  Byte	 0002
 WORD_ORDER			  Byte	 0003
 EXE_LEVEL			  Dword	 0004
 CPU_TYPE			  Word	 0008
 TARGET_OS			  Word	 000A
 MODULE_VERSION			  Dword	 000C
 MODULE_TYPE			  Dword	 0010
 MEMORY_PAGES			  Dword	 0014
 OBJECT_CS			  Dword	 0018
 OFFSET_EIP			  Dword	 001C
 OBJECT_SS			  Dword	 0020
 OFFSET_ESP			  Dword	 0024
 PAGE_SIZE			  Dword	 0028
 BYTES_LAST_PAGE		  Dword	 002C
 FIXUP_SECT_SIZE		  Dword	 0030
 FIXUP_CHECKSUM			  Dword	 0034
 LOAD_SECT_SIZE			  Dword	 0038
 LOAD_CHECKSUM			  Dword	 003C
 OFF_OBJECT_TBL			  Dword	 0040
 OBJ_TBL_ENTRIES		  Dword	 0044
 OFF_PAGE_MAP			  Dword	 0048
 OFF_OBJ_IT_DATA		  Dword	 004C
 OFF_RES_TABLE			  Dword	 0050
 RES_TBL_ENTRIES		  Dword	 0054
 OFF_RES_NAMES			  Dword	 0058
 OFF_ENTRY_TABLE		  Dword	 005C
 OFF_MOD_DIRS			  Dword	 0060
 NUM_MOD_DIRS			  Dword	 0064
 OFF_FIXUP_PAG			  Dword	 0068
 OFF_FIXUP_REC			  Dword	 006C
 OFF_IMPORT_MODS		  Dword	 0070
 NUM_IMPORT_MODS		  Dword	 0074
 OFF_IMPORT_PROC		  Dword	 0078
 OFF_PAGES_CHKSM		  Dword	 007C
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 121
Symbol Table



 OFF_DATA_PAGES			  Dword	 0080
 NUM_PRELOAD			  Dword	 0084
 OFF_NRES_NAMES			  Dword	 0088
 LEN_NRES_NAMES			  Dword	 008C
 NRES_NAMES_CHK			  Dword	 0090
 AUTO_DATA_OBJ			  Dword	 0094
 OFF_DBG_NFO			  Dword	 0098
 LEN_DBG_NFO			  Dword	 009C
 PRELOAD_INST_PG		  Dword	 00A0
 DEMAND_INST_PG			  Dword	 00A4
 EXTRA_HEAP			  Dword	 00A8
 LEH_RESERVED			  Dword	 00AC
OBJECT
 VIRTUAL_SIZE			  Dword	 0000
 RELOCATION_BASE		  Dword	 0004
 OBJECT_FLAGS			  Dword	 0008
 PAGE_MAP_INDEX			  Dword	 000C
 NUM_PAGES			  Dword	 0010
 OT_RESERVED			  Dword	 0014
OBJNFO
 OBJ_HANDLES			  Dword	 0000
 MEM_TYPE			  Byte	 0004
 OBJ_OFFSET			  Dword	 0005
TBLOCK
 BLEN				  Dword	 0000
 STATUS				  Byte	 0004
 MORE				  Byte	 0005
 SIGN				  Word	 0006
 PREV				  Dword	 0008
 NEXT				  Dword	 000C
TCALLBACK
 CALLBACK_STATE			  Byte	 0000
 RM_ENTRY_POINT			  Word	 0001
 PM_PROC_TO_CALL		  Struct 0003 TFWORD
 RM_CALL_STRUC			  Struct 0009 TFWORD
TFWORD
 LOFFSET			  Dword	 0000
 SELECTOR			  Word	 0004
THEAP
 START				  Dword	 0000
 HLEN				  Dword	 0004
TRM_REG
 RM_EDI				  Dword	 0000
 RM_ESI				  Dword	 0004
 RM_EBP				  Dword	 0008
 RM_EBX				  Dword	 0010
 RM_EDX				  Dword	 0014
 RM_ECX				  Dword	 0018
 RM_EAX				  Dword	 001C
 RM_FLAGS			  Word	 0020
 RM_ES				  Word	 0022
 RM_DS				  Word	 0024
 RM_FS				  Word	 0026
 RM_GS				  Word	 0028
 RM_IP				  Word	 002A
 RM_CS				  Word	 002C
 RM_SP				  Word	 002E
Turbo Assembler	 Version 3.1	    11/19/20 08:48:32	    Page 122
Symbol Table



 RM_SS				  Word	 0030

Groups & Segments		  Bit Size Align  Combine Class

DISK				  32  8000 Para	  none
TXCODE				  16  0E01 Para	  none	  CODE
TXCODE32			  32  4066 Para	  none	  CODE32
TXDATA				  16  0EDF Para	  none	  DATA
TXPILA				  16  4000 Para	  Stack	  STACK
TXPILA_REAL			  16  4000 Para	  none	  STACK
